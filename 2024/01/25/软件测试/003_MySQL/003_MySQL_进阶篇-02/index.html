<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>MySQL进阶篇 | 蜗牛浪迹天涯</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg"><!-- index.css--><link rel="stylesheet" href="/css/index.css"><!-- inject head--><link rel="stylesheet" href="https://cdn3.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><link rel="stylesheet" href="/lib/snackbar.min.css"><!-- comment--><!-- pace 胶囊加载条(Capsule loading bar)--><script src="https://cdn.bootcdn.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!-- search--><script src="https://cdn.bootcdn.net/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script><!-- aplayer--><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/Swiper/9.2.4/swiper-bundle.min.css"><!-- echarts--><script src="https://cdn.bootcdn.net/ajax/libs/echarts/5.4.2/echarts.min.js"></script><!-- 灰色纪念日(Gray Anniversary)--><!-- Open Graph--><meta name="description" content="# 视图 | 存储过程 | 触发器 视图介绍 视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条"><!-- pwa--><script>(win => {
        win.saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay,
                }
                localStorage.setItem(key, JSON.stringify(item))
            },

            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)

                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()

                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        }

        const DarkModeStatus = localStorage.getItem('theme')
        if (DarkModeStatus !== null) {
            if (DarkModeStatus === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark')
            } else {
                document.documentElement.setAttribute('data-theme', 'light')
            }
        }

        const asideStatus = saveToLocal.get('aside-status')
        if (asideStatus !== undefined) {
            if (asideStatus === 'hide') {
                document.documentElement.classList.add('hide-aside')
            } else {
                document.documentElement.classList.remove('hide-aside')
            }
        }
    }
)(window)

console.log(
    "%c🔥 程序：Hexo | 主题：Hexo-Theme-Solitude | 作者：王卓Sco、亦封 | Github: https://github.com/DuoSco/Hexo-theme-solitude | 版本：v1.3.0 😄",
    "color: #fff; background: linear-gradient(-25deg, #a8edea, #fed6e3); padding: 8px 15px; border-radius: 8px; text-shadow: 2px 2px 4px white; color: black;"
);
</script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script></div><!-- custom inject--><script>console.log("head")</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":true,"path":"/search.xml"},
    runtime: '2024-01-01 00:00:00',
    lazyload: {
        enable: true,
        error: '/img/error_load.png'
    },
    hightlight: {
        enable: true,
        limit: 200,
        expand: false,
        copy: true,
    },
    lightbox: true,
    randomlinks: false,
    lang: {
        theme: {
            dark: '已切换至深色模式',
            light: '已切换至浅色模式',
        },
        copy: {
            success: '复制成功',
            error: '复制失败',
        },
        backtop: '返回顶部',
        time: {
            recent: '最近',
            yesterday: '昨天',
            berforeyesterday: '前天',
            daybefore: '天前',
            runtime: '天',
        },
        sayhello: {
            morning: `一日之计在于晨`,
            noon: `吃饱了才有力气干活`,
            afternoon: `集中精力，攻克难关`,
            night: `不要太劳累了，早睡更健康`,
            goodnight: `睡个好觉，保证精力充沛`,
        },
        search: {
            empty: '找不到你查询的内容：${query}',
            hit: '找到 ${hits} 条结果，用时 ${time} 毫秒',
            placeholder: '输入关键词快速查找',
        }
    },
    covercolor: {
        enable: true
    },
    comment: {
        enable: false,
        type: 'twikoo',
        commentBarrage: false,
        randomInfoStart: ["聪敏的","可爱的","美丽的"],
        randomInfoEnd: ["白菜","小可爱","小仙女"],
        twikoo: {
            url: '',
            accessToken: ''
        },
        waline: {
            url: '',
        }
    },
    rightside: {
        enable: false
    },
    ai:{
        enable: false,
        key: '',
        talk: '我是王卓Sco开发的摘要生成助理ScoGPT，ScoGPT在静态部署时进行摘要的撰写，并且在访客访问时通过ScoCorrection转译后的文本摘要实现工具。我在这里只负责已经生成的摘要显示，你无法与我直接沟通，但我可以回答一些预设的问题。',
        randomPost: false,
    },
    music:{
        enable: true,
    }
}</script><meta name="generator" content="Hexo 6.3.0"></head><body id="body"><!-- loading--><div id="loading-box" onclick="preloader.endLoading();" style="zoom:1"><div class="loading-bg"><img class="loading-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="loading image"></div></div><script>const preloader = {
    endLoading: () => {
        document.getElementById('loading-box').classList.add('loaded');
    },
    initLoading: () => {
        document.getElementById('loading-box').classList.remove('loaded');
    },
    removePaceDone: () => {
        document.getElementById('body').classList = 'pace-done';
    }
}
window.addEventListener('load', () => {
    preloader.endLoading();
});
window.addEventListener('pjax:send', () => {
    preloader.initLoading();
});
document.addEventListener('pjax:complete', () => {
    preloader.endLoading();
});</script><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="scoicon sco-close-fill"></i></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><div class="author-content-item-title">最新评论</div></div><div class="aside-list"></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><div class="author-content-item-title">寻找感兴趣的领域</div></div><div class="card-tag-cloud"></div></div><div class="console-card history" onclick="sco.hideConsole()"><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" onclick="pjax.loadUrl('/archives/2024/')" href="javascript:void(0);"><span class="card-archive-list-date">2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">61</span><span class="card-archive-list-count-unit">篇</span></div></a></li></ul></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换" href="javascript:void(0);"><i class="scoicon sco-moon-clear-fill"></i></a></div><div class="console-btn-item" id="consoleHideAside"><a class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制" href="javascript:void(0);"><i class="scoicon sco-side-bar-fill"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="sco.musicToggle()"><a class="music-switch" title="音乐开关" href="javascript:void(0);"><i class="scoicon sco-disc-fill"></i></a></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()" href="javascript:void(0);"><i class="scoicon sco-moon-clear-fill"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/DuoSco/Hexo-Theme-solitude" title="Solitude"><img class="back-menu-item-icon" src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="项目"><span class="back-menu-item-text">Solitude</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="scoicon sco-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="scoicon sco-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="scoicon sco-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/moments/"><i class="scoicon sco-wifi-fill"></i><span>鱼塘</span></a></li><li><a class="site-page child" href="/links/"><i class="scoicon sco-group-fill"></i><span>友情链接</span></a></li><li><a class="site-page child" href="javascript:travelling()"><i class="scoicon sco-gift-fill"></i><span>宝藏博主</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/equipment/"><i class="scoicon sco-laptop-line"></i><span>装备</span></a></li><li><a class="site-page child" href="/tlink/"><i class="scoicon sco-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="scoicon sco-laptop-line"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="scoicon sco-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon scoicon sco-more-fill"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/DuoSco/Hexo-Theme-solitude" title="Solitude"><img class="back-menu-item-icon" src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="项目"><span class="back-menu-item-text">Solitude</span></a></div></div></div></div><a id="site-name" href="/" title="返回博客主页" target="_self"><span class="scoicon">首页</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">MySQL进阶篇</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="scoicon sco-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="scoicon sco-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="scoicon sco-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/moments/"><i class="scoicon sco-wifi-fill"></i><span>鱼塘</span></a></li><li><a class="site-page child" href="/links/"><i class="scoicon sco-group-fill"></i><span>友情链接</span></a></li><li><a class="site-page child" href="javascript:travelling()"><i class="scoicon sco-gift-fill"></i><span>宝藏博主</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/equipment/"><i class="scoicon sco-laptop-line"></i><span>装备</span></a></li><li><a class="site-page child" href="/tlink/"><i class="scoicon sco-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="scoicon sco-laptop-line"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="scoicon sco-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button"><a class="site-page" href="https://www.travellings.cn/go.html" title="开往-友链接力" target="_blank"><i class="scoicon sco-train-line"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机一篇文章" href="javascript:void(0);"><i class="scoicon sco-signal-tower-fill"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="scoicon sco-search-line"></i></a></div><div class="nav-button" id="nav-console"><a class="console_switchbutton" onclick="sco.showConsole()" title="中控台" href="javascript:void(0);"><i class="scoicon sco-dashboard-fill"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="scoicon sco-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="scoicon sco-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://tse2-mm.cn.bing.net/th/id/OIP-C.NHdSfyHemLa4eaycz7QR2AHaEK?w=333&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7" alt="MySQL进阶篇"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/软件测试/">软件测试</a></span><div class="tag_share"><div class="post-meta__tag-list"></div></div></div></div><h1 class="post-title">MySQL进阶篇</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="meta_posted 2024-01-25 04:00:00"><i class="post-meta-icon scoicon sco-calendar-todo-fill"></i><time datetime="2024-01-24T20:00:00.000Z">2024-01-24T20:00:00.000Z</time></span><span class="post-meta-date" title="meta_updated 2024-01-28 21:15:30"><i class="post-meta-icon scoicon sco-refresh-line"></i><time datetime="2024-01-28T13:15:30.835Z">2024-01-28T13:15:30.835Z</time></span><span class="post-meta-wordcount"><i class="post-meta-icon scoicon sco-word-fill" title="文章字数"></i><span class="word-count">16.6k</span><span class="post-meta-separator"></span><i class="post-meta-icon scoicon sco-clock-fill" title="阅读耗时"></i><span>63 min</span></span><span class="post-meta-position" title="作者IP归属地为衡阳"><i class="post-meta-icon scoicon sco-map-pin-fill"></i><span>衡阳</span></span><a class="post-meta-pv" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/003_MySQL_%E8%BF%9B%E9%98%B6%E7%AF%87-02/" title="文章热度"><i class="post-meta-icon scoicon sco-fire-fill"></i><span id="busuanzi_value_page_pv"><i class="scoicon sco-loading-line"></i></span></a></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />
# 视图 | 存储过程 | 触发器

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</li>
<li>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [</span><br><span class="line">CASCADED | LOCAL ] CHECK OPTION ]</span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看创建视图语句：SHOW CREATE VIEW 视图名称;</span><br><span class="line">查看视图数据：SELECT * FROM 视图名称 ...... ;</span><br></pre></td></tr></table></figure>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH</span><br><span class="line">[ CASCADED | LOCAL ] CHECK OPTION ]</span><br><span class="line"></span><br><span class="line">方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |</span><br><span class="line">LOCAL ] CHECK OPTION ]</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...</span><br></pre></td></tr></table></figure>

<h4 id="演示示例"><a href="#演示示例" class="headerlink" title="演示示例"></a>演示示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 创建视图</span><br><span class="line">create or replace view stu_v_1 as select id,name from student where id &lt;= 10;</span><br><span class="line">-- 查询视图</span><br><span class="line">show create view stu_v_1;</span><br><span class="line">select * from stu_v_1;</span><br><span class="line">select * from stu_v_1 where id &lt; 3;</span><br><span class="line">-- 修改视图</span><br><span class="line">create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10;</span><br><span class="line">alter view stu_v_1 as select id,name from student where id &lt;= 10;</span><br><span class="line">-- 删除视图</span><br><span class="line">drop view if exists stu_v_1;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述我们演示了，视图应该如何创建、查询、修改、删除，那么我们能不能通过视图来插入、更新数据呢？ 接下来，做一个测试。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;</span><br><span class="line">select * from stu_v_1;</span><br><span class="line">insert into stu_v_1 values(6,&#x27;Tom&#x27;);</span><br><span class="line">insert into stu_v_1 values(17,&#x27;Tom22&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>执行上述的SQL，我们会发现，id为6和17的数据都是可以成功插入的。 但是我们执行查询，查询出来的数据，却没有id为17的记录。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/09/6c1c23da145c441ba7d1dcacecd63e29" alt="image-20240109202707796"></p>
<ul>
<li>因为我们在创建视图的时候，指定的条件为 <code>id&lt;=10</code>, id为17的数据，是不符合条件的，所以没有查询出来，但是这条数据确实是已经成功的插入到了基表中。</li>
<li>如果我们定义视图时，如果指定了条件，然后我们在插入、修改、删除数据时，是否可以做到必须满足条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。</li>
</ul>
<h3 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h3><ul>
<li>当使用 WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。</li>
<li>MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。</li>
</ul>
<h4 id="CASCADED"><a href="#CASCADED" class="headerlink" title="CASCADED"></a>CASCADED</h4><ul>
<li>级联。比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图创建时未指定检查选项。 </li>
<li>则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/09/3c6e3526241f40359192efb0f2838361" alt="image-20240109203043440"></p>
<h4 id="LOCAL"><a href="#LOCAL" class="headerlink" title="LOCAL"></a>LOCAL</h4><ul>
<li>本地。比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创建时未指定检查选项。 </li>
<li>则在执行检查时，知会检查v2，不会检查v2的关联视图v1。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/09/20b7e47c639e4dc2a6144138886eaa3d" alt="image-20240109203112104"></p>
<h3 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h3><ul>
<li>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一</li>
<li>项，则该视图不可更新：<ul>
<li>A. 聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）</li>
<li>B. DISTINCT</li>
<li>C. GROUP BY</li>
<li>D. HAVING</li>
<li>E. UNION 或者 UNION ALL</li>
</ul>
</li>
</ul>
<p>示例 : </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create view stu_v_count as select count(*) from student;</span><br></pre></td></tr></table></figure>

<p>上述的视图中，就只有一个单行单列的数据，如果我们对这个视图进行更新或插入的，将会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into stu_v_count values(10);</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/09/d368551c05874ade8d08aa16d9e95b0f" alt="image-20240109203243913"></p>
<h3 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h3><h4 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h4><ul>
<li>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</li>
</ul>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><ul>
<li>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</li>
</ul>
<h4 id="数据独立"><a href="#数据独立" class="headerlink" title="数据独立"></a>数据独立</h4><ul>
<li>视图可帮助用户屏蔽真实表结构变化带来的影响。</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li>1). 为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view tb_user_view as select id,name,profession,age,gender,status,createtime</span><br><span class="line">from tb_user;</span><br><span class="line">select * from tb_user_view;</span><br></pre></td></tr></table></figure>

<ul>
<li>2). 查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create view tb_stu_course_view as select s.name student_name , s.no student_no ,</span><br><span class="line">c.name course_name from student s, student_course sc , course c where s.id =</span><br><span class="line">sc.studentid and sc.courseid = c.id;</span><br><span class="line">select * from tb_stu_course_view;</span><br></pre></td></tr></table></figure>

<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发</li>
<li>人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</li>
<li>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/09/9dbe4ca54c834abf963ec18aeb6efed2" alt="image-20240109204536532"></p>
<ul>
<li>特点:<ul>
<li>封装，复用 ———————–&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</li>
<li>可以接收参数，也可以返回数据 ——–&gt; 再存储过程中，可以传递参数，也可以接收返回值。</li>
<li>减少网络交互，效率提升 ————-&gt; 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</li>
</ul>
</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])</span><br><span class="line">BEGIN</span><br><span class="line">-- SQL语句</span><br><span class="line">END ;</span><br></pre></td></tr></table></figure>

<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL 名称 ([ 参数 ]);</span><br></pre></td></tr></table></figure>

<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#x27;xxx&#x27;;</span><br><span class="line">-- 查询指定数据库的存储过程及状态信息</span><br><span class="line">SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义</span><br></pre></td></tr></table></figure>

<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ；</span><br></pre></td></tr></table></figure>

<ul>
<li>注意:<ul>
<li>在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。</li>
</ul>
</li>
</ul>
<h4 id="演示示例-1"><a href="#演示示例-1" class="headerlink" title="演示示例"></a>演示示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 存储过程基本语法</span><br><span class="line">-- 创建</span><br><span class="line">create procedure p1()</span><br><span class="line">begin</span><br><span class="line">select count(*) from student;</span><br><span class="line">end;</span><br><span class="line">-- 调用</span><br><span class="line">call p1();</span><br><span class="line">-- 查看</span><br><span class="line">select * from information_schema.ROUTINES where ROUTINE_SCHEMA = &#x27;itcast&#x27;;</span><br><span class="line">show create procedure p1;</span><br><span class="line">-- 删除</span><br><span class="line">drop procedure if exists p1;</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</li>
</ul>
<h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><ul>
<li>系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</li>
<li>1). 查看系统变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量</span><br><span class="line">SHOW [ SESSION | GLOBAL ] VARIABLES LIKE &#x27;......&#x27;; -- 可以通过LIKE模糊匹配方式查找变量</span><br><span class="line">SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值</span><br></pre></td></tr></table></figure>

<ul>
<li>2). 设置系统变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;</span><br><span class="line">SET @@[SESSION | GLOBAL]系统变量名 = 值 ;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意:</p>
</li>
<li><p>如果没有指定SESSION&#x2F;GLOBAL，默认是SESSION，会话变量。</p>
</li>
<li><p>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 <code>/etc/my.cnf</code> 中配置。</p>
</li>
<li><p>A. 全局变量(GLOBAL): 全局变量针对于所有的会话。</p>
</li>
<li><p>B. 会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</p>
</li>
<li><p>演示示例 :</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 查看系统变量</span><br><span class="line">show session variables ;</span><br><span class="line">show session variables like &#x27;auto%&#x27;;</span><br><span class="line">show global variables like &#x27;auto%&#x27;;</span><br><span class="line">select @@global.autocommit;</span><br><span class="line">select @@session.autocommit;</span><br><span class="line">-- 设置系统变量</span><br><span class="line">set session autocommit = 1;</span><br><span class="line">insert into course(id, name) VALUES (6, &#x27;ES&#x27;);</span><br><span class="line">set global autocommit = 0;</span><br><span class="line">select @@global.autocommit;</span><br></pre></td></tr></table></figure>

<h4 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h4><ul>
<li><p>用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 <code>&quot;@变量名&quot;</code> 使用就可以。其作用域为当前连接。</p>
</li>
<li><p>赋值方式一:</p>
<ul>
<li>赋值时，可以使用 <code>=</code> ，也可以使用 <code>:= </code>。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET @var_name = expr [, @var_name = expr] ... ;</span><br><span class="line">SET @var_name := expr [, @var_name := expr] ... ;</span><br></pre></td></tr></table></figure>

<ul>
<li>赋值方式二:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @var_name := expr [, @var_name := expr] ... ;</span><br><span class="line">SELECT 字段名 INTO @var_name FROM 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<ul>
<li>注意: 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @var_name ;</span><br></pre></td></tr></table></figure>

<ul>
<li>演示示例:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 赋值</span><br><span class="line">set @myname = &#x27;itcast&#x27;;</span><br><span class="line">set @myage := 10;</span><br><span class="line">set @mygender := &#x27;男&#x27;,@myhobby := &#x27;java&#x27;;</span><br><span class="line">select @mycolor := &#x27;red&#x27;;</span><br><span class="line">select count(*) into @mycount from tb_user;</span><br><span class="line">-- 使用</span><br><span class="line">select @myname,@myage,@mygender,@myhobby;</span><br><span class="line">select @mycolor , @mycount;</span><br><span class="line">select @abc;</span><br></pre></td></tr></table></figure>

<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><ul>
<li><p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的 BEGIN … END 块。</p>
</li>
<li><p>声明</p>
<ul>
<li>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE 变量名 变量类型 [DEFAULT ... ] ;</span><br></pre></td></tr></table></figure>

<ul>
<li>赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 变量名 = 值 ;</span><br><span class="line">SET 变量名 := 值 ;</span><br><span class="line">SELECT 字段名 INTO 变量名 FROM 表名 ... ;</span><br></pre></td></tr></table></figure>

<ul>
<li>演示示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 声明局部变量 - declare</span><br><span class="line">-- 赋值</span><br><span class="line">create procedure p2()</span><br><span class="line">begin</span><br><span class="line">declare stu_count int default 0;</span><br><span class="line">select count(*) into stu_count from student;</span><br><span class="line">select stu_count;</span><br><span class="line">end;</span><br><span class="line">call p2();</span><br></pre></td></tr></table></figure>

<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>if 用于做条件判断，具体的语法结构为：<ul>
<li>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF 条件1 THEN</span><br><span class="line">.....</span><br><span class="line">ELSEIF 条件2 THEN -- 可选</span><br><span class="line">.....</span><br><span class="line">ELSE -- 可选</span><br><span class="line">.....</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><ul>
<li>根据定义的分数score变量，判定当前分数对应的分数等级。<ul>
<li>score &gt;&#x3D; 85分，等级为优秀。</li>
<li>score &gt;&#x3D; 60分 且 score &lt; 85分，等级为及格。</li>
<li>score &lt; 60分，等级为不及格。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create procedure p3()</span><br><span class="line">begin</span><br><span class="line">declare score int default 58;</span><br><span class="line">declare result varchar(10);</span><br><span class="line">if score &gt;= 85 then</span><br><span class="line">set result := &#x27;优秀&#x27;;</span><br><span class="line">elseif score &gt;= 60 then</span><br><span class="line">set result := &#x27;及格&#x27;;</span><br><span class="line">else</span><br><span class="line">set result := &#x27;不及格&#x27;;</span><br><span class="line">end if;</span><br><span class="line">select result;</span><br><span class="line">end;</span><br><span class="line">call p3();</span><br></pre></td></tr></table></figure>

<ul>
<li>上述的需求我们虽然已经实现了，但是也存在一些问题，比如：score 分数我们是在存储过程中定义死的，而且最终计算出来的分数等级，我们也仅仅是最终查询展示出来而已。</li>
<li>那么我们能不能，把score分数动态的传递进来，计算出来的分数等级是否可以作为返回值返回呢？<ul>
<li>答案是肯定的，我们可以通过接下来所讲解的 参数 来解决上述的问题。</li>
</ul>
</li>
</ul>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/a1d1b096f7ae4c11ba5f903ca03a2ebb" alt="image-20240110164922515"></p>
<ul>
<li>用法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])</span><br><span class="line">BEGIN</span><br><span class="line">-- SQL语句</span><br><span class="line">END ;</span><br></pre></td></tr></table></figure>

<ul>
<li>案例一</li>
<li>根据传入参数score，判定当前分数对应的分数等级，并返回。<ul>
<li>score &gt;&#x3D; 85分，等级为优秀。</li>
<li>score &gt;&#x3D; 60分 且 score &lt; 85分，等级为及格。</li>
<li>score &lt; 60分，等级为不及格。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create procedure p4(in score int, out result varchar(10))</span><br><span class="line">begin</span><br><span class="line">if score &gt;= 85 then</span><br><span class="line">set result := &#x27;优秀&#x27;;</span><br><span class="line">elseif score &gt;= 60 then</span><br><span class="line">set result := &#x27;及格&#x27;;</span><br><span class="line">else</span><br><span class="line">set result := &#x27;不及格&#x27;;</span><br><span class="line">end if;</span><br><span class="line">end;</span><br><span class="line">-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明</span><br><span class="line">call p4(18, @result);</span><br><span class="line">select @result;</span><br></pre></td></tr></table></figure>

<ul>
<li>案例二</li>
<li>将传入的200分制的分数，进行换算，换算成百分制，然后返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create procedure p5(inout score double)</span><br><span class="line">begin</span><br><span class="line">set score := score * 0.5;</span><br><span class="line">end;</span><br><span class="line">set @score = 198;</span><br><span class="line">call p5(@score);</span><br><span class="line">select @score;</span><br></pre></td></tr></table></figure>

<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>case结构及作用，和我们在基础篇中所讲解的流程控制函数很类似。有两种语法格式：</li>
<li>语法1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，</span><br><span class="line">执行statement_list2， 否则就执行 statement_list</span><br><span class="line">CASE case_value</span><br><span class="line">WHEN when_value1 THEN statement_list1</span><br><span class="line">[ WHEN when_value2 THEN statement_list2] ...</span><br><span class="line">[ ELSE statement_list ]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<ul>
<li>语法2：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成</span><br><span class="line">立时，执行statement_list2， 否则就执行 statement_list</span><br><span class="line">CASE</span><br><span class="line">WHEN search_condition1 THEN statement_list1</span><br><span class="line">[WHEN search_condition2 THEN statement_list2] ...</span><br><span class="line">[ELSE statement_list]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><ul>
<li>根据传入的月份，判定月份所属的季节（要求采用case结构）。<ul>
<li>1-3月份，为第一季度</li>
<li>4-6月份，为第二季度</li>
<li>7-9月份，为第三季度</li>
<li>10-12月份，为第四季度</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create procedure p6(in month int)</span><br><span class="line">begin</span><br><span class="line">declare result varchar(10);</span><br><span class="line">case</span><br><span class="line">when month &gt;= 1 and month &lt;= 3 then</span><br><span class="line">set result := &#x27;第一季度&#x27;;</span><br><span class="line">when month &gt;= 4 and month &lt;= 6 then</span><br><span class="line">set result := &#x27;第二季度&#x27;;</span><br><span class="line">when month &gt;= 7 and month &lt;= 9 then</span><br><span class="line">set result := &#x27;第三季度&#x27;;</span><br><span class="line">when month &gt;= 10 and month &lt;= 12 then</span><br><span class="line">set result := &#x27;第四季度&#x27;;</span><br><span class="line">else</span><br><span class="line">set result := &#x27;非法参数&#x27;;</span><br><span class="line">end case ;</span><br><span class="line">select concat(&#x27;您输入的月份为: &#x27;,month, &#x27;, 所属的季度为: &#x27;,result);</span><br><span class="line">end;</span><br><span class="line">call p6(16);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</li>
</ul>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span><br><span class="line">WHILE 条件 DO</span><br><span class="line">SQL逻辑...</span><br><span class="line">END WHILE;</span><br></pre></td></tr></table></figure>

<h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><ul>
<li>计算从1累加到n的值，n为传入的参数值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- A. 定义局部变量, 记录累加之后的值;</span><br><span class="line">-- B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环</span><br><span class="line">create procedure p7(in n int)</span><br><span class="line">begin</span><br><span class="line">declare total int default 0;</span><br><span class="line">while n&gt;0 do</span><br><span class="line">set total := total + n;</span><br><span class="line">set n := n - 1;</span><br><span class="line">end while;</span><br><span class="line">select total;</span><br><span class="line">end;</span><br><span class="line">call p7(100);</span><br></pre></td></tr></table></figure>

<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><h4 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">REPEAT</span><br><span class="line">SQL逻辑...</span><br><span class="line">UNTIL 条件</span><br><span class="line">END REPEAT;</span><br></pre></td></tr></table></figure>

<h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><ul>
<li>计算从1累加到n的值，n为传入的参数值。(使用repeat实现)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- A. 定义局部变量, 记录累加之后的值;</span><br><span class="line">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环</span><br><span class="line">create procedure p8(in n int)</span><br><span class="line">begin</span><br><span class="line">declare total int default 0;</span><br><span class="line">repeat</span><br><span class="line">set total := total + n;</span><br><span class="line">set n := n - 1;</span><br><span class="line">until n &lt;= 0</span><br><span class="line">end repeat;</span><br><span class="line">select total;</span><br><span class="line">end;</span><br><span class="line">call p8(10);</span><br><span class="line">call p8(100);</span><br></pre></td></tr></table></figure>

<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><h4 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。</li>
<li>LOOP可以配合一下两个语句使用：</li>
<li>LEAVE ：配合循环使用，退出循环。</li>
<li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">SQL逻辑...</span><br><span class="line">END LOOP [end_label];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEAVE label; -- 退出指定标记的循环体</span><br><span class="line">ITERATE label; -- 直接进入下一次循环</span><br></pre></td></tr></table></figure>

<ul>
<li>上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。</li>
</ul>
<h4 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h4><ul>
<li>案例一</li>
<li>计算从1累加到n的值，n为传入的参数值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- A. 定义局部变量, 记录累加之后的值;</span><br><span class="line">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx</span><br><span class="line">create procedure p9(in n int)</span><br><span class="line">begin</span><br><span class="line">declare total int default 0;</span><br><span class="line">sum:loop</span><br><span class="line">if n&lt;=0 then</span><br><span class="line">leave sum;</span><br><span class="line">end if;</span><br><span class="line">set total := total + n;</span><br><span class="line">set n := n - 1;</span><br><span class="line">end loop sum;</span><br><span class="line">select total;</span><br><span class="line">end;</span><br><span class="line">call p9(100);</span><br></pre></td></tr></table></figure>

<ul>
<li>案例二</li>
<li>计算从1到n之间的偶数累加的值，n为传入的参数值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- A. 定义局部变量, 记录累加之后的值;</span><br><span class="line">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx</span><br><span class="line">-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------&gt; iterate xx</span><br><span class="line">create procedure p10(in n int)</span><br><span class="line">begin</span><br><span class="line">declare total int default 0;</span><br><span class="line">sum:loop</span><br><span class="line">if n&lt;=0 then</span><br><span class="line">leave sum;</span><br><span class="line">end if;</span><br><span class="line">if n%2 = 1 then</span><br><span class="line">set n := n - 1;</span><br><span class="line">iterate sum;</span><br><span class="line">end if;</span><br><span class="line">set total := total + n;</span><br><span class="line">set n := n - 1;</span><br><span class="line">end loop sum;</span><br><span class="line">select total;</span><br><span class="line">end;</span><br><span class="line">call p10(100);</span><br></pre></td></tr></table></figure>

<h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><h4 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进</li>
<li>行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</li>
<li>A. 声明游标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE 游标名称 CURSOR FOR 查询语句 ;</span><br></pre></td></tr></table></figure>

<ul>
<li>B. 打开游标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN 游标名称 ;</span><br></pre></td></tr></table></figure>

<ul>
<li>C. 获取游标记录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH 游标名称 INTO 变量 [, 变量 ] ;</span><br></pre></td></tr></table></figure>

<ul>
<li>D. 关闭游标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE 游标名称 ;</span><br></pre></td></tr></table></figure>

<h4 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h4><ul>
<li>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 逻辑:</span><br><span class="line">-- A. 声明游标, 存储查询结果集</span><br><span class="line">-- B. 准备: 创建表结构</span><br><span class="line">-- C. 开启游标</span><br><span class="line">-- D. 获取游标中的记录</span><br><span class="line">-- E. 插入数据到新表中</span><br><span class="line">-- F. 关闭游标</span><br><span class="line">create procedure p11(in uage int)</span><br><span class="line">begin</span><br><span class="line">declare uname varchar(100);</span><br><span class="line">declare upro varchar(100);</span><br><span class="line">declare u_cursor cursor for select name,profession from tb_user where age &lt;=</span><br><span class="line">uage;</span><br><span class="line">drop table if exists tb_user_pro;</span><br><span class="line">create table if not exists tb_user_pro(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(100),</span><br><span class="line">profession varchar(100)</span><br><span class="line">);</span><br><span class="line">open u_cursor;</span><br><span class="line">while true do</span><br><span class="line">fetch u_cursor into uname,upro;</span><br><span class="line">insert into tb_user_pro values (null, uname, upro);</span><br><span class="line">end while;</span><br><span class="line">close u_cursor;</span><br><span class="line">end;</span><br><span class="line">call p11(30);</span><br></pre></td></tr></table></figure>

<ul>
<li>上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while循环中，并没有退出条件。当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/01d7ea9066d149b8a61bcb314559c488" alt="image-20240110171943702"></p>
<ul>
<li>但是此时，tb_user_pro表结构及其数据都已经插入成功了，我们可以直接刷新表结构，检查表结构中的数据。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/1eb18a0b422d47ed881187d8d897394c" alt="image-20240110172000588"></p>
<ul>
<li>上述的功能，虽然我们实现了，但是逻辑并不完善，而且程序执行完毕，获取不到数据，数据库还报错。 接下来，我们就需要来完成这个存储过程，并且解决这个问题。</li>
<li>要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handler 来解决。</li>
</ul>
<h3 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h3><h4 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DECLARE handler_action HANDLER FOR condition_value [, condition_value]</span><br><span class="line">... statement ;</span><br><span class="line">handler_action 的取值：</span><br><span class="line">CONTINUE: 继续执行当前程序</span><br><span class="line">EXIT: 终止执行当前程序</span><br><span class="line">condition_value 的取值：</span><br><span class="line">SQLSTATE sqlstate_value: 状态码，如 02000</span><br><span class="line">SQLWARNING: 所有以01开头的SQLSTATE代码的简写</span><br><span class="line">NOT FOUND: 所有以02开头的SQLSTATE代码的简写</span><br><span class="line">SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</span><br></pre></td></tr></table></figure>

<h4 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h4><ul>
<li>我们继续来完成在上一小节提出的这个需求，并解决其中的问题。</li>
<li>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</li>
<li>A. 通过SQLSTATE指定具体的状态码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-- 逻辑:</span><br><span class="line">-- A. 声明游标, 存储查询结果集</span><br><span class="line">-- B. 准备: 创建表结构</span><br><span class="line">-- C. 开启游标</span><br><span class="line">-- D. 获取游标中的记录</span><br><span class="line">-- E. 插入数据到新表中</span><br><span class="line">-- F. 关闭游标</span><br><span class="line">create procedure p11(in uage int)</span><br><span class="line">begin</span><br><span class="line">declare uname varchar(100);</span><br><span class="line">declare upro varchar(100);</span><br><span class="line">declare u_cursor cursor for select name,profession from tb_user where age &lt;=</span><br><span class="line">uage;</span><br><span class="line">-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出</span><br><span class="line">declare exit handler for SQLSTATE &#x27;02000&#x27; close u_cursor;</span><br><span class="line">drop table if exists tb_user_pro;</span><br><span class="line">create table if not exists tb_user_pro(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(100),</span><br><span class="line">profession varchar(100)</span><br><span class="line">);</span><br><span class="line">open u_cursor;</span><br><span class="line">while true do</span><br><span class="line">fetch u_cursor into uname,upro;</span><br><span class="line">insert into tb_user_pro values (null, uname, upro);</span><br><span class="line">end while;</span><br><span class="line">close u_cursor;</span><br><span class="line">end;</span><br><span class="line">call p11(30);</span><br></pre></td></tr></table></figure>

<ul>
<li>B. 通过SQLSTATE的代码简写方式 NOT FOUND</li>
<li>02 开头的状态码，代码简写为 NOT FOUND</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">create procedure p12(in uage int)</span><br><span class="line">begin</span><br><span class="line">declare uname varchar(100);</span><br><span class="line">declare upro varchar(100);</span><br><span class="line">declare u_cursor cursor for select name,profession from tb_user where age &lt;=</span><br><span class="line">uage;</span><br><span class="line">-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02开头时，将关闭游标u_cursor，并退出</span><br><span class="line">declare exit handler for not found close u_cursor;</span><br><span class="line">drop table if exists tb_user_pro;</span><br><span class="line">create table if not exists tb_user_pro(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">  name varchar(100),</span><br><span class="line">profession varchar(100)</span><br><span class="line">);</span><br><span class="line">open u_cursor;</span><br><span class="line">while true do</span><br><span class="line">fetch u_cursor into uname,upro;</span><br><span class="line">insert into tb_user_pro values (null, uname, upro);</span><br><span class="line">end while;</span><br><span class="line">close u_cursor;</span><br><span class="line">end;</span><br><span class="line">call p12(30);</span><br></pre></td></tr></table></figure>

<ul>
<li>具体的错误状态码，可以参考官方文档：</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html">https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html</a></li>
</ul>
<h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。</li>
<li>具体语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION 存储函数名称 ([ 参数列表 ])</span><br><span class="line">RETURNS type [characteristic ...]</span><br><span class="line">BEGIN</span><br><span class="line">-- SQL语句</span><br><span class="line">RETURN ...;</span><br><span class="line">END ;</span><br></pre></td></tr></table></figure>

<ul>
<li>characteristic说明：<ul>
<li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li>
<li>NO SQL ：不包含 SQL 语句。</li>
<li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li>
</ul>
</li>
</ul>
<h3 id="案例-8"><a href="#案例-8" class="headerlink" title="案例"></a>案例</h3><ul>
<li>计算从1累加到n的值，n为传入的参数值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create function fun1(n int)</span><br><span class="line">returns int deterministic</span><br><span class="line">begin</span><br><span class="line">declare total int default 0;</span><br><span class="line">while n&gt;0 do</span><br><span class="line">set total := total + n;</span><br><span class="line">set n := n - 1;</span><br><span class="line">end while;</span><br><span class="line">return total;</span><br><span class="line">end;</span><br><span class="line">select fun1(50);</span><br></pre></td></tr></table></figure>

<ul>
<li>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定characteristic特性，否则就会报如下错误：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/950ed1eb716e4739a0376e041186132a" alt="image-20240110173045392"></p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作 。</li>
<li>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/09212c68adf64ab8b92e7391f65e973e" alt="image-20240110173634149"></p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name</span><br><span class="line">BEFORE/AFTER INSERT/UPDATE/DELETE</span><br><span class="line">ON tbl_name FOR EACH ROW -- 行级触发器</span><br><span class="line">BEGIN</span><br><span class="line">trigger_stmt ;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<h4 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TRIGGERS ;</span><br></pre></td></tr></table></figure>

<h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER [schema_name.]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库 。</span><br></pre></td></tr></table></figure>

<h3 id="案例-9"><a href="#案例-9" class="headerlink" title="案例"></a>案例</h3><ul>
<li>通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加,修改 , 删除 ;</li>
<li>表结构准备:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 准备工作 : 日志表 user_logs</span><br><span class="line">create table user_logs(</span><br><span class="line">id int(11) not null auto_increment,</span><br><span class="line">operation varchar(20) not null comment &#x27;操作类型, insert/update/delete&#x27;,</span><br><span class="line">operate_time datetime not null comment &#x27;操作时间&#x27;,</span><br><span class="line">operate_id int(11) not null comment &#x27;操作的ID&#x27;,</span><br><span class="line">operate_params varchar(500) comment &#x27;操作参数&#x27;,</span><br><span class="line">primary key(`id`)</span><br><span class="line">)engine=innodb default charset=utf8;</span><br></pre></td></tr></table></figure>

<ul>
<li>A. 插入数据触发器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create trigger tb_user_insert_trigger</span><br><span class="line">after insert on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">insert into user_logs(id, operation, operate_time, operate_id, operate_params)</span><br><span class="line">VALUES</span><br><span class="line">(null, &#x27;insert&#x27;, now(), new.id, concat(&#x27;插入的数据内容为:</span><br><span class="line">id=&#x27;,new.id,&#x27;,name=&#x27;,new.name, &#x27;, phone=&#x27;, NEW.phone, &#x27;, email=&#x27;, NEW.email, &#x27;,</span><br><span class="line">profession=&#x27;, NEW.profession));</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试:<ul>
<li>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看</span><br><span class="line">show triggers ;</span><br><span class="line">-- 插入数据到tb_user</span><br><span class="line">insert into tb_user(id, name, phone, email, profession, age, gender, status,</span><br><span class="line">createtime) VALUES (26,&#x27;三皇子&#x27;,&#x27;18809091212&#x27;,&#x27;erhuangzi@163.com&#x27;,&#x27;软件工</span><br><span class="line">程&#x27;,23,&#x27;1&#x27;,&#x27;1&#x27;,now());</span><br></pre></td></tr></table></figure>

<ul>
<li>B. 修改数据触发器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create trigger tb_user_update_trigger</span><br><span class="line">after update on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">insert into user_logs(id, operation, operate_time, operate_id, operate_params)</span><br><span class="line">VALUES</span><br><span class="line">(null, &#x27;update&#x27;, now(), new.id,</span><br><span class="line">concat(&#x27;更新之前的数据: id=&#x27;,old.id,&#x27;,name=&#x27;,old.name, &#x27;, phone=&#x27;,</span><br><span class="line">old.phone, &#x27;, email=&#x27;, old.email, &#x27;, profession=&#x27;, old.profession,</span><br><span class="line">&#x27; | 更新之后的数据: id=&#x27;,new.id,&#x27;,name=&#x27;,new.name, &#x27;, phone=&#x27;,</span><br><span class="line">NEW.phone, &#x27;, email=&#x27;, NEW.email, &#x27;, profession=&#x27;, NEW.profession));</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试:<ul>
<li>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查看</span><br><span class="line">show triggers ;</span><br><span class="line">-- 更新</span><br><span class="line">update tb_user set profession = &#x27;会计&#x27; where id = 23;</span><br><span class="line">update tb_user set profession = &#x27;会计&#x27; where id &lt;= 5;</span><br></pre></td></tr></table></figure>

<ul>
<li>C. 删除数据触发器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create trigger tb_user_delete_trigger</span><br><span class="line">after delete on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">insert into user_logs(id, operation, operate_time, operate_id, operate_params)</span><br><span class="line">VALUES</span><br><span class="line">(null, &#x27;delete&#x27;, now(), old.id,</span><br><span class="line">concat(&#x27;删除之前的数据: id=&#x27;,old.id,&#x27;,name=&#x27;,old.name, &#x27;, phone=&#x27;,</span><br><span class="line">old.phone, &#x27;, email=&#x27;, old.email, &#x27;, profession=&#x27;, old.profession));</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试:<ul>
<li>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查看</span><br><span class="line">show triggers ;</span><br><span class="line">-- 删除数据</span><br><span class="line">delete from tb_user where id = 26;</span><br></pre></td></tr></table></figure>

<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</li>
<li>从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</li>
<li>MySQL中的锁，按照锁的粒度分，分为以下三类：<ul>
<li>全局锁：锁定数据库中的所有表。</li>
<li>表级锁：每次操作锁住整张表。</li>
<li>行级锁：每次操作锁住对应的行数据。</li>
</ul>
</li>
</ul>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>
</li>
<li><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
</li>
<li><p>为什么全库逻辑备份，就需要加全就锁呢？</p>
</li>
<li><p>A. 我们一起先来分析一下不加全局锁，可能存在的问题。</p>
<ul>
<li>假设在数据库中存在这样三张表: tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表。</li>
<li>在进行数据备份时，先备份了tb_stock库存表。</li>
<li>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。</li>
<li>然后再执行备份 tb_order表的逻辑。</li>
<li>业务中执行插入订单日志操作。</li>
<li>最后，又备份了tb_orderlog表。</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/cfb1dbb2870a4d8abc14534fecf0e373" alt="image-20240110204203397"></p>
<ul>
<li><p>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一致(有最新操作的订单信息,但是库存数没减)。</p>
</li>
<li><p>那如何来规避这种问题呢? 此时就可以借助于MySQL的全局锁来解决。</p>
</li>
<li><p>B. 再来分析一下加了全局锁后的情况</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/c6187c17a8ef48c48ed9eba69f24965a" alt="image-20240110205451077"></p>
<ul>
<li>对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。</li>
<li>那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</li>
</ul>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><ul>
<li>加全局锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables with read lock ;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据备份<ul>
<li>数据备份的相关指令, 在后面MySQL管理章节, 还会详细讲解.</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot –p1234 itcast &gt; itcast.sql</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables ;</span><br></pre></td></tr></table></figure>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>数据库中加全局锁，是一个比较重的操作，存在以下问题：<ul>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li>
</ul>
</li>
<li>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot –p123456 itcast &gt; itcast.sql</span><br></pre></td></tr></table></figure>

<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</li>
<li>对于表级锁，主要分为以下三类：<ul>
<li>表锁</li>
<li>元数据锁（meta data lock，MDL）</li>
<li>意向锁</li>
</ul>
</li>
</ul>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul>
<li><p>对于表锁，分为两类：</p>
<ul>
<li>表共享读锁（read lock）</li>
<li>表独占写锁（write lock）</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li>加锁：lock tables 表名… read&#x2F;write。</li>
<li>释放锁：unlock tables &#x2F; 客户端断开连接 。</li>
</ul>
</li>
<li><p>特点:</p>
</li>
<li><p>A. 读锁</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/80cd3486c3df48038df67b89c713174e" alt="image-20240110211353930"></p>
<ul>
<li>左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。</li>
<li>测试:</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/57446882868040e48cb4133e0a5244b2" alt="image-20240110211410112"></p>
<ul>
<li>B. 写锁</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/a6f57e78569b41b48a91e9198b5b63ca" alt="image-20240110211429208"></p>
<ul>
<li>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</li>
<li>测试:</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/ac1a7dfe9b144d4d9259925210c2960d" alt="image-20240110211447363"></p>
<ul>
<li>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</li>
</ul>
<h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><ul>
<li>meta data lock , 元数据锁，简写MDL。</li>
<li>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</li>
<li>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</li>
<li>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</li>
<li>常见的SQL操作时，所添加的元数据锁：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/cb17cb94a541432f8714aae973fc4e5c" alt="image-20240110211604096"></p>
<ul>
<li>演示：</li>
<li>当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ &#x2F; SHARED_WRITE），之间是兼容的。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/d018513fb7db4deda9d031188d5ac4c8" alt="image-20240110211635383"></p>
<ul>
<li>当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁（EXCLUSIVE），之间是互斥的。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/3a7ee2a8ebee4fc3a3c2a8cd89e6c2be" alt="image-20240110211700677"></p>
<ul>
<li>我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select object_type,object_schema,object_name,lock_type,lock_duration from</span><br><span class="line">performance_schema.metadata_locks ;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们在操作过程中，可以通过上述的SQL语句，来查看元数据锁的加锁情况。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/10/7d1677e4953b4478ad16e979e6d1ee67" alt="image-20240110211733045"></p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><h4 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</li>
<li>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</li>
<li>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/9761d2525b4a4128a847b420d816bd95" alt="image-20240113201426318"></p>
<ul>
<li>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/236c1cd0b40c40f29ae811140a314e2a" alt="image-20240113201444575"></p>
<ul>
<li>有了意向锁之后 :<ul>
<li>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/290a379bc06547d692f596a7bb24abba" alt="image-20240113201506475"></p>
<ul>
<li>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/e5174a9f0a624af9ab21059ac32fde1c" alt="image-20240113201520823"></p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</li>
<li>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li>
<li>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</li>
<li>可以通过以下SQL，查看意向锁及行锁的加锁情况：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<ul>
<li>演示 A. 意向共享锁与表读锁是兼容的</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/15688d0f06b244cf8bd00d65c7b95e7b" alt="image-20240113201640993"></p>
<ul>
<li>B. 意向排他锁与表读锁、写锁都是互斥的</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/1b4cc5a4eb7543a98d0a484171f88c69"></p>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><h3 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</li>
<li>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</li>
<li><strong>行锁</strong>（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/fa42b18c8555469b9b5735e5345fc871" alt="image-20240113201950298"></p>
<ul>
<li><strong>间隙锁</strong>（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/35a3cbc3fa71431a9253035c562e9460" alt="image-20240113202009741"></p>
<ul>
<li><strong>临键锁</strong>（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/cd22baa33505478b9a857081908a2eea" alt="image-20240113202023135"></p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><h4 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>InnoDB实现了以下两种类型的行锁：<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li>
</ul>
</li>
<li>两种行锁的兼容情况如下:</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/80de9f0df7ca4cb583f468731233d1a2" alt="image-20240113202117083"></p>
<ul>
<li>常见的SQL语句，在执行时，所加的行锁如下：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/7892660969ba4a2fa700955e4eeb16a0" alt="image-20240113202141671"></p>
<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><ul>
<li>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。<ul>
<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li>
<li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。</li>
</ul>
</li>
<li>可以通过以下SQL，查看意向锁及行锁的加锁情况：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据准备:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `stu` (</span><br><span class="line">`id` int NOT NULL PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">`name` varchar(255) DEFAULT NULL,</span><br><span class="line">`age` int NOT NULL</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8mb4;</span><br><span class="line"></span><br><span class="line">INSERT INTO `stu` VALUES (1, &#x27;tom&#x27;, 1);</span><br><span class="line">INSERT INTO `stu` VALUES (3, &#x27;cat&#x27;, 3);</span><br><span class="line">INSERT INTO `stu` VALUES (8, &#x27;rose&#x27;, 8);</span><br><span class="line">INSERT INTO `stu` VALUES (11, &#x27;jetty&#x27;, 11);</span><br><span class="line">INSERT INTO `stu` VALUES (19, &#x27;lily&#x27;, 19);</span><br><span class="line">INSERT INTO `stu` VALUES (25, &#x27;luci&#x27;, 25);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>演示行锁的时候，我们就通过上面这张表来演示一下。</p>
</li>
<li><p>A. 普通的select语句，执行时，不会加锁。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/6e7002ed89184220a3a3520abd70f9e3" alt="image-20240113202542679"></p>
<ul>
<li>B. select…lock in share mode，加共享锁，共享锁与共享锁之间兼容。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/6fd40f70c8bc4f108927c1f98d4c1202" alt="image-20240113202601076"></p>
<ul>
<li>共享锁与排他锁之间互斥。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/4f37c80fa345440697b3a4509a89019c" alt="image-20240113202615540"></p>
<ul>
<li><p>客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，以为共享锁与排他锁之间互斥。</p>
</li>
<li><p>C. 排它锁与排他锁之间互斥</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/1e667f8d03ff4787a3f87f82e2d2078f" alt="image-20240113202700842"></p>
<ul>
<li><p>当客户端一，执行update语句，会为id为1的记录加排他锁； 客户端二，如果也执行update语句更新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互斥的。 直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞。</p>
</li>
<li><p>D. 无索引行锁升级为表锁</p>
<ul>
<li>stu表中数据如下:</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/40a24df575a048e497dad3a098f81616" alt="image-20240113202739059"></p>
<ul>
<li>我们在两个客户端中执行如下操作:</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/2c0253c04e5b4f69ab266e65923af5b8" alt="image-20240113202925293"></p>
<ul>
<li>在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。</li>
<li>然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态，为什么呢？<ul>
<li>原因就是因为此时，客户端一，根据name字段进行更新时，name字段是没有索引的，如果没有索引，此时行锁会升级为表锁(因为行锁是对索引项加的锁，而name没有索引)。</li>
</ul>
</li>
<li>接下来，我们再针对name字段建立索引，索引建立之后，再次做一个测试：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/ca58df0eefaa4d07ab4bc290c0dfcd62" alt="image-20240113202954469"></p>
<ul>
<li>此时我们可以看到，客户端一，开启事务，然后依然是根据name进行更新。而客户端二，在更新id为3的数据时，更新成功，并未进入阻塞状态。 这样就说明，我们根据索引字段进行更新操作，就可以避免行锁升级为表锁的情况。</li>
</ul>
<h3 id="间隙锁-临键锁"><a href="#间隙锁-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h3><h4 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。<ul>
<li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li>
<li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</li>
<li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li>
</ul>
</li>
<li>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</li>
</ul>
<h4 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h4><ul>
<li>A. 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/9780437dc82e4301a8660f0183f12847" alt="image-20240113203213817"></p>
<ul>
<li><p>B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</p>
</li>
<li><p>介绍分析一下：</p>
<ul>
<li>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/f0e82d588f334b30b012c4568b21dd7a" alt="image-20240113203250611"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/d5a6d0349172422a885889793b74e18f" alt="image-20240113203258811"></p>
<ul>
<li>C. 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/e3b2f6a2881d426fb037eb4eea8d78e6" alt="image-20240113203314267"></p>
<ul>
<li><p>查询的条件为id&gt;&#x3D;19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：</p>
<ul>
<li><p>[19]</p>
</li>
<li><p>(19,25]</p>
</li>
<li><p>(25,+∞]</p>
</li>
</ul>
</li>
<li><p>所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)。</p>
</li>
</ul>
<h1 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h1><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><ul>
<li>InnoDB的逻辑存储结构如下图所示:</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/1644810697d74121ac77b446fbb85cdb" alt="image-20240113203737751"></p>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><ul>
<li>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</li>
</ul>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><ul>
<li>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</li>
</ul>
<h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><ul>
<li>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</li>
</ul>
<h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><ul>
<li>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li>
</ul>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><ul>
<li>行，InnoDB 存储引擎数据是按行进行存放的。</li>
<li>在行中，默认有两个隐藏字段：<ul>
<li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li>
<li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/665cb2544a5647adbf1846c6e47e1cd7" alt="image-20240113203932172"></p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/e07969e554a54e0f8e72531b1eb6dc6e" alt="image-20240113204133485"></p>
<ul>
<li>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 接下来介绍一下这四个部分。</li>
</ul>
<h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><ul>
<li>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I&#x2F;O。</li>
<li>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</li>
<li>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</li>
<li>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：<ul>
<li>• free page：空闲page，未被使用。</li>
<li>• clean page：被使用page，数据没有被修改过。</li>
<li>• dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</li>
</ul>
</li>
<li>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置： show variables like ‘innodb_buffer_pool_size’;</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/d524badf78b74157bd1dabb3ad64b3c7" alt="image-20240113204355895"></p>
<h4 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h4><ul>
<li>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</li>
<li>Change Buffer的意义是什么呢?</li>
<li>先来看一幅图，这个是二级索引的结构图：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/b398af3740d044fe8dbb4f659fd09f52" alt="image-20240113204425434"></p>
<ul>
<li><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。</p>
</li>
<li><p>有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p>
</li>
</ul>
<h4 id="Adaptive-Hash-Index"><a href="#Adaptive-Hash-Index" class="headerlink" title="Adaptive Hash Index"></a>Adaptive Hash Index</h4><ul>
<li><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p>
</li>
<li><p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p>
</li>
<li><p>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</p>
</li>
<li><p>参数： adaptive_hash_index</p>
</li>
</ul>
<h4 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h4><ul>
<li>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</li>
<li>参数:<ul>
<li>innodb_log_buffer_size：缓冲区大小</li>
<li>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：<ul>
<li>0: 每秒将日志写入并刷新到磁盘一次。</li>
<li>1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</li>
<li>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/976d8e38856c49599b0e6143e1498dee" alt="image-20240113205151279"></p>
<h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><ul>
<li>接下来，再来看看InnoDB体系结构的右边部分，也就是磁盘结构：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/bf72e00459e64fa09a7a55d1a0afd036" alt="image-20240113205359065"></p>
<h4 id="System-Tablespace"><a href="#System-Tablespace" class="headerlink" title="System Tablespace"></a>System Tablespace</h4><ul>
<li>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</li>
<li>系统表空间，默认的文件名叫 ibdata1。</li>
<li>参数：innodb_data_file_path</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/0e6423c4a7ca441ab036ab1e4b58c6bb" alt="image-20240113205452147"></p>
<h4 id="File-Per-Table-Tablespaces"><a href="#File-Per-Table-Tablespaces" class="headerlink" title="File-Per-Table Tablespaces"></a>File-Per-Table Tablespaces</h4><ul>
<li>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。</li>
<li>开关参数：innodb_file_per_table ，该参数默认开启。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/73b6ec3a1324472fb6f1766be2f2bb5d" alt="image-20240113210016284"></p>
<ul>
<li>那也就是说，我们没创建一个表，都会产生一个表空间文件，如图：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/54a20fee1c9e49ab8507033f0daa1121" alt="image-20240113210255712"></p>
<h4 id="General-Tablespaces"><a href="#General-Tablespaces" class="headerlink" title="General Tablespaces"></a>General Tablespaces</h4><ul>
<li>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</li>
<li>A. 创建表空间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLESPACE ts_name ADD DATAFILE &#x27;file_name&#x27; ENGINE = engine_name;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/0d8b940d2dfe44f890035b9ab73cb099" alt="image-20240113210411948"></p>
<ul>
<li>B. 创建表时指定表空间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE xxx ... TABLESPACE ts_name;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/f3ad8bf5a38b4408bf84cef64d57f528" alt="image-20240113210403581"></p>
<h4 id="Undo-Tablespaces"><a href="#Undo-Tablespaces" class="headerlink" title="Undo Tablespaces"></a>Undo Tablespaces</h4><ul>
<li>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。</li>
</ul>
<h4 id="Temporary-Tablespaces"><a href="#Temporary-Tablespaces" class="headerlink" title="Temporary Tablespaces"></a>Temporary Tablespaces</h4><ul>
<li>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</li>
</ul>
<h4 id="Doublewrite-Buffer-Files"><a href="#Doublewrite-Buffer-Files" class="headerlink" title="Doublewrite Buffer Files"></a>Doublewrite Buffer Files</h4><ul>
<li>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/de3d14ce9b0b4d7c92c236b85cfe8c41" alt="image-20240113211223917"></p>
<h4 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h4><ul>
<li>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。</li>
<li>以循环方式写入重做日志文件，涉及两个文件：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/d41fd15888634098b62f06401b008cef" alt="image-20240113211325802"></p>
<ul>
<li>前面我们介绍了InnoDB的内存结构，以及磁盘结构，那么内存中我们所更新的数据，又是如何到磁盘中的呢？ 此时，就涉及到一组后台线程，接下来，就来介绍一些InnoDB中涉及到的后台线程。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/d559506457fc411eac504ef61669873e" alt="image-20240113211346534"></p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/27804a26b9e34d1487a94b7305cca87c" alt="image-20240113211559965"></p>
<ul>
<li>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread。</li>
</ul>
<h4 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h4><ul>
<li>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。</li>
</ul>
<h4 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h4><ul>
<li>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/933b1b8e1d35412eabb362506e5610ec" alt="image-20240113212936380"></p>
<ul>
<li>我们可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status \G;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/13/01a06d9b5d184ba6984c6e65871af166" alt="image-20240113213026112"></p>
<h4 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h4><ul>
<li>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</li>
</ul>
<h4 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h4><ul>
<li>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</li>
</ul>
<h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul>
<li>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</li>
</ul>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li><p>• 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p>
</li>
<li><p>• 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p>
</li>
<li><p>• 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p>
</li>
<li><p>• 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p>
</li>
<li><p>那实际上，我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/6319cc5b14954f0d88652cf9d9a3f898" alt="image-20240115080541932"></p>
<ul>
<li>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 而持久性是通过数据库的锁，加上MVCC来保证的。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/3b7aab7976b1475c8b79212e33f616e4" alt="image-20240115080614069"></p>
<ul>
<li>我们在讲解事务原理的时候，主要就是来研究一下redolog，undolog以及MVCC。</li>
</ul>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><ul>
<li><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p>
</li>
<li><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p>
</li>
<li><p>如果没有redolog，可能会存在什么问题的？ 我们一起来分析一下。</p>
</li>
<li><p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 </p>
</li>
<li><p>当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/54424ceae8c441ebb9186b4cf8bd8bfc" alt="image-20240115080809349"></p>
<ul>
<li>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一下，通过redolog如何解决这个问题。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/664d17958c194a15a619551c3f545761" alt="image-20240115080827509"></p>
<ul>
<li><p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。</p>
</li>
<li><p>过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p>
</li>
<li><p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?</p>
<ul>
<li>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 </li>
<li>而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 </li>
<li>这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</li>
</ul>
</li>
</ul>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><ul>
<li>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。</li>
<li>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li>
<li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li>
<li>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><ul>
<li>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</li>
<li>对于我们日常的操作，如：select … lock in share mode(共享锁)，select …for update、update、insert、delete(排他锁)都是一种当前读。</li>
<li>测试：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/580566e379f74750b78b5f8bb5db4702" alt="image-20240115081521019"></p>
<ul>
<li>在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们加排他锁的时候，也是当前读操作。</li>
</ul>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><ul>
<li>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。<ul>
<li>• Read Committed：每次select，都生成一个快照读。</li>
<li>• Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li>
<li>• Serializable：快照读会退化为当前读。</li>
</ul>
</li>
<li>测试:</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/bab6cc2e780c481b8d4ff12f5105b4da" alt="image-20240115081557593"></p>
<ul>
<li>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</li>
</ul>
<h4 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a>MVCC</h4><ul>
<li>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</li>
<li>接下来，我们再来介绍一下InnoDB引擎的表中涉及到的隐藏字段 、undolog 以及 readview，从而来介绍一下MVCC的原理。</li>
</ul>
<h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><h4 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍"></a>介绍</h4><p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/391843677f7e40519bd30815e910bb48" alt="image-20240115081655850"></p>
<ul>
<li>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/273ff53b25be42359c3527792ce7acd9" alt="image-20240115081716096"></p>
<ul>
<li>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul>
<li>01 查看有主键的表 stu<ul>
<li>进入服务器中的 <code>/var/lib/mysql/itcast/</code> , 查看stu的表结构信息, 通过如下指令:</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi stu.ibd</span><br></pre></td></tr></table></figure>

<ul>
<li>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，因为该表有主键，所以没有DB_ROW_ID 隐藏字段。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/d4a93bb5237f4c3884948780a75bd8f5" alt="image-20240115081835457"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/c636003391764b6cade2ecd3451d0523" alt="image-20240115081854627"></p>
<ul>
<li><p>02 查看没有主键的表 employee</p>
</li>
<li><p>建表语句：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table employee (id int , name varchar(10));</span><br></pre></td></tr></table></figure>

<ul>
<li>此时，我们再通过以下指令来查看表结构及其其中的字段信息：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi employee.ibd</span><br></pre></td></tr></table></figure>

<ul>
<li>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有额外的三个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为employee表是没有指定主键的。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/8084ad8c0ef54e948daac85cddd9cf08" alt="image-20240115082032389"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/cdccff51521e4a91a406a04daa0f3e81" alt="image-20240115082045195"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/3a9687f26e7d453ba65d8d354d5f51c5" alt="image-20240115082057775"></p>
<h3 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h3><h4 id="介绍-19"><a href="#介绍-19" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</li>
<li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</li>
<li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</li>
</ul>
<h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h4><ul>
<li>有一张表原始数据为：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/d3bcdf86bd31492aae5d3815c5a9b19d" alt="image-20240115082151968"></p>
<ul>
<li><p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。</p>
</li>
<li><p>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p>
</li>
<li><p>然后，有四个并发事务同时在访问这张表。</p>
</li>
<li><p>A. 第一步</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/a90b217dfd3a45d9b1b4ae192a3960dc" alt="image-20240115082225934"></p>
<ul>
<li>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/9bb0cb77aab64ac8bf21944d633c0233" alt="image-20240115082244313"></p>
<ul>
<li>B.第二步</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/224cdf8cb93d46fa85ef056b18a99388" alt="image-20240115082257444"></p>
<ul>
<li>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/8a017e87d17f4d279d4dc966db45bfb6" alt="image-20240115082312127"></p>
<ul>
<li>C. 第三步</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/c585e5cb0dbe4507b64039efc23f561a" alt="image-20240115082325378"></p>
<ul>
<li>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/16924f538bea41d0bc6b2f2655afd4e4" alt="image-20240115082340912"></p>
<ul>
<li>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</li>
</ul>
<h3 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h3><ul>
<li>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</li>
<li>ReadView中包含了四个核心字段：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/48f32a2e406c43e9b32d7832a8c9257f" alt="image-20240115082418149"></p>
<ul>
<li>而在readview中就规定了版本链数据的访问规则：</li>
<li>trx_id 代表当前undolog版本链对应事务ID。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/bd925a4d139345f193ec4bf5fed8db50" alt="image-20240115082438428"></p>
<ul>
<li>不同的隔离级别，生成ReadView的时机不同：<ul>
<li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li>
<li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li>
</ul>
</li>
</ul>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><h4 id="RC隔离级别"><a href="#RC隔离级别" class="headerlink" title="RC隔离级别"></a>RC隔离级别</h4><ul>
<li><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</p>
</li>
<li><p>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?</p>
</li>
<li><p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读</p>
</li>
<li><p>都会生成一个ReadView，那么两次生成的ReadView如下。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/1a0032279d8e4d46baa9fa4d4fe84145" alt="image-20240115082522767"></p>
<ul>
<li><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p>
</li>
<li><p>A. 先来看第一次快照读具体的读取过程：</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/b502a10bbec64c9f81b46430716a86f9" alt="image-20240115082547943"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/0b9410780d2e4f638e8a00d51c452073" alt="image-20240115082553087"></p>
<ul>
<li>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/6e8f37b8024b4036b415a827ca274d85" alt="image-20240115082624668"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/a50419e21a1b4a70a1ce77896c3717ae" alt="image-20240115082645796"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/62494385d614482eb3d3b52e0801bc4a" alt="image-20240115082658101"></p>
<ul>
<li>B. 再来看第二次快照读具体的读取过程:</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/6910c4a8ed0e4262868f063299fc7560" alt="image-20240115082712048"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/61103ffc79b54c4aa623605161f623cc" alt="image-20240115082717825"></p>
<ul>
<li>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/22ebfa6214a14bbd8b3b56adec7ffecf" alt="image-20240115082738555"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/e8578c4168b54b24bd1b6961683f27ef" alt="image-20240115082750179"></p>
<h4 id="RR隔离级别"><a href="#RR隔离级别" class="headerlink" title="RR隔离级别"></a>RR隔离级别</h4><ul>
<li>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 </li>
<li>而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</li>
<li>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/9822fe95c5b14281ac3279af7fc9716b" alt="image-20240115083148026"></p>
<ul>
<li>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</li>
<li>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。</li>
<li>而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/5a44a42f36f14f1a9380a7116706e5af" alt="image-20240115083216835"></p>
<h1 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h1><h2 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h2><ul>
<li>Mysql数据库安装完成后，自带了一下四个数据库，具体作用如下：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/6ee302c86bc94b388acda14d3208f350" alt="image-20240115083254208"></p>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ul>
<li><p>该mysql不是指mysql服务，而是指mysql的客户端工具。</p>
</li>
<li><p>语法 ：</p>
<ul>
<li><code>mysql [options] [database]</code></li>
</ul>
</li>
<li><p>选项 ：</p>
<ul>
<li>-u, –user&#x3D;name #指定用户名</li>
<li>-p, –password[&#x3D;name] #指定密码</li>
<li>-h, –host&#x3D;name #指定服务器IP或域名</li>
<li>-P, –port&#x3D;port #指定连接端口</li>
<li>-e, –execute&#x3D;name #执行SQL语句并退出</li>
</ul>
</li>
<li><p>-e 选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。</p>
</li>
<li><p>示例：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot –p123456 db01 -e &quot;select * from stu&quot;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/1dfda178a7254442b8adf9143886a743" alt="image-20240115083441749"></p>
<h3 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h3><ul>
<li><p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p>
</li>
<li><p>通过帮助文档查看选项：</p>
<ul>
<li>mysqladmin –help</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/427c92aff71a4628a069f882a63a096e" alt="image-20240115083509639"></p>
<ul>
<li><p>语法:</p>
<ul>
<li>mysqladmin [options] command …</li>
</ul>
</li>
<li><p>选项:</p>
<ul>
<li>-u, –user&#x3D;name #指定用户名</li>
<li>-p, –password[&#x3D;name] #指定密码</li>
<li>-h, –host&#x3D;name #指定服务器IP或域名</li>
<li>-P, –port&#x3D;port #指定连接端口</li>
</ul>
</li>
<li><p>示例：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot –p1234 drop &#x27;test01&#x27;;</span><br><span class="line">mysqladmin -uroot –p1234 version;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/520406dd09cd4bda95f350d6002861da" alt="image-20240115083553174"></p>
<h3 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h3><ul>
<li><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p>
</li>
<li><p>语法 ：</p>
<ul>
<li>mysqlbinlog [options] log-files1 log-files2 …</li>
</ul>
</li>
<li><p>选项 ：</p>
<ul>
<li>-d, –database&#x3D;name 指定数据库名称，只列出指定的数据库相关操作。</li>
<li>-o, –offset&#x3D;# 忽略掉日志中的前n行命令。</li>
<li>-r,–result-file&#x3D;name 将输出的文本格式日志输出到指定文件。</li>
<li>-s, –short-form 显示简单格式， 省略掉一些信息。</li>
<li>–start-datatime&#x3D;date1 –stop-datetime&#x3D;date2 指定日期间隔内的所有日志。</li>
<li>–start-position&#x3D;pos1 –stop-position&#x3D;pos2 指定位置间隔内的所有日志。</li>
</ul>
</li>
<li><p>示例:</p>
<ul>
<li>A. 查看 binlog.000008这个二进制文件中的数据信息</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/3da5014d52994196a1ba69a90f38ad28" alt="image-20240115083637734"></p>
<ul>
<li>上述查看到的二进制日志文件数据信息量太多了，不方便查询。 我们可以加上一个参数 -s 来显示简单格式。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/8fae6ccfd4ce425ebef688499cc782b2" alt="image-20240115083658506"></p>
<h3 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a>mysqlshow</h3><ul>
<li><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p>
</li>
<li><p>语法 ：</p>
<ul>
<li><code>mysqlshow [options] [db_name [table_name [col_name]]]</code></li>
</ul>
</li>
<li><p>选项 ：</p>
<ul>
<li>–count 显示数据库及表的统计信息（数据库，表 均可以不指定）</li>
<li>-i 显示指定数据库或者指定表的状态信息</li>
</ul>
</li>
<li><p>示例:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询test库中每个表中的字段书，及行数</span><br><span class="line">mysqlshow -uroot -p2143 test --count</span><br><span class="line"></span><br><span class="line">#查询test库中book表的详细情况</span><br><span class="line">mysqlshow -uroot -p2143 test book --count</span><br></pre></td></tr></table></figure>

<ul>
<li>示例A :</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># A. 查询每个数据库的表的数量及表中记录的数量</span><br><span class="line">mysqlshow -uroot -p1234 --count</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/df65b989e4fb4aa5a150d490b3bdd293" alt="image-20240115083829786"></p>
<ul>
<li>示例B:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># B. 查看数据库db01的统计信息</span><br><span class="line">mysqlshow -uroot -p1234 db01 --count</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/726472e6c5784d25814fc4b6e6c45517" alt="image-20240115083911050"></p>
<ul>
<li>示例C:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># C. 查看数据库db01中的course表的信息</span><br><span class="line">mysqlshow -uroot -p1234 db01 course --count</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/c7ae7a8d7fd844ca8798c6b1adc6dc08" alt="image-20240115083939451"></p>
<ul>
<li>示例D :</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># D. 查看数据库db01中的course表的id字段的信息</span><br><span class="line">mysqlshow -uroot -p1234 db01 course id --count</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/1ee4b51478da4e43bd9b810dfce1f104" alt="image-20240115084010442"></p>
<h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><ul>
<li><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句</p>
</li>
<li><p>语法 ：</p>
<ul>
<li><code>mysqldump [options] db_name [tables]</code></li>
<li><code>mysqldump [options] --database/-B db1 [db2 db3...]</code></li>
<li><code>mysqldump [options] --all-databases/-A</code></li>
</ul>
</li>
<li><p>连接选项 ：</p>
<ul>
<li>-u, –user&#x3D;name 指定用户名</li>
<li>-p, –password[&#x3D;name] 指定密码</li>
<li>-h, –host&#x3D;name 指定服务器ip或域名</li>
<li>-P, –port&#x3D;# 指定连接端口</li>
</ul>
</li>
<li><p>输出选项：</p>
<ul>
<li>–add-drop-database 在每个数据库创建语句前加上 drop database 语句</li>
<li>–add-drop-table 在每个表创建语句前加上 drop table 语句 , 默认开启 ; 不</li>
</ul>
</li>
<li><p>开启 (–skip-add-drop-table)</p>
<ul>
<li>-n, –no-create-db 不包含数据库的创建语句</li>
<li>-t, –no-create-info 不包含数据表的创建语句</li>
<li>-d –no-data 不包含数据</li>
<li>-T, –tab&#x3D;name 自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件</li>
</ul>
</li>
<li><p>示例A :</p>
<ul>
<li>可以直接打开db01.sql，来查看备份出来的数据到底什么样。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># A. 备份db01数据库</span><br><span class="line">mysqldump -uroot -p1234 db01 &gt; db01.sql</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/e7c4dc7998ef4fc39b3b1c994a174f76" alt="image-20240115084159673"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/45fdbe8628da4802a9b8f29d7b7b6aa3" alt="image-20240115084151820"></p>
<ul>
<li><p>备份出来的数据包含：</p>
<ul>
<li>删除表的语句</li>
<li>创建表的语句</li>
<li>数据插入语句</li>
</ul>
</li>
<li><p>如果我们在数据备份时，不需要创建表，或者不需要备份数据，只需要备份表结构，都可以通过对应的参数来实现。</p>
</li>
<li><p>示例B :</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># B. 备份db01数据库中的表数据，不备份表结构(-t)</span><br><span class="line">mysqldump -uroot -p1234 -t db01 &gt; db01.sql</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/34f75fd7c481472096fb81aa837eba4a" alt="image-20240115084539867"></p>
<ul>
<li>打开 db02.sql ，来查看备份的数据，只有insert语句，没有备份表结构。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/a039abf5b8584eb58e982557ace05984" alt="image-20240115084559388"></p>
<ul>
<li>示例C:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># C. 将db01数据库的表的表结构与数据分开备份(-T)</span><br><span class="line">mysqldump -uroot -p1234 -T /root db01 score</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/4b522ced06ad4efb8be7e05f42f194bc" alt="image-20240115084629733"></p>
<ul>
<li>执行上述指令，会出错，数据不能完成备份，原因是因为我们所指定的数据存放目录&#x2F;root，MySQL认为是不安全的，需要存储在MySQL信任的目录下。那么，哪个目录才是MySQL信任的目录呢，可以查看一下系统变量 secure_file_priv 。执行结果如下：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/f0f0f630e3794df99e2f7944b594f15b" alt="image-20240115084807921"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/f0f0f630e3794df99e2f7944b594f15b"></p>
<ul>
<li>上述的两个文件 score.sql 中记录的就是表结构文件，而 score.txt 就是表数据文件，但是需要注意表数据文件，并不是记录一条条的insert语句，而是按照一定的格式记录表结构中的数据。如下：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/7c201ecdaf764fcc86ca86920dbcf482" alt="image-20240115084828564"></p>
<h3 id="mysqlimport-source"><a href="#mysqlimport-source" class="headerlink" title="mysqlimport&#x2F;source"></a>mysqlimport&#x2F;source</h3><h4 id="mysqlimport"><a href="#mysqlimport" class="headerlink" title="mysqlimport"></a>mysqlimport</h4><ul>
<li><p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。</p>
</li>
<li><p>语法 ：</p>
<ul>
<li><code>mysqlimport [options] db_name textfile1 [textfile2...]</code></li>
</ul>
</li>
<li><p>示例 ：</p>
<ul>
<li><code>mysqlimport -uroot -p2143 test /tmp/city.txt</code></li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/15/53b923e50d114e4a80039921b4748377" alt="image-20240115085045016"></p>
<h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><ul>
<li><p>如果需要导入sql文件,可以使用mysql中的source 指令 :</p>
</li>
<li><p>语法 ：</p>
<ul>
<li><code>source /root/xxxxx.sql</code></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg"></a><div class="post-copyright__author_name">蜗牛浪迹天涯</div><div class="post-copyright__author_desc">宁静致远，热爱生活。</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div><div class="post-reward" onclick="AddRewardMask()"><div class="reward-button" title="赞赏作者"><i class="scoicon sco-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><ul class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a target="_blank" rel="noopener" href="https://bu.dusays.com/2023/11/07/6549e79364fa3.png"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/07/6549e79364fa3.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://bu.dusays.com/2023/11/07/6549e79d02bd6.png" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/07/6549e79d02bd6.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></ul></div></div><script>function RemoveRewardMask() {
    let rewardMainElements = document.querySelectorAll(".reward-main");
    let quitBoxElement = document.querySelector("#quit-box");

    console.log("RemoveRewardMask")

    rewardMainElements.forEach(element => {
        element.style.display = "none";
    });

    if (quitBoxElement) {
        quitBoxElement.style.display = "none";
    }
}

function AddRewardMask() {
    let rewardMainElements = document.querySelectorAll(".reward-main");
    let quitBoxElement = document.querySelector("#quit-box");

    console.log("AddRewardMask")

    rewardMainElements.forEach(element => {
        element.style.display = "flex";
    });

    if (quitBoxElement) {
        quitBoxElement.style.display = "flex";
    }
}</script></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">蜗牛浪迹天涯</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/004_MySQL_%E8%BF%90%E7%BB%B4%E7%AF%87/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL运维篇</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/002_MySQL_%E8%BF%9B%E9%98%B6%E7%AF%87-01/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL进阶篇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">一日之计在于晨</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg"><div class="avatar-sticker"><img class="avatar-sticker-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/12/30/659011053e246.png" alt="心情贴纸"></div></div><div class="author-info__description_group"><div class="author-info__description">分享自己对编程的<b>热爱</b>，对美好生活的<b>向往</b>，对知识海洋<b>探索历程</b>。</div><div class="author-info__description2">相信你可以在这里找到对你有用的知识和教程。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><div class="author-info__name">snail289</div><div class="author-info__desc">宁静致远，热爱生活。</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://github.com/DuoSco/Hexo-Theme-slitude" title="Github"><i class="scoicon sco-github-line"></i></a><a class="social-icon" target="_blank" rel="noopener" href="https://space.bilibili.com/1329819902" title="Bilibili"><i class="scoicon sco-bilibili-line"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="scoicon sco-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-text">查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-text">修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-text">删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA%E7%A4%BA%E4%BE%8B"><span class="toc-text">演示示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E9%80%89%E9%A1%B9"><span class="toc-text">检查选项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CASCADED"><span class="toc-text">CASCADED</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LOCAL"><span class="toc-text">LOCAL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="toc-text">视图的更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E4%BD%9C%E7%94%A8"><span class="toc-text">视图作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95"><span class="toc-text">简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-text">安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B"><span class="toc-text">数据独立</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-1"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8"><span class="toc-text">调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B"><span class="toc-text">查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-1"><span class="toc-text">删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">演示示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-text">系统变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-text">用户定义变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">局部变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-text">if</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-text">参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case"><span class="toc-text">case</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while"><span class="toc-text">while</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#repeat"><span class="toc-text">repeat</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-6"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-4"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loop"><span class="toc-text">loop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-7"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-5"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87"><span class="toc-text">游标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-8"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-6"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">条件处理程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-9"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-7"><span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-text">存储函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-10"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-8"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-11"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-2"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-1"><span class="toc-text">查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-2"><span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-9"><span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-text">全局锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-12"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-13"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-text">元数据锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">意向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-14"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-text">行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-15"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-text">行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-16"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-text">案例演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81-%E4%B8%B4%E9%94%AE%E9%94%81"><span class="toc-text">间隙锁&amp;临键锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-17"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-text">示例演示</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB%E5%BC%95%E6%93%8E"><span class="toc-text">InnoDB引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">逻辑存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5"><span class="toc-text">段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA"><span class="toc-text">区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5"><span class="toc-text">页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C"><span class="toc-text">行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-text">架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-Pool"><span class="toc-text">Buffer Pool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Change-Buffer"><span class="toc-text">Change Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Adaptive-Hash-Index"><span class="toc-text">Adaptive Hash Index</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Log-Buffer"><span class="toc-text">Log Buffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-text">磁盘结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#System-Tablespace"><span class="toc-text">System Tablespace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File-Per-Table-Tablespaces"><span class="toc-text">File-Per-Table Tablespaces</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#General-Tablespaces"><span class="toc-text">General Tablespaces</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Undo-Tablespaces"><span class="toc-text">Undo Tablespaces</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Temporary-Tablespaces"><span class="toc-text">Temporary Tablespaces</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Doublewrite-Buffer-Files"><span class="toc-text">Doublewrite Buffer Files</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redo-Log"><span class="toc-text">Redo Log</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-text">后台线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Master-Thread"><span class="toc-text">Master Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-Thread"><span class="toc-text">IO Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Purge-Thread"><span class="toc-text">Purge Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Cleaner-Thread"><span class="toc-text">Page Cleaner Thread</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="toc-text">事务原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80"><span class="toc-text">事务基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-text">特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log"><span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log"><span class="toc-text">undo log</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC"><span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-text">当前读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-text">快照读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVCC-1"><span class="toc-text">MVCC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="toc-text">隐藏字段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-18"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undolog"><span class="toc-text">undolog</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-19"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-text">版本链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readview"><span class="toc-text">readview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-text">原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">RC隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">RR隔离级别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E7%AE%A1%E7%90%86"><span class="toc-text">MySQL管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">系统数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql"><span class="toc-text">mysql</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqladmin"><span class="toc-text">mysqladmin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqlbinlog"><span class="toc-text">mysqlbinlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqlshow"><span class="toc-text">mysqlshow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqldump"><span class="toc-text">mysqldump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqlimport-source"><span class="toc-text">mysqlimport&#x2F;source</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mysqlimport"><span class="toc-text">mysqlimport</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#source"><span class="toc-text">source</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="scoicon sco-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/15/Python/%E9%BB%91%E9%A9%ACPython_01/" title="Python基础-01"><img alt="Python基础-01" src= "/img/loading.gif" data-lazy-src="https://tse2-mm.cn.bing.net/th/id/OIP-C.fs21LLVsDhIQJeG3UilvswHaEK?w=306&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/02/15/Python/%E9%BB%91%E9%A9%ACPython_01/" title="Python基础-01">Python基础-01</a><a class="article-recent_post_categories" href="/2024/02/15/Python/%E9%BB%91%E9%A9%ACPython_01/">Python</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/15/Python/%E9%BB%91%E9%A9%ACPython_02/" title="Python基础-02"><img alt="Python基础-02" src= "/img/loading.gif" data-lazy-src="https://tse2-mm.cn.bing.net/th/id/OIP-C.fs21LLVsDhIQJeG3UilvswHaEK?w=306&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/02/15/Python/%E9%BB%91%E9%A9%ACPython_02/" title="Python基础-02">Python基础-02</a><a class="article-recent_post_categories" href="/2024/02/15/Python/%E9%BB%91%E9%A9%ACPython_02/">Python</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/15/Python/%E9%BB%91%E9%A9%ACPython_03/" title="Python基础-03"><img alt="Python基础-03" src= "/img/loading.gif" data-lazy-src="https://tse2-mm.cn.bing.net/th/id/OIP-C.fs21LLVsDhIQJeG3UilvswHaEK?w=306&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/02/15/Python/%E9%BB%91%E9%A9%ACPython_03/" title="Python基础-03">Python基础-03</a><a class="article-recent_post_categories" href="/2024/02/15/Python/%E9%BB%91%E9%A9%ACPython_03/">Python</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/007_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/001_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" title="UI自动化测试"><img alt="UI自动化测试" src= "/img/loading.gif" data-lazy-src="https://tse3-mm.cn.bing.net/th/id/OIP-C.FjupsUlF0U4eTb-7NSK7VQHaEK?w=324&amp;h=182&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/01/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/007_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/001_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" title="UI自动化测试">UI自动化测试</a><a class="article-recent_post_categories" href="/2024/01/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/007_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/001_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">软件测试</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/006_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/11_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-02/" title="性能测试基础02"><img alt="性能测试基础02" src= "/img/loading.gif" data-lazy-src="https://tse1-mm.cn.bing.net/th/id/OIP-C.n0oCh3l8SwuNaJd7YTGnbAHaEo?w=254&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/01/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/006_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/11_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-02/" title="性能测试基础02">性能测试基础02</a><a class="article-recent_post_categories" href="/2024/01/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/006_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/11_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-02/">软件测试</a></div></div></div></div></div></div></main><footer id="footer"><div id="sco-footer-bar"><div class="footer-logo"><span class="scoicon">首页</span></div><div class="footer-bar-description">来自蜗牛浪迹天涯 - 宁静致远，热爱生活。的文章</div><a class="footer-bar-link" href="/">了解更多</a></div><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com" title="Github"><i class="scoicon sco-bilibili-line"></i></a><a class="deal_link" href="mailto:1448623289@qq.com" title="Mail"><i class="scoicon sco-mail-line"></i></a><div class="footer_mini_logo" id="footer_mini_logo" title="返回顶部" onclick="sco.toTop()"><img src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="返回顶部"></div><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com" title="Bilibili"><i class="scoicon sco-bilibili-line"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://v.douyin.com" title="抖音"><i class="scoicon sco-douyin-fill"></i></a></div><div id="sco-footer"><div class="footer-group"><h3 class="footer-title">导航</h3><div class="footer-links"><a class="footer-item" href="/archives/" title="归档">归档</a><a class="footer-item" href="/categories/" title="分类">分类</a><a class="footer-item" href="/tags/" title="标签">标签</a></div></div><div class="footer-group"><h3 class="footer-title">服务</h3><div class="footer-links"><a class="footer-item" target="_blank" rel="noopener" href="https://aliyun.com/" title="阿里云">阿里云</a><a class="footer-item" target="_blank" rel="noopener" href="https://v6.51.la/" title="51la统计">51la统计</a><a class="footer-item" target="_blank" rel="noopener" href="https://tongji.baidu.com/" title="百度统计">百度统计</a></div></div><div class="footer-group"><h3 class="footer-title">支持</h3><div class="footer-links"><a class="footer-item" href="/about/" title="打赏记录">打赏记录</a><a class="footer-item" target="_blank" rel="noopener" href="https://docs.wzsco.top/" title="文档">文档</a><a class="footer-item" target="_blank" rel="noopener" href="https://blog.wzsco.top/" title="案例">案例</a></div></div><div class="footer-group"><h3 class="footer-title">协议</h3><div class="footer-links"><a class="footer-item" href="/cookies/" title="Cookies">Cookies</a><a class="footer-item" href="/privacy/" title="用户协议">用户协议</a><a class="footer-item" href="/copyright/" title="版权协议">版权协议</a></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 By&nbsp;<a class="footer-bar-link" href="/">snail289</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/DuoSco/hexo-theme-solitude">主题</a><a class="footer-bar-link cc" href="/copyright/"><i class="scoicon sco-copyright-line"></i><i class="scoicon sco-creative-commons-by-line"></i><i class="scoicon sco-creative-commons-nc-line"></i><i class="scoicon sco-creative-commons-nd-line"></i></a></div></div></div><div class="needEndHide" id="cookies-window"><div class="cookies-window-title">协议提醒助手</div><div class="cookies-window-content"><span class="cookies-tip">查看本站为你的个人隐私做出的努力</span><a class="cookies-link" href="/privacy/" title="本站如何保护你的隐私"><i class="scoicon sco-right-btn-fill"></i></a></div></div></footer></div><!-- inject body--><script src="https://cdn.bootcdn.net/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/lib/lazyload.min.js"></script><script src="/lib/snackbar.min.js"></script><script src="/lib/view-image.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/Swiper/9.2.4/swiper-bundle.min.js"></script><div id="js-pjax"><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: 'post',
    toc: true,
    comment: false,
}
</script></div><!-- post-ai)--><script src="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/meting/2.0.1/Meting.min.js"></script><script>const meting_api = 'https://api.injahow.cn/meting/?server=:server&type=:type&id=:id&auth=:auth&r=:r';
</script><script>const coverColorConfig = {
    mode: 'local',
    api: 'https://img2color.meuicat.com/api?img=',
    time: 43200000,
}</script><script src="/lib/cover-color.min.js"></script><!-- waterfall--><script src="/lib/waterfall.min.js"></script><!-- pjax--><script>let pjaxSelectors = [
    'title',
    '#body-wrap',
    '#site-config',
    'meta[name="description"]',
    '#js-pjax',
    'meta[property^="og:"]',
]

const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()
})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- music--><script src="/js/music.js"></script><!-- inject custom body--><script>console.log("body")</script><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="scoicon sco-close-fill"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/extend/search/local-search.js"></script><!-- music--><div class="needEndHide" id="nav-music" onclick="sco.musicToggle()"><div id="nav-music-hoverTips">音乐已暂停</div><meting-js id="8927329843" server="netease" type="playlist" mutex="true" preload="none" data-lrctype="0" order="random" theme="var(--sco-main)"></meting-js></div></body></html><script>const posts=["2024/02/15/Python/黑马Python_01/","2024/02/15/Python/黑马Python_02/","2024/02/15/Python/黑马Python_03/","2024/01/26/软件测试/007_UI自动化测试/001_UI自动化测试/","2024/01/26/软件测试/006_性能测试/11_性能测试-02/","2024/01/26/软件测试/006_性能测试/11_性能测试-01/","2024/01/26/软件测试/005_接口测试/10_接口测试_接口对象封装_接口自动化测试框架_全量字段校验_持续集成/","2024/01/26/软件测试/005_接口测试/09_接口测试_Requests库_UnitTest框架_数据库操作_日志收集/","2024/01/26/软件测试/005_接口测试/08_接口测试_Postman的使用/","2024/01/26/软件测试/005_接口测试/接口测试_慕课网/","2024/01/26/软件测试/005_接口测试/接口自动化测试_慕课网/","2024/01/26/软件测试/005_接口测试/07_接口测试_接口测试基础/","2024/01/25/软件测试/003_MySQL/004_MySQL_运维篇/","2024/01/25/软件测试/003_MySQL/003_MySQL_进阶篇-02/","2024/01/25/软件测试/003_MySQL/002_MySQL_进阶篇-01/","2024/01/25/软件测试/003_MySQL/001_MySQL_基础篇/","2024/01/25/软件测试/002_Linux/001_Linux/","2024/01/25/软件测试/001_软件测试基础/功能测试项目实战_慕课网/","2024/01/25/软件测试/001_软件测试基础/01_软件测试基础_分类_模型_流程_用例_bug管理/","2024/01/24/Web前端开发/402_Webpack/40201_Webpack/","2024/01/24/Web前端开发/401_TypeScript/40101_TypeScript/","2024/01/23/Web前端开发/303_React/30305_React_Hooks解析/","2024/01/23/Web前端开发/303_React/30304_React_Router/","2024/01/23/Web前端开发/303_React/30303_Redux/","2024/01/23/Web前端开发/303_React/30302_React_过渡动画与CSS样式/","2024/01/23/Web前端开发/303_React/30301_React核心基础/","2024/01/23/Web前端开发/302_Vue3/30207_Vue3_Vue3原理/","2024/01/23/Web前端开发/302_Vue3/30206_Vue3_过渡与动画/","2024/01/23/Web前端开发/302_Vue3/30205_Vue3_自定义指令与插件/","2024/01/23/Web前端开发/302_Vue3/30204_Vue3_Pinia/","2024/01/23/Web前端开发/302_Vue3/30203_Vue3_VueX/","2024/01/23/Web前端开发/302_Vue3/30202_Vue3_Router/","2024/01/23/Web前端开发/302_Vue3/30201_Vue3_基础核心/","2024/01/23/Web前端开发/301_Vue2/30103_Vue2_VueX/","2024/01/23/Web前端开发/301_Vue2/30102_Vue2_VueRouter/","2024/01/23/Web前端开发/301_Vue2/30101_Vue2_Vue2Base/","2024/01/23/Web前端开发/206_模块化/20601_ModuleJS/","2024/01/22/Web前端开发/205_Git/20501_Git/","2024/01/21/Web前端开发/204_Fetch/20401_Fetch/","2024/01/20/Web前端开发/203_Axios/20301_Axios/","2024/01/19/Web前端开发/106_JavaScript高级/10509_JS代码的执行原理/","2024/01/19/Web前端开发/202_Promise/20201_Promise/","2024/01/18/Web前端开发/201_Ajax/20101_Ajax/","2024/01/18/Web前端开发/106_JavaScript高级/10508_浏览器执行过程原理/","2024/01/17/Web前端开发/106_JavaScript高级/10507_JS_ES6-ES13/","2024/01/16/Web前端开发/105_JavaScript/10506_JS_BOM/","2024/01/15/Web前端开发/105_JavaScript/10505_JS_DOM/","2024/01/14/Web前端开发/105_JavaScript/10504_JS_Function/","2024/01/13/Web前端开发/105_JavaScript/10503_JS_Object/","2024/01/12/Web前端开发/105_JavaScript/10502_JS_Array/","2024/01/11/Web前端开发/105_JavaScript/10501_JavaScript_Base/","2024/01/10/Web前端开发/104_Less/10401_Less/","2024/01/09/Web前端开发/103_移动端开发/10304_Flex/","2024/01/08/Web前端开发/103_移动端开发/10303_Rem/","2024/01/07/Web前端开发/103_移动端开发/10302_Percent/","2024/01/06/Web前端开发/103_移动端开发/10301_WebMobileBase/","2024/01/05/Web前端开发/102_HTML5_CSS3/10202_CSS3/","2024/01/04/Web前端开发/102_HTML5_CSS3/10201_HTML5/","2024/01/03/Web前端开发/101_HTML_CSS/10103_CSS/","2024/01/02/Web前端开发/101_HTML_CSS/10102_HTML/","2024/01/01/Web前端开发/101_HTML_CSS/10101_WebBase/"];function toRandomPost(){ pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]); };</script>