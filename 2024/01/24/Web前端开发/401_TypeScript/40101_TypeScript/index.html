<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>TypeScript | 蜗牛浪迹天涯</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg"><!-- index.css--><link rel="stylesheet" href="/css/index.css"><!-- inject head--><link rel="stylesheet" href="https://cdn3.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><link rel="stylesheet" href="/lib/snackbar.min.css"><!-- comment--><!-- pace 胶囊加载条(Capsule loading bar)--><script src="https://cdn.bootcdn.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!-- search--><script src="https://cdn.bootcdn.net/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script><!-- aplayer--><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/Swiper/9.2.4/swiper-bundle.min.css"><!-- echarts--><script src="https://cdn.bootcdn.net/ajax/libs/echarts/5.4.2/echarts.min.js"></script><!-- 灰色纪念日(Gray Anniversary)--><!-- Open Graph--><meta name="description" content="# TypeScript JS存在的问题关于JS 我始终相信：任何新技术的出现都是为了解决原有技术的某个痛点。 JavaScript是一门优秀的编程语言吗？ 每个人可能观点并不完全一致，但是从很多角度来看，JavaScript是一门非常优秀的编程语言； 而且，可以说在很长一段时间内这个语言不会被"><!-- pwa--><script>(win => {
        win.saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay,
                }
                localStorage.setItem(key, JSON.stringify(item))
            },

            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)

                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()

                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        }

        const DarkModeStatus = localStorage.getItem('theme')
        if (DarkModeStatus !== null) {
            if (DarkModeStatus === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark')
            } else {
                document.documentElement.setAttribute('data-theme', 'light')
            }
        }

        const asideStatus = saveToLocal.get('aside-status')
        if (asideStatus !== undefined) {
            if (asideStatus === 'hide') {
                document.documentElement.classList.add('hide-aside')
            } else {
                document.documentElement.classList.remove('hide-aside')
            }
        }
    }
)(window)

console.log(
    "%c🔥 程序：Hexo | 主题：Hexo-Theme-Solitude | 作者：王卓Sco、亦封 | Github: https://github.com/DuoSco/Hexo-theme-solitude | 版本：v1.3.0 😄",
    "color: #fff; background: linear-gradient(-25deg, #a8edea, #fed6e3); padding: 8px 15px; border-radius: 8px; text-shadow: 2px 2px 4px white; color: black;"
);
</script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script></div><!-- custom inject--><script>console.log("head")</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":true,"path":"/search.xml"},
    runtime: '2024-01-01 00:00:00',
    lazyload: {
        enable: true,
        error: '/img/error_load.png'
    },
    hightlight: {
        enable: true,
        limit: 200,
        expand: false,
        copy: true,
    },
    lightbox: true,
    randomlinks: false,
    lang: {
        theme: {
            dark: '已切换至深色模式',
            light: '已切换至浅色模式',
        },
        copy: {
            success: '复制成功',
            error: '复制失败',
        },
        backtop: '返回顶部',
        time: {
            recent: '最近',
            yesterday: '昨天',
            berforeyesterday: '前天',
            daybefore: '天前',
            runtime: '天',
        },
        sayhello: {
            morning: `一日之计在于晨`,
            noon: `吃饱了才有力气干活`,
            afternoon: `集中精力，攻克难关`,
            night: `不要太劳累了，早睡更健康`,
            goodnight: `睡个好觉，保证精力充沛`,
        },
        search: {
            empty: '找不到你查询的内容：${query}',
            hit: '找到 ${hits} 条结果，用时 ${time} 毫秒',
            placeholder: '输入关键词快速查找',
        }
    },
    covercolor: {
        enable: true
    },
    comment: {
        enable: false,
        type: 'twikoo',
        commentBarrage: false,
        randomInfoStart: ["聪敏的","可爱的","美丽的"],
        randomInfoEnd: ["白菜","小可爱","小仙女"],
        twikoo: {
            url: '',
            accessToken: ''
        },
        waline: {
            url: '',
        }
    },
    rightside: {
        enable: false
    },
    ai:{
        enable: false,
        key: '',
        talk: '我是王卓Sco开发的摘要生成助理ScoGPT，ScoGPT在静态部署时进行摘要的撰写，并且在访客访问时通过ScoCorrection转译后的文本摘要实现工具。我在这里只负责已经生成的摘要显示，你无法与我直接沟通，但我可以回答一些预设的问题。',
        randomPost: false,
    },
    music:{
        enable: true,
    }
}</script><meta name="generator" content="Hexo 6.3.0"></head><body id="body"><!-- loading--><div id="loading-box" onclick="preloader.endLoading();" style="zoom:1"><div class="loading-bg"><img class="loading-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="loading image"></div></div><script>const preloader = {
    endLoading: () => {
        document.getElementById('loading-box').classList.add('loaded');
    },
    initLoading: () => {
        document.getElementById('loading-box').classList.remove('loaded');
    },
    removePaceDone: () => {
        document.getElementById('body').classList = 'pace-done';
    }
}
window.addEventListener('load', () => {
    preloader.endLoading();
});
window.addEventListener('pjax:send', () => {
    preloader.initLoading();
});
document.addEventListener('pjax:complete', () => {
    preloader.endLoading();
});</script><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="scoicon sco-close-fill"></i></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><div class="author-content-item-title">最新评论</div></div><div class="aside-list"></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><div class="author-content-item-title">寻找感兴趣的领域</div></div><div class="card-tag-cloud"></div></div><div class="console-card history" onclick="sco.hideConsole()"><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" onclick="pjax.loadUrl('/archives/2024/')" href="javascript:void(0);"><span class="card-archive-list-date">2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">43</span><span class="card-archive-list-count-unit">篇</span></div></a></li></ul></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换" href="javascript:void(0);"><i class="scoicon sco-moon-clear-fill"></i></a></div><div class="console-btn-item" id="consoleHideAside"><a class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制" href="javascript:void(0);"><i class="scoicon sco-side-bar-fill"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="sco.musicToggle()"><a class="music-switch" title="音乐开关" href="javascript:void(0);"><i class="scoicon sco-disc-fill"></i></a></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()" href="javascript:void(0);"><i class="scoicon sco-moon-clear-fill"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/DuoSco/Hexo-Theme-solitude" title="Solitude"><img class="back-menu-item-icon" src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="项目"><span class="back-menu-item-text">Solitude</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="scoicon sco-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="scoicon sco-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="scoicon sco-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/moments/"><i class="scoicon sco-wifi-fill"></i><span>鱼塘</span></a></li><li><a class="site-page child" href="/links/"><i class="scoicon sco-group-fill"></i><span>友情链接</span></a></li><li><a class="site-page child" href="javascript:travelling()"><i class="scoicon sco-gift-fill"></i><span>宝藏博主</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/equipment/"><i class="scoicon sco-laptop-line"></i><span>装备</span></a></li><li><a class="site-page child" href="/tlink/"><i class="scoicon sco-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="scoicon sco-laptop-line"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="scoicon sco-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon scoicon sco-more-fill"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/DuoSco/Hexo-Theme-solitude" title="Solitude"><img class="back-menu-item-icon" src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="项目"><span class="back-menu-item-text">Solitude</span></a></div></div></div></div><a id="site-name" href="/" title="返回博客主页" target="_self"><span class="scoicon">首页</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">TypeScript</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="scoicon sco-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="scoicon sco-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="scoicon sco-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/moments/"><i class="scoicon sco-wifi-fill"></i><span>鱼塘</span></a></li><li><a class="site-page child" href="/links/"><i class="scoicon sco-group-fill"></i><span>友情链接</span></a></li><li><a class="site-page child" href="javascript:travelling()"><i class="scoicon sco-gift-fill"></i><span>宝藏博主</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/equipment/"><i class="scoicon sco-laptop-line"></i><span>装备</span></a></li><li><a class="site-page child" href="/tlink/"><i class="scoicon sco-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="scoicon sco-laptop-line"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="scoicon sco-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button"><a class="site-page" href="https://www.travellings.cn/go.html" title="开往-友链接力" target="_blank"><i class="scoicon sco-train-line"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机一篇文章" href="javascript:void(0);"><i class="scoicon sco-signal-tower-fill"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="scoicon sco-search-line"></i></a></div><div class="nav-button" id="nav-console"><a class="console_switchbutton" onclick="sco.showConsole()" title="中控台" href="javascript:void(0);"><i class="scoicon sco-dashboard-fill"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="scoicon sco-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="scoicon sco-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://tse4-mm.cn.bing.net/th/id/OIP-C.EI3avnVaz4qhmuwwpADISQHaEK?w=322&amp;h=181&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7" alt="TypeScript"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/Web前端开发/">Web前端开发</a></span><div class="tag_share"><div class="post-meta__tag-list"></div></div></div></div><h1 class="post-title">TypeScript</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="meta_posted 2024-01-24 11:00:00"><i class="post-meta-icon scoicon sco-calendar-todo-fill"></i><time datetime="2024-01-24T03:00:00.000Z">2024-01-24T03:00:00.000Z</time></span><span class="post-meta-date" title="meta_updated 2024-01-28 14:20:13"><i class="post-meta-icon scoicon sco-refresh-line"></i><time datetime="2024-01-28T06:20:13.743Z">2024-01-28T06:20:13.743Z</time></span><span class="post-meta-wordcount"><i class="post-meta-icon scoicon sco-word-fill" title="文章字数"></i><span class="word-count">18.1k</span><span class="post-meta-separator"></span><i class="post-meta-icon scoicon sco-clock-fill" title="阅读耗时"></i><span>74 min</span></span><span class="post-meta-position" title="作者IP归属地为衡阳"><i class="post-meta-icon scoicon sco-map-pin-fill"></i><span>衡阳</span></span><a class="post-meta-pv" href="/2024/01/24/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/401_TypeScript/40101_TypeScript/" title="文章热度"><i class="post-meta-icon scoicon sco-fire-fill"></i><span id="busuanzi_value_page_pv"><i class="scoicon sco-loading-line"></i></span></a></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />
# TypeScript

<h2 id="JS存在的问题"><a href="#JS存在的问题" class="headerlink" title="JS存在的问题"></a>JS存在的问题</h2><h3 id="关于JS"><a href="#关于JS" class="headerlink" title="关于JS"></a>关于JS</h3><ul>
<li>我始终相信：任何新技术的出现都是为了解决原有技术的某个痛点。</li>
<li>JavaScript是一门优秀的编程语言吗？<ul>
<li>每个人可能观点并不完全一致，但是从很多角度来看，JavaScript是一门非常优秀的编程语言；</li>
<li>而且，可以说在很长一段时间内<strong>这个语言不会被代替，并且会在更多的领域被大家广泛使用</strong>；</li>
</ul>
</li>
<li>著名的Atwood定律：<ul>
<li>Stack Overflow的创立者之一的 Jeff Atwood 在2007年提出了著名的 Atwood定律。</li>
<li>any application that can be written in JavaScript, will eventually be written in JavaScript.</li>
<li>任何可以使用JavaScript来实现的应用都最终都会使用JavaScript实现。</li>
</ul>
</li>
<li>其实我们已经看到了，这句话正在一步步被应验：<ul>
<li><strong>Web端</strong>的开发我们一直都是使用JavaScript；</li>
<li><strong>移动端</strong>开发可以借助于ReactNative、Weex、Uniapp等框架实现跨平台开发；</li>
<li><strong>小程序端</strong>的开发也是离不开JavaScript；</li>
<li><strong>桌面端</strong>应用程序我们可以借助于Electron来开发；</li>
<li><strong>服务器端</strong>开发可以借助于Node环境使用JavaScript来开发。</li>
</ul>
</li>
</ul>
<h3 id="JS的缺点"><a href="#JS的缺点" class="headerlink" title="JS的缺点"></a>JS的缺点</h3><ul>
<li>并且随着近几年前端领域的快速发展，让JavaScript迅速被普及和受广大开发者的喜爱，借助于JavaScript本身的强大，也让使用JavaScript开发的人员越来越多。</li>
<li>优秀的JavaScript没有缺点吗？<ul>
<li>其实上由于各种历史因素，JavaScript语言本身存在很多的缺点；</li>
<li>比如ES5以及之前的使用的var关键字关于作用域的问题；</li>
<li>比如最初JavaScript设计的数组类型并不是连续的内存空间；</li>
<li>比如<strong>直到今天 JavaScript 也没有加入类型检测这一机制</strong>；</li>
</ul>
</li>
<li>JavaScript正在慢慢变好<ul>
<li>不可否认的是，JavaScript正在慢慢变得越来越好，无论是从底层设计还是应用层面。</li>
<li>ES6、7、8 等的推出，每次都会让这门语言更加现代、更加安全、更加方便。</li>
<li>但是知道今天，JavaScript在类型检测上依然是毫无进展（为什么类型检测如此重要，我后面会聊到）。</li>
</ul>
</li>
</ul>
<h3 id="关于类型"><a href="#关于类型" class="headerlink" title="关于类型"></a>关于类型</h3><h4 id="类型带来的问题"><a href="#类型带来的问题" class="headerlink" title="类型带来的问题"></a>类型带来的问题</h4><ul>
<li>首先你需要知道，编程开发中我们有一个共识：<strong>错误出现的越早越好</strong><ul>
<li>能在写代码的时候发现错误，就不要在代码编译时再发现（IDE的优势就是在代码编写过程中帮助我们发现错误）。</li>
<li>能在代码编译期间发现错误，就不要在代码运行期间再发现（类型检测就可以很好的帮助我们做到这一点）。</li>
<li>能在开发阶段发现错误，就不要在测试期间发现错误，能在测试期间发现错误，就不要在上线后发现错误。</li>
</ul>
</li>
<li>现在我们想探究的就是如何在 代码编译期间 发现代码的错误：<ul>
<li>JavaScript 可以做到吗？不可以，我们来看下面这段经常可能出现的 JavaScript  代码问题。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">length</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;你好,李银河&#x27;</span>) <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 报错, Cannot read properties of undefined (reading &#x27;length&#x27;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;上面报错,执行不到我...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前 foo 函数,在被其他地方调用时,没有做任何的参数校验</span></span><br><span class="line"><span class="comment"> *  1. 没有对类型进行校验</span></span><br><span class="line"><span class="comment"> *  2. 没有对是否传入参数进行校验</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="类型错误"><a href="#类型错误" class="headerlink" title="类型错误"></a>类型错误</h4><ul>
<li>这是我们一个非常常见的错误：<ul>
<li>这个错误很大的原因就是因为JavaScript没有对我们传入的参数进行任何的限制，只能等到运行期间才发现这个错误；</li>
<li>并且当这个错误产生时，会影响后续代码的继续执行，也就是整个项目都因为一个小小的错误而深入崩溃；</li>
</ul>
</li>
<li>当然，你可能会想：我怎么可能犯这样低级的错误呢？<ul>
<li>当我们写像我们上面这样的简单的demo时，这样的错误很容易避免，并且当出现错误时，也很容易检查出来；</li>
<li>但是当我们开发一个大型项目时呢？你能保证自己一定不会出现这样的问题吗？而且如果我们是调用别人的类库，又如何知道让我们传入的到底是什么样的参数呢？</li>
</ul>
</li>
<li>但是，如果我们可以给JavaScript加上很多限制，在开发中就可以很好的避免这样的问题了：<ul>
<li>比如我们的getLength函数中str是一个必传的类型，没有调用者没有传编译期间就会报错；</li>
<li>比如我们要求它的必须是一个String类型，传入其他类型就直接报错；</li>
<li>那么就可以知道很多的错误问题在编译期间就被发现，而不是等到运行时再去发现和修改；</li>
</ul>
</li>
</ul>
<h4 id="类型思维"><a href="#类型思维" class="headerlink" title="类型思维"></a>类型思维</h4><ul>
<li>我们已经简单体会到没有类型检查带来的一些问题，JavaScript因为从设计之初就没有考虑类型的约束问题，所以造成了前端开发人员关于类型思维的缺失：<ul>
<li>前端开发人员通常不关心变量或者参数是什么类型的，如果在必须确定类型时，我们往往需要使用各种判断验证；</li>
<li>从其他方向转到前端的人员，也会因为没有类型约束，而总是担心自己的代码不安全，不够健壮；</li>
</ul>
</li>
<li>所以我们经常会说JavaScript不适合开发大型项目，因为当项目一旦庞大起来，这种宽松的类型约束会带来非常多的安全隐患，多人员开发它们之间也没有良好的类型契约。<ul>
<li>比如当我们去实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证我们代码的健壮性；</li>
<li>比如我们去调用别人的函数，对方没有对函数进行任何的注释，我们只能去看里面的逻辑来理解这个函数需要传入什么参数，返回值是什么类型；</li>
</ul>
</li>
</ul>
<h4 id="JS添加类型约束"><a href="#JS添加类型约束" class="headerlink" title="JS添加类型约束"></a>JS添加类型约束</h4><ul>
<li>为了弥补JavaScript类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案：p2014年，Facebook推出了flow来对JavaScript进行类型检查；<ul>
<li>同年，Microsoft微软也推出了TypeScript1.0版本；</li>
<li>他们都致力于为JavaScript提供类型检查；</li>
</ul>
</li>
<li>而现在，无疑TypeScript已经完全胜出：<ul>
<li>Vue2.x的时候采用的就是flow来做类型检查；</li>
<li>Vue3.x已经全线转向TypeScript，98.3%使用TypeScript进行了重构；</li>
<li>而Angular在很早期就使用TypeScript进行了项目重构并且需要使用TypeScript来进行开发；</li>
<li>而甚至Facebook公司一些自己的产品也在使用TypeScript；</li>
</ul>
</li>
<li>学习TypeScript不仅仅可以为我们的代码增加类型约束，而且可以培养我们前端程序员具备类型思维。</li>
</ul>
<h2 id="邂逅TypeScript"><a href="#邂逅TypeScript" class="headerlink" title="邂逅TypeScript"></a>邂逅TypeScript</h2><h3 id="认识TypeScript"><a href="#认识TypeScript" class="headerlink" title="认识TypeScript"></a>认识TypeScript</h3><ul>
<li>我们经常说TypeScript是JavaScript的一个超级：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/28/492d3340abab43debaade3bed11ae24e" alt="1667917585720"></p>
<ul>
<li>虽然我们已经知道TypeScript是干什么的了，也知道它解决了什么样的问题，但是我们还是需要全面的来认识一下TypeScript到底是什么？</li>
<li>我们来看一下TypeScript在GitHub和官方上对自己的定义：<ul>
<li>GitHub说法：TypeScript is a superset of JavaScript that compiles to clean JavaScript output.</li>
<li>TypeScript官网：TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</li>
<li>翻译一下：<strong>TypeScript是拥有类型的JavaScript超集，它可以编译成普通、干净、完整的JavaScript代码</strong>。</li>
</ul>
</li>
<li>怎么理解上面的话呢？<ul>
<li>我们可以将TypeScript理解成加强版的JavaScript。</li>
<li>JavaScript所拥有的特性，TypeScript全部都是支持的，并且它紧随ECMAScript的标准，所以ES6、ES7、ES8等新语法标准，它都是支持的；</li>
<li>并且在语言层面上，不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型（Enum）、元组类型（Tuple）等；</li>
<li>TypeScript在实现新特性的同时，总是保持和ES标准的同步甚至是领先；</li>
<li>并且<strong>TypeScript最终会被编译成JavaScript代码，所以你并不需要担心它的兼容性问题，在编译时也不需要借助于Babel这样的工具</strong>；</li>
<li>所以，我们可以把TypeScript理解成更加强大的JavaScript，不仅让JavaScript更加安全，而且给它带来了诸多好用的好用特性；</li>
</ul>
</li>
</ul>
<h3 id="TypeScript的特点"><a href="#TypeScript的特点" class="headerlink" title="TypeScript的特点"></a>TypeScript的特点</h3><ul>
<li>官方对TypeScript有几段特点的描述，我觉得非常到位（虽然有些官方，了解一下），我们一起来分享一下：</li>
<li>始于JavaScript，归于JavaScript<ul>
<li>TypeScript从今天数以百万计的JavaScript开发者所熟悉的语法和语义开始。使用现有的JavaScript代码，包括流行的JavaScript库，并从JavaScript代码中调用TypeScript代码；</li>
<li>TypeScript可以编译出纯净、 简洁的JavaScript代码，并且可以运行在任何浏览器上、Node.js环境中和任何支持ECMAScript 3（或更高版本）的JavaScript引擎中；</li>
</ul>
</li>
<li>TypeScript是一个强大的工具，用于构建大型项目<ul>
<li><strong>类型允许JavaScript开发者在开发JavaScript应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构</strong>；</li>
<li>类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有JavaScript库的行为；</li>
</ul>
</li>
<li>拥有先进的 JavaScript<ul>
<li>TypeScript提供最新的和不断发展的JavaScript特性，包括那些来自2015年的ECMAScript和未来的提案中的特性，比如异步功能和Decorators，以帮助建立健壮的组件；</li>
<li>这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的ECMAScript3（或更新版本）的JavaScript；</li>
</ul>
</li>
</ul>
<h3 id="项目采用TypeScript"><a href="#项目采用TypeScript" class="headerlink" title="项目采用TypeScript"></a>项目采用TypeScript</h3><ul>
<li>正是因为有这些特性，TypeScript目前已经在很多地方被应用：<ul>
<li>Angular源码在很早就使用TypeScript来进行了重写，并且开发Angular也需要掌握TypeScript；</li>
<li>Vue3源码也采用了TypeScript进行重写，在前面阅读源码时我们看到大量TypeScript的语法；</li>
<li>包括目前已经变成最流行的编辑器VSCode也是使用TypeScript来完成的；</li>
<li>包括在React中已经使用的ant-design的UI库，也大量使用TypeScript来编写；</li>
<li>目前公司非常流行Vue3+TypeScript、React+TypeScript的开发模式；</li>
<li>包括小程序开发，也是支持TypeScript的；</li>
</ul>
</li>
</ul>
<h3 id="前端的发展趋势"><a href="#前端的发展趋势" class="headerlink" title="前端的发展趋势"></a>前端的发展趋势</h3><ul>
<li>大前端是一群最能或者说最需要折腾的开发者：<ul>
<li>客户端开发者：从Android到iOS，或者从iOS到Android，到RN，甚至现在越来越多的客户端开发者接触前端相关知识（Vue、React、Angular、小程序）；</li>
<li>前端开发者：从jQuery到AngularJS，到三大框架并行：Vue、React、Angular，还有小程序，甚至现在也要接触客户端开发（比如RN、Flutter）；</li>
<li>目前又面临着不仅仅学习ES的特性，还要学习TypeScript；</li>
<li>新框架的出现，我们又需要学习新框架的特性，比如vue3.x、react18等等；</li>
</ul>
</li>
<li>但是每一样技术的出现都会让惊喜，因为他必然是解决了之前技术的某一个痛点的，而TypeScript真是解决了JavaScript存在的很多设计缺陷，尤其是关于类型检测的。</li>
<li>并且从开发者长远的角度来看，学习TypeScript有助于我们前端程序员培养 类型思维，这种思维方式对于完成大型项目尤为重要。</li>
</ul>
<h2 id="TypeScript基本使用"><a href="#TypeScript基本使用" class="headerlink" title="TypeScript基本使用"></a>TypeScript基本使用</h2><h3 id="TS的编译环境"><a href="#TS的编译环境" class="headerlink" title="TS的编译环境"></a>TS的编译环境</h3><ul>
<li>在前面我们提到过，TypeScript最终会被编译成JavaScript来运行，所以我们需要搭建对应的环境：<ul>
<li>我们需要在电脑上安装TypeScript，这样就可以通过TypeScript的Compiler将其编译成JavaScript；</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/28/5672ebc25172466b8ae3ef4a5e28f5a3" alt="1667916437366"></p>
<ul>
<li>所以，我们需要先可以先进行全局的安装：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line">npm install typescript -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">tsc --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行指定文件</span></span><br><span class="line">tsc math.ts <span class="comment"># 会在同级目录生成一个同名的 js 文件,再通过 node 或者 浏览器执行该 js 文件即可查看编译结果</span></span><br></pre></td></tr></table></figure>

<h3 id="TS的运行环境"><a href="#TS的运行环境" class="headerlink" title="TS的运行环境"></a>TS的运行环境</h3><ul>
<li>n 如果我们每次为了查看TypeScript代码的运行效果，都通过经过两个步骤的话就太繁琐了：<ul>
<li>第一步：通过tsc编译TypeScript到JavaScript代码；</li>
<li>第二步：在浏览器或者Node环境下运行JavaScript代码；</li>
</ul>
</li>
<li>n 是否可以简化这样的步骤呢？<ul>
<li>比如编写了TypeScript之后可以直接运行在浏览器上？</li>
<li>比如编写了TypeScript之后，直接通过node的命令来执行？</li>
</ul>
</li>
<li>n 上面我提到的两种方式，可以通过两个解决方案来完成：<ul>
<li>方式一：通过webpack，配置本地的TypeScript编译环境和开启一个本地服务，可以直接运行在浏览器上；</li>
<li>方式二：通过ts-node库，为TypeScript的运行提供执行环境；</li>
</ul>
</li>
<li>n 方式一：webpack配置<ul>
<li>方式一在之前的TypeScript文章中我已经有写过，如果需要可以自行查看对应的文章；</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wnL1l-ERjTDykWM76l4Ajw%EF%BC%9B">https://mp.weixin.qq.com/s/wnL1l-ERjTDykWM76l4Ajw；</a></li>
</ul>
</li>
<li>方式二: <ul>
<li>安装 ts-node<ul>
<li><strong>npm install ts-node -g</strong></li>
</ul>
</li>
<li>n 另外ts-node需要依赖tslib 和@types&#x2F;node 两个包：<ul>
<li><strong>npm install tslib @types&#x2F;node -g</strong></li>
</ul>
</li>
<li>n 现在，我们可以直接通过ts-node 来运行TypeScript的代码：<ul>
<li><strong>ts-node math.ts</strong>  即可直接运行 ts 文件,,不会再生成同名的 js 文件</li>
</ul>
</li>
</ul>
</li>
<li><strong>方式三 : 借助 vue3 项目</strong><ul>
<li>创建 vue3 项目 : <strong>vue create demoapp</strong><ul>
<li>选择自定义安装,勾选 TypeScript 即可</li>
<li>TypeScript 代码即可在入口文件 main.ts 中编写</li>
<li>开启项目本地服务,即可在浏览器控制台查看编译结果</li>
</ul>
</li>
</ul>
</li>
<li>关闭 ESlint 校验 :</li>
</ul>
<p><strong>vue.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">lintOnSave</span>: <span class="literal">false</span>,<span class="comment">// 关闭 ESlint 校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript变量类型"><a href="#TypeScript变量类型" class="headerlink" title="TypeScript变量类型"></a>TypeScript变量类型</h2><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><ul>
<li>我们已经强调过很多次，在TypeScript中定义变量需要指定 标识符 的类型。</li>
<li>所以完整的声明格式如下：<ul>
<li>声明了类型后TypeScript就会进行类型检测，声明的类型可以称之为类型注解；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;你好,师姐&#x27;</span> <span class="comment">// 定义一个变量,并限定为 string 类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">// 你好,师姐</span></span><br></pre></td></tr></table></figure>

<ul>
<li>比如我们声明一个message，完整的写法如下：<ul>
<li>注意：这里的string是小写的，和String是有区别的</li>
<li>string是TypeScript中定义的字符串类型，String是ECMAScript中定义的一个类</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string:·TypeScript中的字符串类型</span></span><br><span class="line"><span class="comment">// String:JavaScript的字符串包装类的类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;你好,师姐&#x27;</span> <span class="comment">// 定义一个变量,并限定为 string 类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">// 你好,师姐</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果我们给message赋值其他类型的值，那么就会报错：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;你好,师姐&#x27;</span> <span class="comment">// 定义一个变量,并限定为 string 类型</span></span><br><span class="line">message = <span class="number">18</span> <span class="comment">// 报错 ,不能将类型&quot;number”分配给类型“string&quot;。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">// 你好,师姐</span></span><br></pre></td></tr></table></figure>

<h3 id="声明变量的关键字"><a href="#声明变量的关键字" class="headerlink" title="声明变量的关键字"></a>声明变量的关键字</h3><ul>
<li>在TypeScript定义变量（标识符）和ES6之后一致，可以使用var、let、const来定义。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;李银河&#x27;</span> </span><br><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;你好,师姐&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message, name, age) <span class="comment">// 你好,师姐 李银河 18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125; <span class="comment">// 在全局作用域中, 如果报错 &quot;无法重新声明块范围变量“xxxxxx” &quot; , 在最后导出一个空对象即可成为一个独立模块</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当然，在tslint中并不推荐使用var来声明变量：<ul>
<li>可见，在TypeScript中并不建议再使用var关键字了</li>
<li>主要原因和ES6升级后let和var的区别是一样的，var是没有块级作用域的，会引起很多的问题，这里不再展开探讨。</li>
</ul>
</li>
</ul>
<h3 id="变量的类型推导"><a href="#变量的类型推导" class="headerlink" title="变量的类型推导"></a>变量的类型推导</h3><ul>
<li>在开发中，有时候为了方便起见我们并不会在声明每一个变量时都写上对应的数据类型，我们更希望可以通过TypeScript本身的特性帮助我们推断出对应的变量类型：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 ts 中直接给一个变量赋值,不写类型注解,TS会根据变量值自动进行类型推断 , 即 TS 会自动判断类型</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span> </span><br><span class="line"><span class="comment">// age = &quot;你好, 师姐&quot; // 报错,不能将类型“string”分配给类型&quot;number”。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这是因为在一个变量第一次赋值时，会根据后面的赋值内容的类型，来推断出变量的类型：<ul>
<li>上面的message就是因为后面赋值的是一个string类型，所以message虽然没有明确的说明，但是依然是一个string类型；</li>
</ul>
</li>
</ul>
<h3 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h3><ul>
<li>数字类型是我们开发中经常使用的类型，TypeScript和JavaScript一样，不区分整数类型（int）和浮点型（double），统一为number类型。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">123</span> <span class="comment">// 定义一个 number 类型的变量</span></span><br><span class="line"><span class="comment">// num = &quot;lisi&quot; // 报错,不能将类型“string”分配给类型“number”。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果你学习过ES6应该知道，ES6新增了二进制和八进制的表示方法，而TypeScript也是支持二进制、八进制、十六进制的表示：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num1</span>: <span class="built_in">number</span> = <span class="number">100</span> <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num2</span>: <span class="built_in">number</span> = <span class="number">0b100</span> <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num3</span>: <span class="built_in">number</span> = <span class="number">0o100</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num4</span>: <span class="built_in">number</span> = <span class="number">0x100</span> <span class="comment">// 十六进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1, num2, num3, num4) <span class="comment">// 100 4 64 256</span></span><br></pre></td></tr></table></figure>

<h3 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h3><ul>
<li>boolean类型只有两个取值：true和false，非常简单</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: <span class="built_in">boolean</span> = <span class="literal">true</span> <span class="comment">// 定义一个布尔类型的变量</span></span><br><span class="line">flag = <span class="number">20</span> &gt; <span class="number">30</span> <span class="comment">// 同类型的变量可以重新赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flag) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><ul>
<li>string类型是字符串类型，可以使用单引号或者双引号表示：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;你好,师姐&#x27;</span> <span class="comment">// 默认情况下,如何可以自动推导出标识符的类型,一般不加类型注解</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">//你好,师姐</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同时也支持ES6的模板字符串来拼接变量和字符串：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;why&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">`name:<span class="subst">$&#123;name&#125;</span>,age:<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg) <span class="comment">//name:why,age:18</span></span><br></pre></td></tr></table></figure>

<h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h3><ul>
<li>数组类型的定义也非常简单，有两种方式：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个数组中在TypeScript开发中, 最好存放的数据类型是固定一样的,在数组中存放不同的类型是不好的习惯</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">names1</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [] <span class="comment">// 不推荐的写法,在 react 的 jsx 中有冲突</span></span><br><span class="line">names1.<span class="title function_">push</span>(<span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names1)  <span class="comment">// [&#x27;lisi&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">names2</span>: <span class="built_in">string</span>[] = [] <span class="comment">// 推荐的写法</span></span><br><span class="line">names2.<span class="title function_">push</span>(<span class="string">&#x27;laowang&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names2) <span class="comment">// [&#x27;laowang&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><ul>
<li>object对象类型可以用于描述一个对象：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会自动进行类型推导</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info) <span class="comment">// &#123;name: &#x27;why&#x27;, age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h3><ul>
<li>在ES5中，如果我们是不可以在对象中添加相同的属性名称的，比如下面的做法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span> <span class="comment">// 报错 , 对象文本不能具有多个名称相同的属性。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通常我们的做法是定义两个不同的属性名字：比如identity1和identity2。</li>
<li>但是我们也可以通过symbol来定义相同的名称，因为Symbol函数返回的是不同的值：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> title2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  [title1]: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  [title2]: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info) <span class="comment">// &#123;Symbol(title): &#x27;why&#x27;, Symbol(title): &#x27;kobe&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><ul>
<li>在 JavaScript 中，undefined 和 null 是两个基本数据类型。</li>
<li>在TypeScript中，它们各自的类型也是undefined和null，也就意味着它们既是实际的值，也是自己的类型：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">n1</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">n2</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n1, n2) <span class="comment">// null undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">n3</span>: <span class="built_in">string</span> = <span class="literal">null</span> <span class="comment">// 在未开启严格模式下,可以将 null 赋值给 string 类型</span></span><br><span class="line">n3 = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n3) <span class="comment">// abc</span></span><br></pre></td></tr></table></figure>

<h3 id="any类型"><a href="#any类型" class="headerlink" title="any类型"></a>any类型</h3><ul>
<li>在某些情况下，我们确实无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以使用any类型（类似于Dart语言中的dynamic类型）。</li>
<li>any类型有点像一种讨巧的TypeScript手段：<ul>
<li>我们可以对any类型的变量进行任何的操作，包括获取不存在的属性、方法；</li>
<li>我们给一个any类型的变量赋值任何的值，比如数字、字符串的值；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经常在进行一些类型断言 as any 时使用</span></span><br><span class="line"><span class="comment">// 经常在不想给某些JavaScript添加具体的数据类型时(原生的JavaScript代码是一样)使用</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="built_in">any</span> = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">message = <span class="number">123</span> <span class="comment">// any 类型的变量,可以赋值其他类型的数据</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果对于某些情况的处理过于繁琐不希望添加规定的类型注解，或者在引入一些第三方库时，缺失了类型注解，这个时候我们可以使用any：<ul>
<li>包括在Vue源码中，也会使用到any来进行某些类型的适配；</li>
</ul>
</li>
</ul>
<h3 id="unknown类型"><a href="#unknown类型" class="headerlink" title="unknown类型"></a>unknown类型</h3><ul>
<li>unknown是TypeScript中比较特殊的一种类型，它用于描述类型不确定的变量。</li>
<li>什么意思呢？我们来看下面的场景：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">result</span>: <span class="built_in">unknown</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  result = <span class="title function_">foo</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result == <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unknown 类型只能赋值给 any 和 unknown 类型</span></span><br><span class="line"><span class="comment">// any 类型可以赋值给任意类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let message: string = result // 报错,不能将类型“unknown”分配给类型“string”。</span></span><br><span class="line"><span class="comment">// let num:number = result // 报错,不能将类型“unknown”分配给类型&quot;number”。</span></span><br></pre></td></tr></table></figure>

<h3 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h3><ul>
<li>void通常用来指定一个函数是没有返回值的，那么它的返回值就是void类型：<ul>
<li>我们可以将null和undefined赋值给void类型，也就是函数可以返回null或者undefined</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示返回值是 void 类型,也可以不写</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2) <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个函数我们没有写任何类型，那么它默认返回值的类型就是void的，我们也可以显示的来指定返回值是void：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示返回值是 void 类型,也可以不写</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2) <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h3><ul>
<li>never 表示永远不会发生值的类型，比如一个函数：<ul>
<li>如果一个函数中是一个死循环或者抛出一个异常，那么这个函数会返回东西吗？</li>
<li>不会，那么写void类型或者其他类型作为返回值类型都不合适，我们就可以使用never类型；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示永远没有返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>):<span class="built_in">never</span> &#123; </span><br><span class="line">  <span class="comment">// 死循环</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示永远没有返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) :<span class="built_in">never</span>&#123; </span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>never有什么样的应用场景呢？这里我们举一个例子，但是它用到了联合类型，后面我们会讲到</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never 的应用场景</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleMessage</span>(<span class="params">message: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> message) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按string的方式处理message&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按number的方式处理message&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按boolean的方式处理message&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="comment">// 如果代码执行来到这里,说明缺少对传入的变量的类型的业务处理</span></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">check</span>: <span class="built_in">never</span> = message <span class="comment">// 报错,不能将类型“boolean”分配给类型“never&quot;。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="number">456</span>)</span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h3 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h3><ul>
<li><p>tuple是元组类型，很多语言中也有这种数据类型，比如Python、Swift等。</p>
</li>
<li><p>那么tuple和数组有什么区别呢？</p>
<ul>
<li>首先，数组中通常建议存放相同类型的元素，不同类型的元素是不推荐放在数组中。（可以放在对象或者元组中）</li>
<li>其次，元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;why&#x27;</span>, <span class="number">18</span>, <span class="number">1.88</span>]</span><br><span class="line"><span class="keyword">const</span> name = info[<span class="number">0</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">length</span>)</span><br><span class="line"><span class="keyword">const</span> age = info[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// console.log(age.length) // 报错,此时可以第一时间直接知道 age 变量没有 length 属性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>那么tuple在什么地方使用的是最多的呢？<ul>
<li>tuple通常可以作为返回的值，在使用的时候会非常的方便；</li>
</ul>
</li>
</ul>
<h2 id="TypeScript中的函数"><a href="#TypeScript中的函数" class="headerlink" title="TypeScript中的函数"></a>TypeScript中的函数</h2><h3 id="函数的形参类型"><a href="#函数的形参类型" class="headerlink" title="函数的形参类型"></a>函数的形参类型</h3><ul>
<li>函数是JavaScript非常重要的组成部分，TypeScript允许我们指定函数的参数和返回值的类型。</li>
<li>参数的类型注解<ul>
<li>声明函数时，可以在每个参数后添加类型注解，以声明函数接受的参数类型：</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给函数形参加上类型注解</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2) <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">return</span> num1 + num2 <span class="comment">// 会自动推导返回值类型,通常情况下不写返回值的类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 实参的个数与类型,必须与形参相同,否则报错</span></span><br><span class="line"><span class="comment">// sum(1,&quot;jki&quot;) //报错, 类型“string”的参数不能赋给类型“number”的参数。</span></span><br></pre></td></tr></table></figure>

<h3 id="函数返回值类型"><a href="#函数返回值类型" class="headerlink" title="函数返回值类型"></a>函数返回值类型</h3><ul>
<li>我们也可以添加返回值的类型注解，这个注解出现在函数列表的后面：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给函数形参加上类型注解</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2) <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">return</span> num1 + num2 <span class="comment">// 会自动推导返回值类型,通常情况下不写返回值的类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 实参的个数与类型,必须与形参相同,否则报错</span></span><br><span class="line"><span class="comment">// sum(1,&quot;jki&quot;) //报错, 类型“string”的参数不能赋给类型“number”的参数。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>和变量的类型注解一样，我们通常情况下不需要返回类型注解，因为TypeScript会根据 return 返回值推断函数的返回类型：<ul>
<li>某些第三方库处于方便理解，会明确指定返回类型，但是这个看个人喜好；</li>
</ul>
</li>
</ul>
<h3 id="匿名函数的参数"><a href="#匿名函数的参数" class="headerlink" title="匿名函数的参数"></a>匿名函数的参数</h3><ul>
<li>匿名函数与函数声明会有一些不同：<ul>
<li>当一个函数出现在TypeScript可以确定该函数会被如何调用的地方时；</li>
<li>该函数的参数会自动指定类型；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;acn&#x27;</span>, <span class="string">&#x27;jck&#x27;</span>, <span class="string">&#x27;kok&#x27;</span>]</span><br><span class="line"><span class="comment">// 回调中的形参 item, 可以写也可以不写类型注解,会自动根据上下文环境推导出来</span></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>我们并没有指定item的类型，但是item是一个string类型：<ul>
<li>这是因为TypeScript会根据forEach函数的类型以及数组的类型推断出item的类型；</li>
<li>这个过程称之为上下文类型（contextual typing），因为函数执行的上下文可以帮助确定参数和返回值的类型；</li>
</ul>
</li>
</ul>
<h3 id="对象类型的形参"><a href="#对象类型的形参" class="headerlink" title="对象类型的形参"></a>对象类型的形参</h3><ul>
<li>如果我们希望限定一个函数接受的参数是一个对象，这个时候要如何限定呢？<ul>
<li>我们可以使用对象类型；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给对象类型的形参添加类型注解</span></span><br><span class="line"><span class="comment">// 限定形参 point 为对象类型, 必须包含两个属性, 且属性的类型必须是 number 类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">x</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">y</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printPoint</span>(&#123; <span class="attr">x</span>: <span class="number">123</span>, <span class="attr">y</span>: <span class="number">456</span> &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在这里我们使用了一个对象来作为类型：<ul>
<li>在对象我们可以添加属性，并且告知TypeScript该属性需要是什么类型；</li>
<li>属性之间可以使用 , 或者 ; 来分割，最后一个分隔符是可选的；</li>
<li>每个属性的类型部分也是可选的，如果不指定，那么就是any类型；</li>
</ul>
</li>
</ul>
<h3 id="形参的可选类型"><a href="#形参的可选类型" class="headerlink" title="形参的可选类型"></a>形参的可选类型</h3><ul>
<li>对象类型也可以指定哪些属性是可选的，可以在属性的后面添加一个问号 : <code>?</code></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给对象类型的形参添加类型注解</span></span><br><span class="line"><span class="comment">// 限定形参 point 为对象类型, 必须包含两个属性, 且属性的类型必须是 number 类型</span></span><br><span class="line"><span class="comment">// 在形参后面加一个问号(?),表示该形参可以传递,也可以不传递,未传递实参,则值默认是 undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span>; z?: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">x</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">y</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">z</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printPoint</span>(&#123; <span class="attr">x</span>: <span class="number">123</span>, <span class="attr">y</span>: <span class="number">456</span> &#125;)</span><br><span class="line"><span class="title function_">printPoint</span>(&#123; <span class="attr">x</span>: <span class="number">123</span>, <span class="attr">y</span>: <span class="number">456</span>, <span class="attr">z</span>: <span class="number">798</span> &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>其实上，可选类型可以看做是 类型 和 undefined 的联合类型：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">message: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">undefined</span>) <span class="comment">// 必须明确传入 undefined,否则报错</span></span><br></pre></td></tr></table></figure>

<h3 id="形参的联合类型"><a href="#形参的联合类型" class="headerlink" title="形参的联合类型"></a>形参的联合类型</h3><ul>
<li>TypeScript的类型系统允许我们使用多种运算符，从现有类型中构建新类型。</li>
<li>我们来使用第一种组合类型的方法：联合类型（Union Type）<ul>
<li>联合类型是由两个或者多个其他类型组成的类型；</li>
<li>表示可以是这些类型中的任何一个值；</li>
<li>联合类型中的每一个类型被称之为联合成员（union’s members）；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用联合类型,给形参添加类型注解</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printID</span>(<span class="number">123</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="title function_">printID</span>(<span class="string">&#x27;lisi&#x27;</span>) <span class="comment">// lisi</span></span><br><span class="line"><span class="title function_">printID</span>(<span class="literal">true</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>传入给一个联合类型的值是非常简单的：只要保证是联合类型中的某一个类型的值即可<ul>
<li>但是我们拿到这个值之后，我们应该如何使用它呢？因为它可能是任何一种类型。</li>
<li>比如我们拿到的值可能是string或者number，我们就不能对其调用string上的一些方法；</li>
</ul>
</li>
<li>那么我们怎么处理这样的问题呢？<ul>
<li>我们需要使用缩小（narrow）联合（后续我们还会专门讲解缩小相关的功能）；</li>
<li>TypeScript可以根据我们缩小的代码结构，推断出更加具体的类型；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用联合类型,给形参添加类型注解</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 使用联合类型时,需要特别小心</span></span><br><span class="line">  <span class="comment">// norrow : 缩小</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printID</span>(<span class="number">123</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="title function_">printID</span>(<span class="string">&#x27;lisi&#x27;</span>) <span class="comment">// lisi</span></span><br><span class="line"><span class="title function_">printID</span>(<span class="literal">true</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="形参的类型别名"><a href="#形参的类型别名" class="headerlink" title="形参的类型别名"></a>形参的类型别名</h3><ul>
<li>在前面，我们通过在类型注解中编写 对象类型 和 联合类型，但是当我们想要多次在其他地方使用时，就要编写多次。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 用于定义类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IDType</span> = <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: IDType</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printID</span>(<span class="number">123</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="title function_">printID</span>(<span class="string">&#x27;lisi&#x27;</span>) <span class="comment">// lisi</span></span><br><span class="line"><span class="title function_">printID</span>(<span class="literal">true</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="其他的类型补充"><a href="#其他的类型补充" class="headerlink" title="其他的类型补充"></a>其他的类型补充</h2><h3 id="类型断言as"><a href="#类型断言as" class="headerlink" title="类型断言as"></a>类型断言as</h3><ul>
<li>有时候TypeScript无法获取具体的类型信息，这个我们需要使用类型断言（Type Assertions）。<ul>
<li>比如我们通过 document.getElementById，TypeScript只知道该函数会返回 HTMLElement ，但并不知道它具体的类型：</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;why&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLImageElement</span></span><br><span class="line">el.<span class="property">src</span> = <span class="string">&quot;xxxx.com&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">studying</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">p: Person</span>) &#123;</span><br><span class="line">  ;(p <span class="keyword">as</span> <span class="title class_">Student</span>).<span class="title function_">studying</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="title function_">sayHello</span>(stu)</span><br></pre></td></tr></table></figure>

<ul>
<li>TypeScript只允许类型断言转换为 更具体 或者 不太具体 的类型版本，此规则可防止不可能的强制转换：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;why&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">age</span>: <span class="built_in">number</span> = message <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="built_in">number</span></span><br></pre></td></tr></table></figure>

<h3 id="非空类型断言"><a href="#非空类型断言" class="headerlink" title="非空类型断言"></a>非空类型断言</h3><ul>
<li>当我们编写下面的代码时，在执行ts的编译阶段会报错：<ul>
<li>这是因为传入的message有可能是为undefined的，这个时候是不能执行方法的；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选类型,相当于是undefined和当前类型的联合类型(undefined | string) </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printMessageLength</span>(<span class="params">message?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">length</span>) <span class="comment">// 传入的message有可能是为undefined,没有 length 属性,会报错,当然也可以通过类型缩小解决报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printMessageLength</span>(<span class="string">&#x27;why&#x27;</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// printMessageLength() // 报错,没传递参数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>但是，我们确定传入的参数是有值的，这个时候我们可以使用非空类型断言：<ul>
<li>非空断言使用的是 ! ，表示可以确定某个标识符是有值的，跳过ts在编译阶段对它的检测；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选类型,相当于是undefined和当前类型的联合类型(undefined | string) </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printMessageLength</span>(<span class="params">message?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message!.<span class="property">length</span>) <span class="comment">// 非空类型断言,就是保证 message 一定是有值的,即函数调用时传递了实参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printMessageLength</span>(<span class="string">&#x27;why&#x27;</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// printMessageLength() // 报错,没传递参数</span></span><br></pre></td></tr></table></figure>

<h3 id="可选链的使用"><a href="#可选链的使用" class="headerlink" title="可选链的使用"></a>可选链的使用</h3><ul>
<li>可选链事实上并不是TypeScript独有的特性，它是ES11（ES2020）中增加的特性：<ul>
<li>可选链使用可选链操作符 <code>?.</code>；</li>
<li>它的作用是当对象的属性不存在时，会短路，直接返回undefined，如果存在，那么才会继续执行；</li>
<li>虽然可选链操作是ECMAScript提出的特性，但是和TypeScript一起使用更版本；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  friend?: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">    girlFriend?: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">friend</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>?.<span class="property">name</span>) <span class="comment">// kobe , 判断 info 是否有 friend 属性,有就继续往下去 name 属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>?.<span class="property">age</span>) <span class="comment">// undefined , info 对象里有 friend 属性,往下取不存在的 age 属性,则返回 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>?.<span class="property">girlFriend</span>?.<span class="property">name</span>) <span class="comment">// undefined,friend 属性里没有 girlFriend 属性,直接返回 undefined,不再往下取</span></span><br></pre></td></tr></table></figure>

<h3 id="和-的作用"><a href="#和-的作用" class="headerlink" title="??和!!的作用"></a>??和!!的作用</h3><ul>
<li>有时候我们还会看到 !! 和 ?? 操作符，这些都是做什么的呢？</li>
<li>!!操作符：<ul>
<li>将一个其他类型转换成boolean类型；</li>
<li>类似于Boolean(变量)的方式；</li>
<li>这是 JS 里的语法,并不属于 TS 的语法</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&#x27;why&#x27;</span></span><br><span class="line"><span class="keyword">const</span> flag1 = <span class="title class_">Boolean</span>(message)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flag1) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flag2 = !!message</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flag2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>??操作符：<ul>
<li>它是ES11增加的新特性；</li>
<li>空值合并操作符（??）是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string | <span class="literal">null</span> = <span class="string">&#x27;hello 师姐&#x27;</span></span><br><span class="line"><span class="keyword">const</span> content = message ?? <span class="string">&#x27;你好啊,师姐&#x27;</span> <span class="comment">// ??, 判断 message 是否为 null 或 undefined,是就返回后边的值</span></span><br><span class="line"><span class="comment">// const content = message ? message : &#x27;你好啊,师姐&#x27; // ?? 类似于三目运算符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(content) <span class="comment">// hello 师姐</span></span><br></pre></td></tr></table></figure>

<h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><ul>
<li>除了前面我们所讲过的类型之外，也可以使用字面量类型（literal types）：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;why&#x27;</span> <span class="comment">// 用 let 定义的变量,会自动推导为 string 类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">message</span>: <span class="string">&#x27;hello world&#x27;</span> = <span class="string">&#x27;hello world&#x27;</span> <span class="comment">// const 定义的字面量类型,值也可以作为类型,值和类型要保持一致</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">num</span>: <span class="number">456</span> = <span class="number">456</span> <span class="comment">// const 定义的字面量类型,值也可以作为类型,值和类型要保持一致</span></span><br></pre></td></tr></table></figure>

<ul>
<li>那么这样做有什么意义呢？<ul>
<li>默认情况下这么做是没有太大的意义的，但是我们可以将多个类型联合在一起</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量类型的意义,就是必须结合联合类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Alignment</span> = <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span> | <span class="string">&#x27;center&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">align</span>: <span class="title class_">Alignment</span> = <span class="string">&#x27;left&#x27;</span> <span class="comment">// 即 align 变量只能赋值指定的值</span></span><br><span class="line">align = <span class="string">&#x27;right&#x27;</span> <span class="comment">// 即 align 变量只能赋值指定的值</span></span><br><span class="line">align = <span class="string">&#x27;center&#x27;</span> <span class="comment">// 即 align 变量只能赋值指定的值</span></span><br></pre></td></tr></table></figure>

<h3 id="字面量推理"><a href="#字面量推理" class="headerlink" title="字面量推理"></a>字面量推理</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Method</span> = <span class="string">&#x27;GET&#x27;</span> | <span class="string">&#x27;POSt&#x27;</span></span><br><span class="line"><span class="comment">// 定义一个方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url: <span class="built_in">string</span>, method: Method</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Request</span> = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">method</span>: <span class="title class_">Method</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://www.baidu.com&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法并传递参数</span></span><br><span class="line"><span class="title function_">request</span>(options.<span class="property">url</span>, options.<span class="property">method</span>) <span class="comment">// options.method 报错,类型“string”的参数不能赋给类型“Method”的参数。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这是因为我们的对象再进行字面量推理的时候，info 其实是一个 {url: string, method: string}，所以我们没办法将一个 string 赋值给一个 字面量 类型。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Method</span> = <span class="string">&#x27;GET&#x27;</span> | <span class="string">&#x27;POST&#x27;</span></span><br><span class="line"><span class="comment">// 定义一个方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url: <span class="built_in">string</span>, method: Method</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Request</span> = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">method</span>: <span class="title class_">Method</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">const</span> options = &#123; <span class="comment">// 不使用 as const , 也可以给 options 变量加上 Request 类型别名</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://www.baidu.com&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span> <span class="comment">// 字面量推理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法并传递参数</span></span><br><span class="line"><span class="title function_">request</span>(options.<span class="property">url</span>, options.<span class="property">method</span>) <span class="comment">// options.method 报错,类型“string”的参数不能赋给类型“Method”的参数。</span></span><br></pre></td></tr></table></figure>

<h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><h3 id="类型缩小"><a href="#类型缩小" class="headerlink" title="类型缩小"></a>类型缩小</h3><ul>
<li>什么是类型缩小呢？<ul>
<li>类型缩小的英文是 Type Narrowing；</li>
<li>我们可以通过类似于 typeof padding &#x3D;&#x3D;&#x3D; “number” 的判断语句，来改变TypeScript的执行路径；</li>
<li>在给定的执行路径中，我们可以缩小比声明时更小的类型，这个过程称之为 缩小;</li>
<li>而我们编写的 typeof padding &#x3D;&#x3D;&#x3D; “number 可以称之为 类型保护（type guards）；</li>
</ul>
</li>
<li>常见的类型保护有如下几种：<ul>
<li>typeof</li>
<li>平等缩小（比如&#x3D;&#x3D;&#x3D;、!&#x3D;&#x3D;）</li>
<li>pinstanceof </li>
<li>in</li>
<li>等等…</li>
</ul>
</li>
</ul>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul>
<li>在 TypeScript 中，检查返回的值typeof是一种类型保护：因为 TypeScript 对如何typeof操作不同的值进行编码。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IDType</span> = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: IDType</span>) &#123;</span><br><span class="line">  <span class="comment">// 类型缩小</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printID</span>(<span class="string">&#x27;why&#x27;</span>) <span class="comment">// WHY</span></span><br><span class="line"><span class="title function_">printID</span>(<span class="number">123</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h3 id="平等缩小"><a href="#平等缩小" class="headerlink" title="平等缩小"></a>平等缩小</h3><ul>
<li>我们可以使用Switch或者相等的一些运算符来表达相等性（比如&#x3D;&#x3D;&#x3D;, !&#x3D;&#x3D;, &#x3D;&#x3D;, and !&#x3D; ）：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span> | <span class="string">&#x27;top&#x27;</span> | <span class="string">&#x27;bottom&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="comment">// if 判断</span></span><br><span class="line">  <span class="keyword">if</span> (direction === <span class="string">&#x27;left&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch 判断</span></span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;left&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;right&#x27;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(direction)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul>
<li>JavaScript 有一个运算符来检查一个值是否是另一个值的”实例”</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printTime</span>(<span class="params">time: <span class="built_in">string</span> | <span class="built_in">Date</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (time <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="comment">// toUTCString() 方法可根据世界时 (UTC) 把 Date 对象转换为字符串，并返回结果。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(time.<span class="title function_">toUTCString</span>())</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printTime</span>(<span class="string">&#x27;why&#x27;</span>) <span class="comment">// why</span></span><br><span class="line"><span class="title function_">printTime</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">// Fri, 11 Nov 2022 03:34:18 GMT</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="title function_">studying</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;学习&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="title function_">teacher</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;教学&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">work</span>(<span class="params">p: Student | Teacher</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p <span class="keyword">instanceof</span> <span class="title class_">Student</span>) &#123;</span><br><span class="line">    p.<span class="title function_">studying</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p.<span class="title function_">teacher</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Student</span>()) <span class="comment">// 学习</span></span><br><span class="line"><span class="title function_">work</span>(<span class="keyword">new</span> <span class="title class_">Teacher</span>()) <span class="comment">// 教学</span></span><br></pre></td></tr></table></figure>

<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><ul>
<li>Javascript 有一个运算符，用于确定对象是否具有带名称的属性：in运算符<ul>
<li>如果指定的属性在指定的对象或其原型链中，则 in 运算符返回 true；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">walk</span>(<span class="params">animal: Fish | Dog</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断 animal 中是否有 swimming</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;swimming&#x27;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    animal.<span class="title function_">swimming</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    animal.<span class="title function_">running</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fish</span>: <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;swimming&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象传入方法调用</span></span><br><span class="line"><span class="title function_">walk</span>(fish) <span class="comment">//swimming</span></span><br></pre></td></tr></table></figure>

<h2 id="TypeScript函数类型"><a href="#TypeScript函数类型" class="headerlink" title="TypeScript函数类型"></a>TypeScript函数类型</h2><h3 id="TS函数类型"><a href="#TS函数类型" class="headerlink" title="TS函数类型"></a>TS函数类型</h3><ul>
<li>在JavaScript开发中，函数是重要的组成部分，并且函数可以作为一等公民（可以作为参数，也可以作为返回值进行传递）。</li>
<li>那么在使用函数的过程中，函数是否也可以有自己的类型呢？<ul>
<li>我们可以编写函数类型的表达式（Function Type Expressions），来表示函数类型；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooFnType</span> = <span class="function">() =&gt;</span> <span class="built_in">void</span> <span class="comment">// 表示类型是一个函数</span></span><br><span class="line"><span class="comment">// 定义一个方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn: FooFnType</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;why&quot;</span>)&#125;</span><br><span class="line"><span class="comment">// 将函数作为参数传递给方法调用</span></span><br><span class="line"><span class="title function_">bar</span>(foo) <span class="comment">// why</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>  <span class="comment">// void 可以返回任意类型</span></span><br><span class="line"><span class="comment">// 定义一个方法,并添加类型注解为函数类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">a1: <span class="built_in">number</span>, a2: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a1 + a2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="TS函数类型解析"><a href="#TS函数类型解析" class="headerlink" title="TS函数类型解析"></a>TS函数类型解析</h3><ul>
<li>在上面的语法中 (num1: number, num2: number) &#x3D;&gt; void，代表的就是一个函数类型：<ul>
<li>接收两个参数的函数：num1和num2，并且都是number类型；</li>
<li>并且这个函数是没有返回值的，所以是void；</li>
</ul>
</li>
<li>在某些语言中，可能参数名称num1和num2是可以省略，但是TypeScript是不可以的：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>  <span class="comment">// void 可以返回任意类型</span></span><br><span class="line"><span class="comment">// 定义一个方法,并添加类型注解为函数类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">a1: <span class="built_in">number</span>, a2: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a1 + a2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calc</span>(<span class="params">n1: <span class="built_in">number</span>, n2: <span class="built_in">number</span>, fn: (num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fn</span>(n1, n2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = <span class="title function_">calc</span>(<span class="number">20</span>, <span class="number">30</span>, <span class="keyword">function</span>(<span class="params">a1, a2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a1 + a2</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1) <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result2 = <span class="title function_">calc</span>(<span class="number">20</span>, <span class="number">30</span>, <span class="keyword">function</span>(<span class="params">a1, a2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a1 * a2</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2) <span class="comment">// 600</span></span><br></pre></td></tr></table></figure>

<h3 id="参数的可选类型"><a href="#参数的可选类型" class="headerlink" title="参数的可选类型"></a>参数的可选类型</h3><ul>
<li>我们可以指定某个参数是可选的:</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选参数 y </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>, <span class="number">30</span>) <span class="comment">// 20 30</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>) <span class="comment">// 20 undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个时候这个参数x依然是有类型的，它是什么类型呢？ number | undefined</li>
<li>另外可选类型需要在必传参数的后面：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选类型是必须写在必选类型的后面的</span></span><br><span class="line"><span class="comment">// 可选参数 y 相当于联合类型: undefined | number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>, <span class="number">30</span>) <span class="comment">// 20 30</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>) <span class="comment">// 20 undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul>
<li>从ES6开始，JavaScript是支持默认参数的，TypeScript也是支持默认参数的：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先写 必传参数 ,再写 有默认值的参数 ,最后写 可选参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">y: <span class="built_in">number</span>, x: <span class="built_in">number</span> = <span class="number">20</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">30</span>) <span class="comment">// 20 30</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个时候y的类型其实是 undefined 和 number 类型的联合。</li>
</ul>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><ul>
<li>从ES6开始，JavaScript也支持剩余参数，剩余参数语法允许我们将一个不定数量的参数放到一个数组中。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示剩余参数 nums 是一个元素为 number 类型的数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">initalNum: <span class="built_in">number</span>, ...nums: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = initalNum</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    total += num</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">20</span>, <span class="number">30</span>)) <span class="comment">// 50</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)) <span class="comment">// 90</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)) <span class="comment">// 140</span></span><br></pre></td></tr></table></figure>

<h3 id="可推导的this类型"><a href="#可推导的this类型" class="headerlink" title="可推导的this类型"></a>可推导的this类型</h3><ul>
<li>this是JavaScript中一个比较难以理解和把握的知识点：<ul>
<li>我在公众号也有一篇文章专门讲解this：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA%EF%BC%9B">https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA；</a></li>
<li>因为this在不同的情况下会绑定不同的值，所以对于它的类型就更难把握了；</li>
</ul>
</li>
<li>那么，TypeScript是如何处理this呢？我们先来看一个例子：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this是可以被推导出来 info对象(TypeScript推导出来)</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; eating&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info.<span class="title function_">eating</span>() <span class="comment">// why eating</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码是可以正常运行的，也就是TypeScript在编译时，认为我们的this是可以正确去使用的：<ul>
<li>TypeScript认为函数 sayHello 有一个对应的this的外部对象 info，所以在使用时，就会把this当做该对象。</li>
</ul>
</li>
</ul>
<h3 id="不确定的this类型"><a href="#不确定的this类型" class="headerlink" title="不确定的this类型"></a>不确定的this类型</h3><ul>
<li>但是对于某些情况来说，我们并不知道this到底是什么？</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eating</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(this.name + &#x27; eating&#x27;, message) // 报错,&quot;this”隐式具有类型&quot;any&quot;，因为它没有类型注释。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">eating</span>: eating,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">info.<span class="title function_">eating</span>(<span class="string">&#x27;哈哈哈&#x27;</span>) <span class="comment">// why eating 哈哈哈</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码运行会报错的：<ul>
<li>这里我们再次强调一下，TypeScript进行类型检测的目的是让我们的代码更加的安全；</li>
<li>所以这里对于 sayHello 的调用来说，我们虽然将其放到了info中，通过info去调用，this依然是指向info对象的；</li>
<li>但是对于TypeScript编译器来说，这个代码是非常不安全的，因为我们也有可能直接调用函数，或者通过别的对象来调用函数；</li>
</ul>
</li>
</ul>
<h3 id="指定this的类型"><a href="#指定this的类型" class="headerlink" title="指定this的类型"></a>指定this的类型</h3><ul>
<li>这个时候，通常TypeScript会要求我们明确的指定this的类型：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ThisType</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eating</span>(<span class="params"><span class="variable language_">this</span>: ThisType, message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; eating&#x27;</span>, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">eating</span>: eating,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">info.<span class="title function_">eating</span>(<span class="string">&#x27;哈哈哈&#x27;</span>) <span class="comment">// why eating 哈哈哈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示绑定</span></span><br><span class="line">eating.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span> &#125;, <span class="string">&#x27;呵呵呵&#x27;</span>) <span class="comment">// kobe eating 呵呵呵</span></span><br><span class="line">eating.<span class="title function_">apply</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;james&#x27;</span> &#125;, [<span class="string">&#x27;嘿嘿嘿&#x27;</span>]) <span class="comment">// james eating 嘿嘿嘿</span></span><br></pre></td></tr></table></figure>

<h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><ul>
<li>在TypeScript中，如果我们编写了一个add函数，希望可以对字符串和数字类型进行相加，应该如何编写呢？</li>
<li>我们可能会这样来编写，但是其实是错误的：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过联合类型有两个缺点:</span></span><br><span class="line"><span class="comment"> *  1.进行很多的逻辑判断(类型缩小)</span></span><br><span class="line"><span class="comment"> *  2.返回值的类型依然是不能确定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a1: <span class="built_in">number</span> | <span class="built_in">string</span>, a2: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 可以使用类型缩小解决下面的报错</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a1 === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> a2 === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> a1 === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> a2 === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return a1 + a2 // 拨错,运算符“+”不能应用于类型“string | number”和“string | number”。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>那么这个代码应该如何去编写呢？</p>
<ul>
<li>在TypeScript中，我们可以去编写不同的重载签名（overload signatures）来表示函数可以以不同的方式进行调用；</li>
<li>一般是编写两个或者以上的重载签名，再去编写一个通用的函数以及实现；</li>
</ul>
</li>
<li><p>比如我们对sum函数进行重构：</p>
<ul>
<li>在我们调用sum的时候，它会根据我们传入的参数类型来决定执行函数体时，到底执行哪一个函数的重载签名；</li>
</ul>
</li>
<li><p>但是注意，有实现重载的函数，是不能直接被调用的：</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的重载: 函数的名称相同, 但是参数不同的几个函数, 就是函数的重载</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="built_in">number</span>; <span class="comment">// 没函数体</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: <span class="built_in">string</span>, num2: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: <span class="built_in">any</span>, num2: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> num1 === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> num2 === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1.<span class="property">length</span> + num2.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的调用</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">add</span>(<span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> result2 = <span class="title function_">add</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// 50</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数的重载中, 实现函数是不能直接被调用的</span></span><br><span class="line"><span class="comment">// add(&#123;name: &quot;why&quot;&#125;, &#123;age: 18&#125;) // 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="联合类型和重载"><a href="#联合类型和重载" class="headerlink" title="联合类型和重载"></a>联合类型和重载</h3><ul>
<li>我们现在有一个需求：定义一个函数，可以传入字符串或者数组，获取它们的长度。</li>
<li>这里有两种实现方案：<ul>
<li>方案一：使用联合类型来实现；</li>
<li>方案二：实现函数重载来实现；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现方式一: 联合类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">args: <span class="built_in">string</span> | <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>(<span class="string">&quot;abc&quot;</span>)) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>([<span class="number">123</span>, <span class="number">321</span>, <span class="number">123</span>])) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现方式二: 函数的重载</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">args: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">args: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">args: <span class="built_in">any</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>(<span class="string">&quot;abc&quot;</span>)) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>([<span class="number">123</span>, <span class="number">321</span>, <span class="number">123</span>])) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在开发中我们选择使用哪一种呢？<ul>
<li>在可能的情况下，尽量选择使用联合类型来实现；</li>
</ul>
</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="认识类的使用"><a href="#认识类的使用" class="headerlink" title="认识类的使用"></a>认识类的使用</h3><ul>
<li><p>类的定义我们通常会使用class关键字：</p>
<ul>
<li>在面向对象的世界里，任何事物都可以使用类的结构来描述；</li>
<li>类中包含特有的属性和方法；认识类的使用</li>
</ul>
</li>
<li><p>在早期的JavaScript开发中（ES5）我们需要通过函数和原型链来实现类和继承，从ES6开始，引入了class关键字，可以更加方便的定义和使用类。</p>
</li>
<li><p>TypeScript作为JavaScript的超集，也是支持使用class关键字的，并且还可以对类的属性和方法等进行静态类型检测。</p>
</li>
<li><p>实际上在JavaScript的开发过程中，我们更加习惯于函数式编程：</p>
<ul>
<li>比如React开发中，目前更多使用的函数组件以及结合Hook的开发模式；</li>
<li>比如在Vue3开发中，目前也更加推崇使用 Composition API；</li>
</ul>
</li>
<li><p>但是在封装某些业务的时候，类具有更强大封装性，所以我们也需要掌握它们。</p>
</li>
</ul>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><ul>
<li>我们来定义一个Person类：</li>
<li>使用class关键字来定义一个类；</li>
<li>我们可以声明一些类的属性：在类的内部声明类的属性以及对应的类型<ul>
<li>如果类型没有声明，那么它们默认是any的；</li>
<li>我们也可以给属性设置初始化值；</li>
<li>在默认的strictPropertyInitialization模式下面我们的属性是必须初始化的，如果没有初始化，那么编译时就会报错；<ul>
<li>ü	如果我们在strictPropertyInitialization模式下确实不希望给属性初始化，可以使用 name!: string语法；</li>
</ul>
</li>
</ul>
</li>
<li>类可以有自己的构造函数constructor，当我们通过new关键字创建一个实例时，构造函数会被调用；<ul>
<li>构造函数不需要返回任何值，默认返回当前创建出来的实例；</li>
</ul>
</li>
<li>类中可以有自己的函数，定义的函数称之为方法；</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; eating&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;why&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>) <span class="comment">// why</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">age</span>) <span class="comment">// 18</span></span><br><span class="line">p.<span class="title function_">eating</span>() <span class="comment">// why eating</span></span><br></pre></td></tr></table></figure>

<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><ul>
<li>面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。</li>
<li>我们使用extends关键字来实现继承，子类中使用super来访问父类。</li>
<li>我们来看一下Student类继承自Person：<ul>
<li>Student类可以有自己的属性和方法，并且会继承Person的属性和方法；</li>
<li>在构造函数中，我们可以通过super来调用父类的构造方法，对父类中的属性进行初始化；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;eating&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承 Person 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="attr">sno</span>: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">  <span class="title function_">studying</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;studying&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承 Person 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="title function_">teaching</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;teaching&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类的实例对象</span></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line">stu.<span class="property">name</span> = <span class="string">&quot;coderwhy&quot;</span></span><br><span class="line">stu.<span class="property">age</span> = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">name</span>) <span class="comment">// coderwhy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">age</span>) <span class="comment">// 18</span></span><br><span class="line">stu.<span class="title function_">eating</span>() <span class="comment">// eating</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;eating 100行&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="attr">sno</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, sno: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// super 调用父类的构造器</span></span><br><span class="line">    <span class="variable language_">super</span>(name, age)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sno</span> = sno</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类实例方法重写</span></span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;student eating&#x27;</span>)</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">eating</span>() <span class="comment">// 调用父类的实例方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">studying</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;studying&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类的实例对象</span></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;why&#x27;</span>, <span class="number">18</span>, <span class="number">111</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">name</span>) <span class="comment">// why</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">age</span>) <span class="comment">// 18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">sno</span>) <span class="comment">// 111</span></span><br><span class="line">stu.<span class="title function_">eating</span>() <span class="comment">// eating 100行</span></span><br></pre></td></tr></table></figure>

<h3 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">action</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;animal action&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">action</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dog running!!!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">action</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fish swimming&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// animal: dog/fish</span></span><br><span class="line"><span class="comment">// 多态的目的是为了写出更加具备通用性的代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeActions</span>(<span class="params">animals: Animal[]</span>) &#123;</span><br><span class="line">  animals.<span class="title function_">forEach</span>(<span class="function">(<span class="params">animal</span>) =&gt;</span> &#123;</span><br><span class="line">    animal.<span class="title function_">action</span>() <span class="comment">// 调用的是自己类的实例方法,没有再去父类找</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">makeActions</span>([<span class="keyword">new</span> <span class="title class_">Dog</span>(), <span class="keyword">new</span> <span class="title class_">Fish</span>(), <span class="keyword">new</span> <span class="title class_">Cat</span>()])</span><br></pre></td></tr></table></figure>

<h3 id="类的成员修饰符"><a href="#类的成员修饰符" class="headerlink" title="类的成员修饰符"></a>类的成员修饰符</h3><ul>
<li><p>在TypeScript中，类的属性和方法支持三种修饰符： public、private、protected </p>
<ul>
<li>public 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是public的；</li>
<li>private 修饰的是仅在同一类中可见、私有的属性或方法；</li>
<li>protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法；</li>
</ul>
</li>
<li><p>public是默认的修饰符，也是可以直接访问的，我们这里来演示一下protected和private。</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;coderwhy&#x27;</span> <span class="comment">// 类的私有成员,只能在类中访问</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装了两个方法, 通过方法来访问name</span></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> <span class="comment">// 返回 Person 类的私有成员 name</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = newName <span class="comment">// 更新 Person 类的私有成员 name</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> <span class="comment">// 返回 Person 类的私有成员 name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="title function_">getName</span>()) <span class="comment">// coderwhy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="title function_">setName</span>(<span class="string">&#x27;why&#x27;</span>)) <span class="comment">// why</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;123&#x27;</span> <span class="comment">// protected: 在类内部和子类中可以访问,类的实例无法直接访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例对象</span></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="title function_">getName</span>()) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h3 id="只读属性readonly"><a href="#只读属性readonly" class="headerlink" title="只读属性readonly"></a>只读属性readonly</h3><ul>
<li>如果有一个属性我们不希望外界可以任意的修改，只希望确定值后直接使用，那么可以使用readonly：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 1.只读属性是可以在构造器中赋值, 赋值之后就不可以修改</span></span><br><span class="line">  <span class="comment">// 2.属性本身不能进行修改, 但是如果它是对象类型, 对象中的属性是可以修改</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">readonly</span> friend?: <span class="title class_">Person</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, friend?: Person</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friend</span> = friend</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;why&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;kobe&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>) <span class="comment">// why</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">friend</span>) <span class="comment">// Person &#123;name: &#x27;kobe&#x27;, age: undefined, friend: undefined&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p.friend = new Person(&quot;james&quot;) // 不可以直接修改friend</span></span><br><span class="line"><span class="keyword">if</span> (p.<span class="property">friend</span>) &#123;</span><br><span class="line">  p.<span class="property">friend</span>.<span class="property">age</span> = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p.name = &quot;123&quot; // 不可以直接修改类的只读属性</span></span><br></pre></td></tr></table></figure>

<h3 id="getters-setters"><a href="#getters-setters" class="headerlink" title="getters&#x2F;setters"></a>getters&#x2F;setters</h3><ul>
<li>在前面一些私有属性我们是不能直接访问的，或者某些属性我们想要监听它的获取(getter)和设置(setter)的过程，这个时候我们可以使用存取器。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问器 setter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = newName</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 访问器 getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;why&#x27;</span>)</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>) <span class="comment">// coderwhy</span></span><br></pre></td></tr></table></figure>

<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ul>
<li>前面我们在类中定义的成员和方法都属于对象级别的, 在开发中, 我们有时候也需要定义类级别的成员和方法。</li>
<li>在TypeScript中通过关键字static来定义：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">time</span>: <span class="built_in">string</span> = <span class="string">&quot;20:00&quot;</span> <span class="comment">// static 静态成员</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">attendClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;去学习~&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Student</span>.<span class="property">time</span>) <span class="comment">// 20:00 ,访问类的静态成员</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="title function_">attendClass</span>() <span class="comment">// 去学习~ , 调用静态方法</span></span><br></pre></td></tr></table></figure>

<h3 id="抽象类abstract"><a href="#抽象类abstract" class="headerlink" title="抽象类abstract"></a>抽象类abstract</h3><ul>
<li><p>我们知道，继承是多态使用的前提。</p>
<ul>
<li>所以在定义很多通用的调用接口时, 我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。</li>
<li>但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法,，我们可以定义为抽象方法。</li>
</ul>
</li>
<li><p>什么是 抽象方法? 在TypeScript中没有具体实现的方法(没有方法体)，就是抽象方法。</p>
<ul>
<li>抽象方法，必须存在于抽象类中；</li>
<li>抽象类是使用abstract声明的类；</li>
</ul>
</li>
<li><p>抽象类有如下的特点：</p>
<ul>
<li>抽象类是不能被实例的话（也就是不能通过new创建）</li>
<li>抽象方法必须被子类实现，否则该类必须是一个抽象类；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> shape.<span class="title function_">getArea</span>() <span class="comment">// 传入一个类的实例对象,通过类的实例对象调用方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类,不能实例化(不能 new),且所有抽象方法在子类中必须实现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">getArea</span>(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">width</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">height</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">width: <span class="built_in">number</span>, height: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">r</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">r: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">r</span> = r</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">r</span> * <span class="variable language_">this</span>.<span class="property">r</span> * <span class="number">3.14</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的实例化</span></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeArea</span>(rectangle)) <span class="comment">// 600</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeArea</span>(circle)) <span class="comment">// 314</span></span><br></pre></td></tr></table></figure>

<h3 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h3><ul>
<li>类本身也是可以作为一种数据类型的：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;123&quot;</span></span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;123&quot;</span></span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPerson</span>(<span class="params">p: Person</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printPerson</span>(<span class="keyword">new</span> <span class="title class_">Person</span>()) <span class="comment">// 123</span></span><br><span class="line"><span class="title function_">printPerson</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">eating</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;&#125;) <span class="comment">// kobe</span></span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h3><ul>
<li>在前面我们通过type可以用来声明一个对象类型：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类型(type)别名来声明对象类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">InfoType</span> = &#123;<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象的另外一种声明方式就是通过接口来声明：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外一种方式声明对象类型: 接口interface</span></span><br><span class="line"><span class="comment">// 在其中可以定义可选类型 , 也可以定义只读属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IInfoType</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  friend?: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">IInfoType</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">friend</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>?.<span class="property">name</span>) <span class="comment">// kobe</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">name</span>) <span class="comment">// why</span></span><br><span class="line"><span class="comment">// info.name = &quot;123&quot; // 只读属性,不能修改</span></span><br><span class="line">info.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">age</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>他们在使用上的区别，我们后续再来说明。</li>
<li>接下来我们继续学习一下接口的其他特性。</li>
</ul>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><ul>
<li>接口中我们也可以定义可选属性：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外一种方式声明对象类型: 接口interface</span></span><br><span class="line"><span class="comment">// 在其中可以定义可选类型 , 也可以定义只读属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IInfoType</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  friend?: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">IInfoType</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">friend</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>?.<span class="property">name</span>) <span class="comment">// kobe</span></span><br></pre></td></tr></table></figure>

<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><ul>
<li>接口中也可以定义只读属性：<ul>
<li>这样就意味着我们再初始化之后，这个值是不可以被修改的；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外一种方式声明对象类型: 接口interface</span></span><br><span class="line"><span class="comment">// 在其中可以定义可选类型 , 也可以定义只读属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IInfoType</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  friend?: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">IInfoType</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">friend</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">name</span>) <span class="comment">// why</span></span><br><span class="line"><span class="comment">// info.name = &quot;123&quot; // 只读属性,不能修改</span></span><br><span class="line">info.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">age</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li>前面我们使用interface来定义对象类型，这个时候其中的属性名、类型、方法都是确定的，但是有时候我们会遇到类似下面的对象：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过interface来定义索引类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IndexLanguage</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">frontLanguage</span>: <span class="title class_">IndexLanguage</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;HTML&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;CSS&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;JavaScript&#x27;</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ILanguageYear</span> &#123;</span><br><span class="line">  [<span class="attr">name</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">languageYear</span>: <span class="title class_">ILanguageYear</span> = &#123;</span><br><span class="line">  <span class="attr">C</span>: <span class="number">1972</span>,</span><br><span class="line">  <span class="title class_">Java</span>: <span class="number">1995</span>,</span><br><span class="line">  <span class="title class_">JavaScript</span>: <span class="number">1996</span>,</span><br><span class="line">  <span class="title class_">TypeScript</span>: <span class="number">2014</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><ul>
<li>前面我们都是通过interface来定义对象中普通的属性和方法的，实际上它也可以用来定义函数类型：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可调用的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CalcFn</span> &#123;</span><br><span class="line">  (<span class="attr">n1</span>: <span class="built_in">number</span>, <span class="attr">n2</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calc</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span>, calcFn: CalcFn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">calcFn</span>(num1, num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">CalcFn</span> = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calc</span>(<span class="number">20</span>, <span class="number">30</span>, add)) <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当然，除非特别的情况，还是推荐大家使用类型别名来定义函数：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CalcFn</span> = <span class="function">(<span class="params">n1: <span class="built_in">number</span>, n2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br></pre></td></tr></table></figure>

<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><ul>
<li>接口和类一样是可以进行继承的，也是使用extends关键字：<ul>
<li>并且我们会发现，接口是支持多继承的（类不支持多继承）</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ISwim</span> &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IFly</span> &#123;</span><br><span class="line">  <span class="attr">flying</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口并继承接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IAction</span> <span class="keyword">extends</span> <span class="title class_">ISwim</span>, <span class="title class_">IFly</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用继承的接口限定对象中的两个属性必须是方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">action</span>: <span class="title class_">IAction</span> = &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">flying</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><ul>
<li>接口定义后，也是可以被类实现的：<ul>
<li>如果被一个类实现，那么在之后需要传入接口的地方，都可以将这个类传入；</li>
<li>这就是面向接口开发；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ISwim</span> &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IEat</span> &#123;</span><br><span class="line">  <span class="attr">eating</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承: 只能实现单继承</span></span><br><span class="line"><span class="comment">// 实现: 实现接口, 类可以实现多个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> <span class="keyword">implements</span> <span class="title class_">ISwim</span>, <span class="title class_">IEat</span> &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Fish Swmming&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Fish Eating&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">ISwim</span> &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Person Swimming&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一些公共的API: 面向接口编程</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swimAction</span>(<span class="params">swimable: ISwim</span>) &#123;</span><br><span class="line">  swimable.<span class="title function_">swimming</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.所有实现了接口的类对应的对象, 都是可以传入</span></span><br><span class="line"><span class="title function_">swimAction</span>(<span class="keyword">new</span> <span class="title class_">Fish</span>()) <span class="comment">// Fish Swmming</span></span><br><span class="line"><span class="title function_">swimAction</span>(<span class="keyword">new</span> <span class="title class_">Person</span>()) <span class="comment">// Person Swimming</span></span><br><span class="line"><span class="title function_">swimAction</span>(&#123;<span class="attr">swimming</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><ul>
<li>前面我们学习了联合类型：<ul>
<li>联合类型表示多个类型中一个即可</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一种组合类型的方式: 联合类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">WhyType</span> = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;center&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>还有另外一种类型合并，就是交叉类型（Intersection Types）：<ul>
<li>交叉类似表示需要满足多个类型的条件；</li>
<li>交叉类型使用 &amp; 符号；</li>
</ul>
</li>
<li>我们来看下面的交叉类型：<ul>
<li>表达的含义是number和string要同时满足；</li>
<li>但是有同时满足是一个number又是一个string的值吗？其实是没有的，所以MyType其实是一个never类型；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另一种组合类型的方式: 交叉类型</span></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ISwim</span> &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IFly</span> &#123;</span><br><span class="line">  <span class="attr">flying</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyType1</span> = <span class="title class_">ISwim</span> | <span class="title class_">IFly</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyType2</span> = <span class="title class_">ISwim</span> &amp; <span class="title class_">IFly</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义的数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj1</span>: <span class="title class_">MyType1</span> = &#123;</span><br><span class="line">  <span class="title function_">flying</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: <span class="title class_">MyType2</span> = &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">flying</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="interface和type区别"><a href="#interface和type区别" class="headerlink" title="interface和type区别"></a>interface和type区别</h3><ul>
<li>我们会发现interface和type都可以用来定义对象类型，那么在开发中定义对象类型时，到底选择哪一个呢？<ul>
<li>如果是定义非对象类型，通常推荐使用type，比如Direction、Alignment、一些Function；</li>
</ul>
</li>
<li>如果是定义对象类型，那么他们是有区别的：<ul>
<li>interface 可以重复的对某个接口来定义属性和方法；</li>
<li>而type定义的是别名，别名是不能重复的；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同名的接口会合并</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IFoo</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IFoo</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: <span class="title class_">IFoo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IBar</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错,标识符“IBar”重复。</span></span><br><span class="line"><span class="comment">// type IBar = &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="字面量赋值"><a href="#字面量赋值" class="headerlink" title="字面量赋值"></a>字面量赋值</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// freshness 擦除</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">IPerson</span> = info  <span class="comment">// 不能直接在等号右边跟一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info) <span class="comment">// &#123;name: &#x27;why&#x27;, age: 18, height: 1.88, address: &#x27;广州市&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p) <span class="comment">// &#123;name: &#x27;why&#x27;, age: 18, height: 1.88, address: &#x27;广州市&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printInfo</span>(<span class="params">person: IPerson</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码会报错</span></span><br><span class="line"><span class="comment">// printInfo(&#123;</span></span><br><span class="line"><span class="comment">//   name: &quot;why&quot;,</span></span><br><span class="line"><span class="comment">//   age: 18,</span></span><br><span class="line"><span class="comment">//   height: 1.88,</span></span><br><span class="line"><span class="comment">//   address: &quot;广州市&quot;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printInfo</span>(info) <span class="comment">// &#123;name: &#x27;why&#x27;, age: 18, height: 1.88, address: &#x27;广州市&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这是因为TypeScript在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。<ul>
<li>但是之后如果我们是将一个变量标识符 赋值给其他的变量时，会进行 freshness 擦除操作。</li>
</ul>
</li>
</ul>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h3 id="TS枚举类型"><a href="#TS枚举类型" class="headerlink" title="TS枚举类型"></a>TS枚举类型</h3><ul>
<li>枚举类型是为数不多的TypeScript特性有的特性之一：<ul>
<li>枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型；</li>
<li>枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型；</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;Right&quot;</span> | <span class="string">&quot;Top&quot;</span> | <span class="string">&quot;Bottom&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="variable constant_">LEFT</span>,</span><br><span class="line">  <span class="variable constant_">RIGHT</span>,</span><br><span class="line">  <span class="variable constant_">TOP</span>,</span><br><span class="line">  <span class="variable constant_">BOTTOM</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">turnDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">LEFT</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向左&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">RIGHT</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向右&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">TOP</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向上&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Direction</span>.<span class="property">BOTTOM</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变角色的方向向下&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">foo</span>: <span class="built_in">never</span> = direction;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">turnDirection</span>(<span class="title class_">Direction</span>.<span class="property">LEFT</span>)</span><br><span class="line"><span class="title function_">turnDirection</span>(<span class="title class_">Direction</span>.<span class="property">RIGHT</span>)</span><br><span class="line"><span class="title function_">turnDirection</span>(<span class="title class_">Direction</span>.<span class="property">TOP</span>)</span><br><span class="line"><span class="title function_">turnDirection</span>(<span class="title class_">Direction</span>.<span class="property">BOTTOM</span>)</span><br></pre></td></tr></table></figure>

<h3 id="枚举类型的值"><a href="#枚举类型的值" class="headerlink" title="枚举类型的值"></a>枚举类型的值</h3><ul>
<li>枚举类型默认是有值的，比如上面的枚举，默认值是这样的：</li>
<li>当然，我们也可以给枚举其他值：<ul>
<li>这个时候会从100进行递增；</li>
</ul>
</li>
<li>我们也可以给他们赋值其他的类型：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="认识泛型"><a href="#认识泛型" class="headerlink" title="认识泛型"></a>认识泛型</h3><ul>
<li>软件工程的主要目的是构建不仅仅明确和一致的API，还要让你的代码具有很强的可重用性：<ul>
<li>比如我们可以通过函数来封装一些API，通过传入不同的函数参数，让函数帮助我们完成不同的操作；</li>
<li>但是对于参数的类型是否也可以参数化呢？<ul>
<li>泛型,就是将类型参数化</li>
</ul>
</li>
</ul>
</li>
<li>什么是类型的参数化？<ul>
<li>我们来提一个需求：封装一个函数，传入一个参数，并且返回这个参数；</li>
</ul>
</li>
<li>如果我们是TypeScript的思维方式，要考虑这个参数和返回值的类型需要一致：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">456</span>)) <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码虽然实现了，但是不适用于其他类型，比如string、boolean、Person等类型：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型,就是将类型参数化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义这个函数时, 我不决定这些参数的类型</span></span><br><span class="line"><span class="comment">// 而是让调用者以参数的形式告知,我这里的函数参数应该是什么类型</span></span><br><span class="line"><span class="keyword">function</span> sum&lt;<span class="title class_">Type</span>&gt;(<span class="attr">num</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.调用方式一: 明确的传入类型</span></span><br><span class="line">sum&lt;<span class="built_in">number</span>&gt;(<span class="number">20</span>)</span><br><span class="line">sum&lt;&#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;&gt;(&#123; <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span> &#125;)</span><br><span class="line">sum&lt;<span class="built_in">any</span>[]&gt;([<span class="string">&#x27;abc&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用方式二: 自动进行类型推导</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">50</span>)</span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="泛型实现类型参数化"><a href="#泛型实现类型参数化" class="headerlink" title="泛型实现类型参数化"></a>泛型实现类型参数化</h3><ul>
<li>虽然any是可以的，但是定义为any的时候，我们其实已经丢失了类型信息：<ul>
<li>比如我们传入的是一个number，那么我们希望返回的可不是any类型，而是number类型；</li>
<li>所以，我们需要在函数中可以捕获到参数的类型是number，并且同时使用它来作为返回值的类型；</li>
</ul>
</li>
<li>我们需要在这里使用一种特性的变量 - 类型变量（type variable），它作用于类型，而不是值：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型,就是将类型参数化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义这个函数时, 我不决定这些参数的类型</span></span><br><span class="line"><span class="comment">// 而是让调用者以参数的形式告知,我这里的函数参数应该是什么类型</span></span><br><span class="line"><span class="keyword">function</span> sum&lt;<span class="title class_">Type</span>&gt;(<span class="attr">num</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.调用方式一: 明确的传入类型</span></span><br><span class="line">sum&lt;<span class="built_in">number</span>&gt;(<span class="number">20</span>)</span><br><span class="line">sum&lt;&#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;&gt;(&#123; <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span> &#125;)</span><br><span class="line">sum&lt;<span class="built_in">any</span>[]&gt;([<span class="string">&#x27;abc&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用方式二: 自动进行类型推导</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">50</span>)</span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>这里我们可以使用两种方式来调用它：<ul>
<li>方式一：通过 &lt;类型&gt; 的方式将类型传递给函数；</li>
<li>方式二：通过类型推到，自动推到出我们传入变量的类型：<ul>
<li>在这里会推导出它们是 字面量类型的，因为字面量类型对于我们的函数也是适用的</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型,就是将类型参数化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义这个函数时, 我不决定这些参数的类型</span></span><br><span class="line"><span class="comment">// 而是让调用者以参数的形式告知,我这里的函数参数应该是什么类型</span></span><br><span class="line"><span class="keyword">function</span> sum&lt;<span class="title class_">Type</span>&gt;(<span class="attr">num</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.调用方式一: 明确的传入类型</span></span><br><span class="line">sum&lt;<span class="built_in">number</span>&gt;(<span class="number">20</span>)</span><br><span class="line">sum&lt;&#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;&gt;(&#123; <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span> &#125;)</span><br><span class="line">sum&lt;<span class="built_in">any</span>[]&gt;([<span class="string">&#x27;abc&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用方式二: 自动进行类型推导</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">50</span>)</span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="泛型的基本补充"><a href="#泛型的基本补充" class="headerlink" title="泛型的基本补充"></a>泛型的基本补充</h3><ul>
<li>当然我们也可以传入多个类型：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo&lt;T, E, O&gt;(<span class="attr">arg1</span>: T, <span class="attr">arg2</span>: E, arg3?: O, ...<span class="attr">args</span>: T[]) &#123; <span class="comment">// 这里限定 args 不定参是一个元素为 number 类型的数组</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg1, arg2, arg3, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo&lt;<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>&gt;(<span class="number">10</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="literal">true</span>, <span class="number">18</span>, <span class="number">20</span>) <span class="comment">// 10 &#x27;abc&#x27; true [18, 20]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>平时在开发中我们可能会看到一些常用的名称：<ul>
<li>T：Type的缩写，类型</li>
<li>K、V：key和value的缩写，键值对</li>
<li>E：Element的缩写，元素</li>
<li>pO：Object的缩写，对象</li>
</ul>
</li>
</ul>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><ul>
<li>在定义接口的时候我们也可以使用泛型：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给泛型接口提供默认类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span>&lt;T1 = <span class="built_in">string</span>, T2 = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="variable constant_">T1</span></span><br><span class="line">  <span class="attr">age</span>: <span class="variable constant_">T2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="variable constant_">T1</span></span><br><span class="line">  <span class="attr">age</span>: <span class="variable constant_">T2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用接口时指定泛型接口的数据类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">IPerson</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ul>
<li>我们也可以编写一个泛型类</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">x</span>: T</span><br><span class="line">  <span class="attr">y</span>: T</span><br><span class="line">  <span class="attr">z</span>: T</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x: T, y: T, z: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">z</span> = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="string">&#x27;1.33.2&#x27;</span>, <span class="string">&#x27;2.22.3&#x27;</span>, <span class="string">&#x27;4.22.1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;1.33.2&#x27;</span>, <span class="string">&#x27;2.22.3&#x27;</span>, <span class="string">&#x27;4.22.1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p3</span>: <span class="title class_">Point</span>&lt;<span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="string">&#x27;1.33.2&#x27;</span>, <span class="string">&#x27;2.22.3&#x27;</span>, <span class="string">&#x27;4.22.1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">names1</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>, <span class="string">&#x27;nba&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">names2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>, <span class="string">&#x27;nba&#x27;</span>] <span class="comment">// 不推荐(react jsx &lt;&gt;)</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><ul>
<li>有时候我们希望传入的类型有某些共性，但是这些共性可能不是在同一种类型中：<ul>
<li>比如string和array都是有length的，或者某些对象也是会有length属性的；</li>
<li>那么只要是拥有length的属性都可以作为我们的参数类型，那么应该如何操作呢？</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILength</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getLength&lt;T <span class="keyword">extends</span> <span class="title class_">ILength</span>&gt;(<span class="attr">arg</span>: T) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getLength</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="title function_">getLength</span>([<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>])</span><br><span class="line"><span class="title function_">getLength</span>(&#123; <span class="attr">length</span>: <span class="number">100</span> &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h3><ul>
<li>TypeScript支持两种方式来控制我们的作用域：<ul>
<li>模块化：每个文件可以是一个独立的模块，支持ES Module，也支持CommonJS；</li>
<li>命名空间：通过namespace来声明一个命名空间</li>
</ul>
</li>
</ul>
<p><strong>math.ts</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sub</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>main.ts</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add, sub &#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">20</span>, <span class="number">30</span>)); <span class="comment">// 50</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sub</span>(<span class="number">20</span>, <span class="number">30</span>)); <span class="comment">// -10</span></span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul>
<li>命名空间在TypeScript早期时，称之为内部模块，主要目的是将一个模块内部再进行作用域的划分，防止一些命名冲突的问题。</li>
</ul>
<p><strong>.&#x2F;format.ts</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> time &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">time: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;2222-02-22&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> price &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">price: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> price</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>main.ts</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; time, price &#125; <span class="keyword">from</span> <span class="string">&#x27;./format&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(time.<span class="title function_">format</span>(<span class="string">&#x27;11111111&#x27;</span>))<span class="comment">//2222-02-22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(price.<span class="title function_">format</span>(<span class="number">123</span>)) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><h3 id="类型的查找"><a href="#类型的查找" class="headerlink" title="类型的查找"></a>类型的查找</h3><ul>
<li>之前我们所有的typescript中的类型，几乎都是我们自己编写的，但是我们也有用到一些其他的类型：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2024/01/28/173ab306d65e4c9996290b4968c7cfda" alt="1668169663529"></p>
<ul>
<li>大家是否会奇怪，我们的HTMLImageElement类型来自哪里呢？甚至是document为什么可以有getElementById的方法呢？<ul>
<li>其实这里就涉及到typescript对类型的管理和查找规则了。</li>
</ul>
</li>
<li>我们这里先给大家介绍另外的一种typescript文件：.d.ts文件<ul>
<li>我们之前编写的typescript文件都是 .ts 文件，这些文件最终会输出 .js 文件，也是我们通常编写代码的地方；</li>
<li>还有另外一种文件 .d.ts 文件，它是用来做类型的声明(declare)。 它仅仅用来做类型检测，告知typescript我们有哪些类型；</li>
</ul>
</li>
<li>那么typescript会在哪里查找我们的类型声明呢？<ul>
<li>内置类型声明；</li>
<li>外部定义类型声明；</li>
<li>自己定义类型声明；</li>
</ul>
</li>
</ul>
<h3 id="内置类型声明"><a href="#内置类型声明" class="headerlink" title="内置类型声明"></a>内置类型声明</h3><ul>
<li>内置类型声明是 typescript 自带的、帮助我们内置了 JavaScript 运行时的一些标准化 API 的声明文件；<ul>
<li>包括比如 Math、Date 等内置类型，也包括 DOM API，比如 Window、Document 等；</li>
</ul>
</li>
<li>内置类型声明通常在我们安装 typescript 的环境中会带有的；</li>
<li><a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/tree/main/lib">https://github.com/microsoft/TypeScript/tree/main/lib</a></li>
</ul>
<h3 id="定义类型声明"><a href="#定义类型声明" class="headerlink" title="定义类型声明"></a>定义类型声明</h3><ul>
<li>外部类型声明通常是我们使用一些库（比如第三方库）时，需要的一些类型声明。</li>
<li>这些库通常有两种类型声明方式：</li>
<li>方式一：在自己库中进行类型声明（编写.d.ts文件），比如axios</li>
<li>方式二：通过社区的一个公有库DefinitelyTyped存放类型声明文件<ul>
<li>该库的GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped/">https://github.com/DefinitelyTyped/DefinitelyTyped/</a></li>
<li>该库查找声明安装方式的地址：<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/dt/search?search=">https://www.typescriptlang.org/dt/search?search=</a></li>
<li>比如我们安装react的类型声明： <strong>npm i @types&#x2F;react –save-dev</strong></li>
</ul>
</li>
<li>什么情况下需要自己来定义声明文件呢？<ul>
<li>情况一：我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash</li>
<li>情况二：我们给自己的代码中声明一些类型，方便在其他地方直接进行使用；</li>
</ul>
</li>
</ul>
<h3 id="声明模块"><a href="#声明模块" class="headerlink" title="声明模块"></a>声明模块</h3><ul>
<li>我们也可以声明模块，比如lodash模块默认不能使用的情况，可以自己来声明这个模块：</li>
</ul>
<p><strong>xxx.d.ts</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明模块</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;lodash&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 声明变量/函数/类</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">whyName</span>: <span class="built_in">string</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">whyAge</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">whyHeight</span>: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">whyFoo</span>(<span class="params"></span>): <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明模块的语法: declare module ‘模块名’ { }。<ul>
<li>在声明模块的内部，我们可以通过 export 导出对应库的类、函数等；</li>
</ul>
</li>
</ul>
<h3 id="declare文件"><a href="#declare文件" class="headerlink" title="declare文件"></a>declare文件</h3><ul>
<li>在某些情况下，我们也可以声明文件：<ul>
<li>比如在开发vue的过程中，默认是不识别我们的.vue文件的，那么我们就需要对其进行文件的声明；</li>
<li>比如在开发中我们使用了 jpg 这类图片文件，默认typescript也是不支持的，也需要对其进行声明；</li>
</ul>
</li>
</ul>
<p><strong>xxx.d.ts</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明文件</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.jpg&#x27;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.jpeg&#x27;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.png&#x27;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.svg&#x27;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.gif&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="declare命名空间"><a href="#declare命名空间" class="headerlink" title="declare命名空间"></a>declare命名空间</h3><ul>
<li>比如我们在 index.html 中直接引入了jQuery：<ul>
<li>CDN 地址： <a target="_blank" rel="noopener" href="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js">https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js</a></li>
</ul>
</li>
<li>我们可以进行命名空间的声明：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明命名空间</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> $ &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">settings: <span class="built_in">any</span></span>): <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在main.ts中就可以使用了：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123; &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="tsconfig-json文件"><a href="#tsconfig-json文件" class="headerlink" title="tsconfig.json文件"></a>tsconfig.json文件</h3><ul>
<li>tsconfig.json是用于配置TypeScript编译时的配置选项：<ul>
<li><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig">https://www.typescriptlang.org/tsconfig</a></li>
</ul>
</li>
<li>我们这里讲解几个比较常见的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg"></a><div class="post-copyright__author_name">蜗牛浪迹天涯</div><div class="post-copyright__author_desc">宁静致远，热爱生活。</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div><div class="post-reward" onclick="AddRewardMask()"><div class="reward-button" title="赞赏作者"><i class="scoicon sco-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><ul class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a target="_blank" rel="noopener" href="https://bu.dusays.com/2023/11/07/6549e79364fa3.png"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/07/6549e79364fa3.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://bu.dusays.com/2023/11/07/6549e79d02bd6.png" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/07/6549e79d02bd6.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></ul></div></div><script>function RemoveRewardMask() {
    let rewardMainElements = document.querySelectorAll(".reward-main");
    let quitBoxElement = document.querySelector("#quit-box");

    console.log("RemoveRewardMask")

    rewardMainElements.forEach(element => {
        element.style.display = "none";
    });

    if (quitBoxElement) {
        quitBoxElement.style.display = "none";
    }
}

function AddRewardMask() {
    let rewardMainElements = document.querySelectorAll(".reward-main");
    let quitBoxElement = document.querySelector("#quit-box");

    console.log("AddRewardMask")

    rewardMainElements.forEach(element => {
        element.style.display = "flex";
    });

    if (quitBoxElement) {
        quitBoxElement.style.display = "flex";
    }
}</script></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">蜗牛浪迹天涯</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/24/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/402_Webpack/40201_Webpack/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Webpack</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/303_React/30305_React_Hooks%E8%A7%A3%E6%9E%90/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">React Hooks</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">一日之计在于晨</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg"><div class="avatar-sticker"><img class="avatar-sticker-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/12/30/659011053e246.png" alt="心情贴纸"></div></div><div class="author-info__description_group"><div class="author-info__description">分享自己对编程的<b>热爱</b>，对美好生活的<b>向往</b>，对知识海洋<b>探索历程</b>。</div><div class="author-info__description2">相信你可以在这里找到对你有用的知识和教程。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><div class="author-info__name">snail289</div><div class="author-info__desc">宁静致远，热爱生活。</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://github.com/DuoSco/Hexo-Theme-slitude" title="Github"><i class="scoicon sco-github-line"></i></a><a class="social-icon" target="_blank" rel="noopener" href="https://space.bilibili.com/1329819902" title="Bilibili"><i class="scoicon sco-bilibili-line"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="scoicon sco-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">JS存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EJS"><span class="toc-text">关于JS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">JS的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%B1%BB%E5%9E%8B"><span class="toc-text">关于类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">类型带来的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF"><span class="toc-text">类型错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%80%9D%E7%BB%B4"><span class="toc-text">类型思维</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">JS添加类型约束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%82%E9%80%85TypeScript"><span class="toc-text">邂逅TypeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86TypeScript"><span class="toc-text">认识TypeScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">TypeScript的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%87%87%E7%94%A8TypeScript"><span class="toc-text">项目采用TypeScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E7%9A%84%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF"><span class="toc-text">前端的发展趋势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">TypeScript基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TS%E7%9A%84%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="toc-text">TS的编译环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TS%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-text">TS的运行环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">TypeScript变量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">变量的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">声明变量的关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text">变量的类型推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#number%E7%B1%BB%E5%9E%8B"><span class="toc-text">number类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boolean%E7%B1%BB%E5%9E%8B"><span class="toc-text">boolean类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E7%B1%BB%E5%9E%8B"><span class="toc-text">string类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array%E7%B1%BB%E5%9E%8B"><span class="toc-text">Array类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB%E5%9E%8B"><span class="toc-text">Object类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol%E7%B1%BB%E5%9E%8B"><span class="toc-text">Symbol类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null%E5%92%8Cundefined"><span class="toc-text">null和undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any%E7%B1%BB%E5%9E%8B"><span class="toc-text">any类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unknown%E7%B1%BB%E5%9E%8B"><span class="toc-text">unknown类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void%E7%B1%BB%E5%9E%8B"><span class="toc-text">void类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never%E7%B1%BB%E5%9E%8B"><span class="toc-text">never类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tuple%E7%B1%BB%E5%9E%8B"><span class="toc-text">tuple类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">TypeScript中的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E7%B1%BB%E5%9E%8B"><span class="toc-text">函数的形参类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">函数返回值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">匿名函数的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BD%A2%E5%8F%82"><span class="toc-text">对象类型的形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E7%9A%84%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">形参的可选类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E7%9A%84%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">形参的联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">形参的类型别名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%A1%A5%E5%85%85"><span class="toc-text">其他的类型补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80as"><span class="toc-text">类型断言as</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">非空类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">可选链的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">??和!!的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">字面量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E6%8E%A8%E7%90%86"><span class="toc-text">字面量推理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4"><span class="toc-text">类型保护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F"><span class="toc-text">类型缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E7%AD%89%E7%BC%A9%E5%B0%8F"><span class="toc-text">平等缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in"><span class="toc-text">in</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">TypeScript函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TS%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">TS函数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TS%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90"><span class="toc-text">TS函数类型解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">参数的可选类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-text">剩余参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%8E%A8%E5%AF%BC%E7%9A%84this%E7%B1%BB%E5%9E%8B"><span class="toc-text">可推导的this类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84this%E7%B1%BB%E5%9E%8B"><span class="toc-text">不确定的this类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9Athis%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">指定this的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-text">函数的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-text">联合类型和重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">认识类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">类的多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">类的成员修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7readonly"><span class="toc-text">只读属性readonly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getters-setters"><span class="toc-text">getters&#x2F;setters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BBabstract"><span class="toc-text">抽象类abstract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">类的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">接口的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">只读属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">索引类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">接口的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface%E5%92%8Ctype%E5%8C%BA%E5%88%AB"><span class="toc-text">interface和type区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E8%B5%8B%E5%80%BC"><span class="toc-text">字面量赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TS%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">TS枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC"><span class="toc-text">枚举类型的值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B"><span class="toc-text">认识泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-text">泛型实现类型参数化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A1%A5%E5%85%85"><span class="toc-text">泛型的基本补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">泛型约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91"><span class="toc-text">模块化开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">类型声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-text">类型的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">内置类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">定义类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%A8%A1%E5%9D%97"><span class="toc-text">声明模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#declare%E6%96%87%E4%BB%B6"><span class="toc-text">declare文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#declare%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">declare命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tsconfig-json%E6%96%87%E4%BB%B6"><span class="toc-text">tsconfig.json文件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="scoicon sco-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/24/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/402_Webpack/40201_Webpack/" title="Webpack"><img alt="Webpack" src= "/img/loading.gif" data-lazy-src="https://tse3-mm.cn.bing.net/th/id/OIP-C.Qb6YcFvpvLuZXJ44H6Nb3gAAAA?w=280&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/01/24/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/402_Webpack/40201_Webpack/" title="Webpack">Webpack</a><a class="article-recent_post_categories" href="/2024/01/24/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/402_Webpack/40201_Webpack/">Web前端开发</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/24/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/401_TypeScript/40101_TypeScript/" title="TypeScript"><img alt="TypeScript" src= "/img/loading.gif" data-lazy-src="https://tse4-mm.cn.bing.net/th/id/OIP-C.EI3avnVaz4qhmuwwpADISQHaEK?w=322&amp;h=181&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/01/24/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/401_TypeScript/40101_TypeScript/" title="TypeScript">TypeScript</a><a class="article-recent_post_categories" href="/2024/01/24/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/401_TypeScript/40101_TypeScript/">Web前端开发</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/303_React/30305_React_Hooks%E8%A7%A3%E6%9E%90/" title="React Hooks"><img alt="React Hooks" src= "/img/loading.gif" data-lazy-src="https://img2.baidu.com/it/u=2126133000,279682015&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=800&amp;h=500"></a><div class="content"><a class="title" href="/2024/01/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/303_React/30305_React_Hooks%E8%A7%A3%E6%9E%90/" title="React Hooks">React Hooks</a><a class="article-recent_post_categories" href="/2024/01/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/303_React/30305_React_Hooks%E8%A7%A3%E6%9E%90/">Web前端开发</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/303_React/30304_React_Router/" title="React_Router"><img alt="React_Router" src= "/img/loading.gif" data-lazy-src="https://img0.baidu.com/it/u=1968277298,413771727&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=499&amp;h=281"></a><div class="content"><a class="title" href="/2024/01/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/303_React/30304_React_Router/" title="React_Router">React_Router</a><a class="article-recent_post_categories" href="/2024/01/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/303_React/30304_React_Router/">Web前端开发</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/303_React/30303_Redux/" title="Redux"><img alt="Redux" src= "/img/loading.gif" data-lazy-src="https://img2.baidu.com/it/u=2805819978,1711130178&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=890&amp;h=500"></a><div class="content"><a class="title" href="/2024/01/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/303_React/30303_Redux/" title="Redux">Redux</a><a class="article-recent_post_categories" href="/2024/01/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/303_React/30303_Redux/">Web前端开发</a></div></div></div></div></div></div></main><footer id="footer"><div id="sco-footer-bar"><div class="footer-logo"><span class="scoicon">首页</span></div><div class="footer-bar-description">来自蜗牛浪迹天涯 - 宁静致远，热爱生活。的文章</div><a class="footer-bar-link" href="/">了解更多</a></div><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com" title="Github"><i class="scoicon sco-bilibili-line"></i></a><a class="deal_link" href="mailto:1448623289@qq.com" title="Mail"><i class="scoicon sco-mail-line"></i></a><div class="footer_mini_logo" id="footer_mini_logo" title="返回顶部" onclick="sco.toTop()"><img src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="返回顶部"></div><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com" title="Bilibili"><i class="scoicon sco-bilibili-line"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://v.douyin.com" title="抖音"><i class="scoicon sco-douyin-fill"></i></a></div><div id="sco-footer"><div class="footer-group"><h3 class="footer-title">导航</h3><div class="footer-links"><a class="footer-item" href="/archives/" title="归档">归档</a><a class="footer-item" href="/categories/" title="分类">分类</a><a class="footer-item" href="/tags/" title="标签">标签</a></div></div><div class="footer-group"><h3 class="footer-title">服务</h3><div class="footer-links"><a class="footer-item" target="_blank" rel="noopener" href="https://aliyun.com/" title="阿里云">阿里云</a><a class="footer-item" target="_blank" rel="noopener" href="https://v6.51.la/" title="51la统计">51la统计</a><a class="footer-item" target="_blank" rel="noopener" href="https://tongji.baidu.com/" title="百度统计">百度统计</a></div></div><div class="footer-group"><h3 class="footer-title">支持</h3><div class="footer-links"><a class="footer-item" href="/about/" title="打赏记录">打赏记录</a><a class="footer-item" target="_blank" rel="noopener" href="https://docs.wzsco.top/" title="文档">文档</a><a class="footer-item" target="_blank" rel="noopener" href="https://blog.wzsco.top/" title="案例">案例</a></div></div><div class="footer-group"><h3 class="footer-title">协议</h3><div class="footer-links"><a class="footer-item" href="/cookies/" title="Cookies">Cookies</a><a class="footer-item" href="/privacy/" title="用户协议">用户协议</a><a class="footer-item" href="/copyright/" title="版权协议">版权协议</a></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 By&nbsp;<a class="footer-bar-link" href="/">snail289</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/DuoSco/hexo-theme-solitude">主题</a><a class="footer-bar-link cc" href="/copyright/"><i class="scoicon sco-copyright-line"></i><i class="scoicon sco-creative-commons-by-line"></i><i class="scoicon sco-creative-commons-nc-line"></i><i class="scoicon sco-creative-commons-nd-line"></i></a></div></div></div><div class="needEndHide" id="cookies-window"><div class="cookies-window-title">协议提醒助手</div><div class="cookies-window-content"><span class="cookies-tip">查看本站为你的个人隐私做出的努力</span><a class="cookies-link" href="/privacy/" title="本站如何保护你的隐私"><i class="scoicon sco-right-btn-fill"></i></a></div></div></footer></div><!-- inject body--><script src="https://cdn.bootcdn.net/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/lib/lazyload.min.js"></script><script src="/lib/snackbar.min.js"></script><script src="/lib/view-image.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/Swiper/9.2.4/swiper-bundle.min.js"></script><div id="js-pjax"><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: 'post',
    toc: true,
    comment: false,
}
</script></div><!-- post-ai)--><script src="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/meting/2.0.1/Meting.min.js"></script><script>const meting_api = 'https://api.injahow.cn/meting/?server=:server&type=:type&id=:id&auth=:auth&r=:r';
</script><script>const coverColorConfig = {
    mode: 'local',
    api: 'https://img2color.meuicat.com/api?img=',
    time: 43200000,
}</script><script src="/lib/cover-color.min.js"></script><!-- waterfall--><script src="/lib/waterfall.min.js"></script><!-- pjax--><script>let pjaxSelectors = [
    'title',
    '#body-wrap',
    '#site-config',
    'meta[name="description"]',
    '#js-pjax',
    'meta[property^="og:"]',
]

const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()
})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- music--><script src="/js/music.js"></script><!-- inject custom body--><script>console.log("body")</script><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="scoicon sco-close-fill"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/extend/search/local-search.js"></script><!-- music--><div class="needEndHide" id="nav-music" onclick="sco.musicToggle()"><div id="nav-music-hoverTips">音乐已暂停</div><meting-js id="8927329843" server="netease" type="playlist" mutex="true" preload="none" data-lrctype="0" order="random" theme="var(--sco-main)"></meting-js></div></body></html><script>const posts=["2024/01/24/Web前端开发/402_Webpack/40201_Webpack/","2024/01/24/Web前端开发/401_TypeScript/40101_TypeScript/","2024/01/23/Web前端开发/303_React/30305_React_Hooks解析/","2024/01/23/Web前端开发/303_React/30304_React_Router/","2024/01/23/Web前端开发/303_React/30303_Redux/","2024/01/23/Web前端开发/303_React/30302_React_过渡动画与CSS样式/","2024/01/23/Web前端开发/303_React/30301_React核心基础/","2024/01/23/Web前端开发/302_Vue3/30207_Vue3_Vue3原理/","2024/01/23/Web前端开发/302_Vue3/30206_Vue3_过渡与动画/","2024/01/23/Web前端开发/302_Vue3/30205_Vue3_自定义指令与插件/","2024/01/23/Web前端开发/302_Vue3/30204_Vue3_Pinia/","2024/01/23/Web前端开发/302_Vue3/30203_Vue3_VueX/","2024/01/23/Web前端开发/302_Vue3/30202_Vue3_Router/","2024/01/23/Web前端开发/302_Vue3/30201_Vue3_基础核心/","2024/01/23/Web前端开发/301_Vue2/30103_Vue2_VueX/","2024/01/23/Web前端开发/301_Vue2/30102_Vue2_VueRouter/","2024/01/23/Web前端开发/301_Vue2/30101_Vue2_Vue2Base/","2024/01/23/Web前端开发/206_模块化/20601_ModuleJS/","2024/01/22/Web前端开发/205_Git/20501_Git/","2024/01/21/Web前端开发/204_Fetch/20401_Fetch/","2024/01/20/Web前端开发/203_Axios/20301_Axios/","2024/01/19/Web前端开发/106_JavaScript高级/10509_JS代码的执行原理/","2024/01/19/Web前端开发/202_Promise/20201_Promise/","2024/01/18/Web前端开发/106_JavaScript高级/10508_浏览器执行过程原理/","2024/01/18/Web前端开发/201_Ajax/20101_Ajax/","2024/01/17/Web前端开发/106_JavaScript高级/10507_JS_ES6-ES13/","2024/01/16/Web前端开发/105_JavaScript/10506_JS_BOM/","2024/01/15/Web前端开发/105_JavaScript/10505_JS_DOM/","2024/01/14/Web前端开发/105_JavaScript/10504_JS_Function/","2024/01/13/Web前端开发/105_JavaScript/10503_JS_Object/","2024/01/12/Web前端开发/105_JavaScript/10502_JS_Array/","2024/01/11/Web前端开发/105_JavaScript/10501_JavaScript_Base/","2024/01/10/软件测试/软件测试test/","2024/01/10/Web前端开发/104_Less/10401_Less/","2024/01/09/Web前端开发/103_移动端开发/10304_Flex/","2024/01/08/Web前端开发/103_移动端开发/10303_Rem/","2024/01/07/Web前端开发/103_移动端开发/10302_Percent/","2024/01/06/Web前端开发/103_移动端开发/10301_WebMobileBase/","2024/01/05/Web前端开发/102_HTML5_CSS3/10202_CSS3/","2024/01/04/Web前端开发/102_HTML5_CSS3/10201_HTML5/","2024/01/03/Web前端开发/101_HTML_CSS/10103_CSS/","2024/01/02/Web前端开发/101_HTML_CSS/10102_HTML/","2024/01/01/Web前端开发/101_HTML_CSS/10101_WebBase/"];function toRandomPost(){ pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]); };</script>