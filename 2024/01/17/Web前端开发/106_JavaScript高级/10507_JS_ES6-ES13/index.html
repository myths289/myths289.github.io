<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>JavaScript_ES6-ES13 | 蜗牛浪迹天涯</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg"><!-- index.css--><link rel="stylesheet" href="/css/index.css"><!-- inject head--><link rel="stylesheet" href="https://cdn3.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><link rel="stylesheet" href="/lib/snackbar.min.css"><!-- comment--><!-- pace 胶囊加载条(Capsule loading bar)--><script src="https://cdn.bootcdn.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!-- search--><script src="https://cdn.bootcdn.net/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script><!-- aplayer--><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/Swiper/9.2.4/swiper-bundle.min.css"><!-- echarts--><script src="https://cdn.bootcdn.net/ajax/libs/echarts/5.4.2/echarts.min.js"></script><!-- 灰色纪念日(Gray Anniversary)--><!-- Open Graph--><meta name="description" content="# ES6-ES13 ECMA新描述概念ECMA新描述概念 在执行学习JavaScript代码执行过程中，我们学习了很多ECMA文档的术语： 执行上下文栈：Execution Context Stack，用于执行上下文的栈结构； 执行上下文：Execution Context，代码在执行之前会"><!-- pwa--><script>(win => {
        win.saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay,
                }
                localStorage.setItem(key, JSON.stringify(item))
            },

            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)

                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()

                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        }

        const DarkModeStatus = localStorage.getItem('theme')
        if (DarkModeStatus !== null) {
            if (DarkModeStatus === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark')
            } else {
                document.documentElement.setAttribute('data-theme', 'light')
            }
        }

        const asideStatus = saveToLocal.get('aside-status')
        if (asideStatus !== undefined) {
            if (asideStatus === 'hide') {
                document.documentElement.classList.add('hide-aside')
            } else {
                document.documentElement.classList.remove('hide-aside')
            }
        }
    }
)(window)

console.log(
    "%c🔥 程序：Hexo | 主题：Hexo-Theme-Solitude | 作者：王卓Sco、亦封 | Github: https://github.com/DuoSco/Hexo-theme-solitude | 版本：v1.3.0 😄",
    "color: #fff; background: linear-gradient(-25deg, #a8edea, #fed6e3); padding: 8px 15px; border-radius: 8px; text-shadow: 2px 2px 4px white; color: black;"
);
</script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script></div><!-- custom inject--><script>console.log("head")</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":true,"path":"/search.xml"},
    runtime: '2024-01-01 00:00:00',
    lazyload: {
        enable: true,
        error: '/img/error_load.png'
    },
    hightlight: {
        enable: true,
        limit: 200,
        expand: false,
        copy: true,
    },
    lightbox: true,
    randomlinks: false,
    lang: {
        theme: {
            dark: '已切换至深色模式',
            light: '已切换至浅色模式',
        },
        copy: {
            success: '复制成功',
            error: '复制失败',
        },
        backtop: '返回顶部',
        time: {
            recent: '最近',
            yesterday: '昨天',
            berforeyesterday: '前天',
            daybefore: '天前',
            runtime: '天',
        },
        sayhello: {
            morning: `一日之计在于晨`,
            noon: `吃饱了才有力气干活`,
            afternoon: `集中精力，攻克难关`,
            night: `不要太劳累了，早睡更健康`,
            goodnight: `睡个好觉，保证精力充沛`,
        },
        search: {
            empty: '找不到你查询的内容：${query}',
            hit: '找到 ${hits} 条结果，用时 ${time} 毫秒',
            placeholder: '输入关键词快速查找',
        }
    },
    covercolor: {
        enable: true
    },
    comment: {
        enable: false,
        type: 'twikoo',
        commentBarrage: false,
        randomInfoStart: ["聪敏的","可爱的","美丽的"],
        randomInfoEnd: ["白菜","小可爱","小仙女"],
        twikoo: {
            url: '',
            accessToken: ''
        },
        waline: {
            url: '',
        }
    },
    rightside: {
        enable: false
    },
    ai:{
        enable: false,
        key: '',
        talk: '我是王卓Sco开发的摘要生成助理ScoGPT，ScoGPT在静态部署时进行摘要的撰写，并且在访客访问时通过ScoCorrection转译后的文本摘要实现工具。我在这里只负责已经生成的摘要显示，你无法与我直接沟通，但我可以回答一些预设的问题。',
        randomPost: false,
    },
    music:{
        enable: true,
    }
}</script><meta name="generator" content="Hexo 6.3.0"></head><body id="body"><!-- loading--><div id="loading-box" onclick="preloader.endLoading();" style="zoom:1"><div class="loading-bg"><img class="loading-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="loading image"></div></div><script>const preloader = {
    endLoading: () => {
        document.getElementById('loading-box').classList.add('loaded');
    },
    initLoading: () => {
        document.getElementById('loading-box').classList.remove('loaded');
    },
    removePaceDone: () => {
        document.getElementById('body').classList = 'pace-done';
    }
}
window.addEventListener('load', () => {
    preloader.endLoading();
});
window.addEventListener('pjax:send', () => {
    preloader.initLoading();
});
document.addEventListener('pjax:complete', () => {
    preloader.endLoading();
});</script><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="scoicon sco-close-fill"></i></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><div class="author-content-item-title">最新评论</div></div><div class="aside-list"></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><div class="author-content-item-title">寻找感兴趣的领域</div></div><div class="card-tag-cloud"></div></div><div class="console-card history" onclick="sco.hideConsole()"><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" onclick="pjax.loadUrl('/archives/2024/')" href="javascript:void(0);"><span class="card-archive-list-date">2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">48</span><span class="card-archive-list-count-unit">篇</span></div></a></li></ul></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换" href="javascript:void(0);"><i class="scoicon sco-moon-clear-fill"></i></a></div><div class="console-btn-item" id="consoleHideAside"><a class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制" href="javascript:void(0);"><i class="scoicon sco-side-bar-fill"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="sco.musicToggle()"><a class="music-switch" title="音乐开关" href="javascript:void(0);"><i class="scoicon sco-disc-fill"></i></a></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()" href="javascript:void(0);"><i class="scoicon sco-moon-clear-fill"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/DuoSco/Hexo-Theme-solitude" title="Solitude"><img class="back-menu-item-icon" src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="项目"><span class="back-menu-item-text">Solitude</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="scoicon sco-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="scoicon sco-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="scoicon sco-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/moments/"><i class="scoicon sco-wifi-fill"></i><span>鱼塘</span></a></li><li><a class="site-page child" href="/links/"><i class="scoicon sco-group-fill"></i><span>友情链接</span></a></li><li><a class="site-page child" href="javascript:travelling()"><i class="scoicon sco-gift-fill"></i><span>宝藏博主</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/equipment/"><i class="scoicon sco-laptop-line"></i><span>装备</span></a></li><li><a class="site-page child" href="/tlink/"><i class="scoicon sco-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="scoicon sco-laptop-line"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="scoicon sco-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon scoicon sco-more-fill"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/DuoSco/Hexo-Theme-solitude" title="Solitude"><img class="back-menu-item-icon" src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="项目"><span class="back-menu-item-text">Solitude</span></a></div></div></div></div><a id="site-name" href="/" title="返回博客主页" target="_self"><span class="scoicon">首页</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">JavaScript_ES6-ES13</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="scoicon sco-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="scoicon sco-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="scoicon sco-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/moments/"><i class="scoicon sco-wifi-fill"></i><span>鱼塘</span></a></li><li><a class="site-page child" href="/links/"><i class="scoicon sco-group-fill"></i><span>友情链接</span></a></li><li><a class="site-page child" href="javascript:travelling()"><i class="scoicon sco-gift-fill"></i><span>宝藏博主</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/equipment/"><i class="scoicon sco-laptop-line"></i><span>装备</span></a></li><li><a class="site-page child" href="/tlink/"><i class="scoicon sco-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/music/"><i class="scoicon sco-laptop-line"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="scoicon sco-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button"><a class="site-page" href="https://www.travellings.cn/go.html" title="开往-友链接力" target="_blank"><i class="scoicon sco-train-line"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机一篇文章" href="javascript:void(0);"><i class="scoicon sco-signal-tower-fill"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="scoicon sco-search-line"></i></a></div><div class="nav-button" id="nav-console"><a class="console_switchbutton" onclick="sco.showConsole()" title="中控台" href="javascript:void(0);"><i class="scoicon sco-dashboard-fill"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="scoicon sco-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="scoicon sco-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://img1.baidu.com/it/u=2070775777,1738145051&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" alt="JavaScript_ES6-ES13"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/Web前端开发/">Web前端开发</a></span><div class="tag_share"><div class="post-meta__tag-list"></div></div></div></div><h1 class="post-title">JavaScript_ES6-ES13</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="meta_posted 2024-01-17 00:00:00"><i class="post-meta-icon scoicon sco-calendar-todo-fill"></i><time datetime="2024-01-16T16:00:00.000Z">2024-01-16T16:00:00.000Z</time></span><span class="post-meta-date" title="meta_updated 2024-01-27 23:00:09"><i class="post-meta-icon scoicon sco-refresh-line"></i><time datetime="2024-01-27T15:00:09.166Z">2024-01-27T15:00:09.166Z</time></span><span class="post-meta-wordcount"><i class="post-meta-icon scoicon sco-word-fill" title="文章字数"></i><span class="word-count">19.9k</span><span class="post-meta-separator"></span><i class="post-meta-icon scoicon sco-clock-fill" title="阅读耗时"></i><span>77 min</span></span><span class="post-meta-position" title="作者IP归属地为衡阳"><i class="post-meta-icon scoicon sco-map-pin-fill"></i><span>衡阳</span></span><a class="post-meta-pv" href="/2024/01/17/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/106_JavaScript%E9%AB%98%E7%BA%A7/10507_JS_ES6-ES13/" title="文章热度"><i class="post-meta-icon scoicon sco-fire-fill"></i><span id="busuanzi_value_page_pv"><i class="scoicon sco-loading-line"></i></span></a></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />
# ES6-ES13

<h2 id="ECMA新描述概念"><a href="#ECMA新描述概念" class="headerlink" title="ECMA新描述概念"></a>ECMA新描述概念</h2><h3 id="ECMA新描述概念-1"><a href="#ECMA新描述概念-1" class="headerlink" title="ECMA新描述概念"></a>ECMA新描述概念</h3><ul>
<li><p>在执行学习JavaScript代码执行过程中，我们学习了很多ECMA文档的术语：</p>
<ul>
<li><strong>执行上下文栈</strong>：Execution Context Stack，用于执行上下文的栈结构；</li>
<li><strong>执行上下文</strong>：Execution Context，代码在执行之前会先创建对应的执行上下文；</li>
<li><strong>变量对象</strong>：Variable Object，上下文关联的VO对象，用于记录函数和变量声明；</li>
<li><strong>全局对象</strong>：Global Object，全局执行上下文关联的VO对象；</li>
<li><strong>激活对象</strong>：Activation Object，函数执行上下文关联的VO对象；</li>
<li><strong>作用域链</strong>：scope chain，作用域链，用于关联指向上下文的变量查找；</li>
</ul>
</li>
<li><p>在新的ECMA 代码执行描述中（ES5以及之上），对于代码的执行流程描述改成了另外的一些词汇：</p>
<ul>
<li>基本思路是相同的，只是对于一些词汇的描述发生了改变；</li>
<li>执行上下文栈和执行上下文也是相同的；</li>
</ul>
</li>
</ul>
<h3 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h3><ul>
<li>词法环境是一种规范类型，用于在词法嵌套结构中定义关联的变量、函数等标识符；<ul>
<li>一个词法环境是由环境记录（Environment Record）和一个外部词法环境（oute;r Lexical Environment）组成；</li>
<li>一个词法环境经常用于关联一个函数声明、代码块语句、try-catch语句，当它们的代码被执行时，词法环境被创建出来；</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/cdfd81c5a7904af28b9e13e9327473fc" alt="1674715027356"></p>
<ul>
<li>也就是在ES5之后，执行一个代码，通常会关联对应的词法环境；<ul>
<li>那么执行上下文会关联哪些词法环境呢？</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/d403060c249d4a85a6686a726e1fd4a5" alt="1674715053861"></p>
<ul>
<li>LexicalEnvironment用于处理let、const声明的标识符：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/e54174478fde45a0acecff113176079d" alt="1674715087198"></p>
<ul>
<li>VariableEnvironment用于处理var和function声明的标识符：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/4fe55c3557864fb6bea5431b69066cc8" alt="1674715092632"></p>
<h3 id="环境记录"><a href="#环境记录" class="headerlink" title="环境记录"></a>环境记录</h3><ul>
<li>在这个规范中有两种主要的环境记录值:声明式环境记录和对象环境记录。<ul>
<li>声明式环境记录：声明性环境记录用于定义ECMAScript语言语法元素的效果，如函数声明、变量声明和直接将标识符绑定与ECMAScript语言值关联起来的Catch子句。</li>
<li>对象式环境记录：对象环境记录用于定义ECMAScript元素的效果，例如WithStatement，它将标识符绑定与某些对象的属性关联起来。</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/683a0713f14f429b984990ec900b9c64" alt="1674715125454"></p>
<ul>
<li>新ECMA描述内存图</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/ba7b9a53fd7643f99102898614495e0b" alt="1674715163644"></p>
<h2 id="let-const的使用"><a href="#let-const的使用" class="headerlink" title="let&#x2F;const的使用"></a>let&#x2F;const的使用</h2><h3 id="let-const的使用-1"><a href="#let-const的使用-1" class="headerlink" title="let&#x2F;const的使用"></a>let&#x2F;const的使用</h3><ul>
<li><p>在 ES5 中我们声明变量都是使用的 var关键字，从ES6开始新增了两个关键字可以声明变量：let、const</p>
<ul>
<li>let、const 在其他编程语言中都是有的，所以也并不是新鲜的关键字；</li>
<li>但是 let、const 确确实实给 JavaScript 带来一些不一样的东西；</li>
</ul>
</li>
<li><p>let 关键字：</p>
<ul>
<li>从直观的角度来说，let 和 var 是没有太大的区别的，都是用于声明一个变量；</li>
</ul>
</li>
<li><p>const 关键字：</p>
<ul>
<li>const 关键字是 constant 的单词的缩写，表示常量、衡量的意思；</li>
<li>它表示保存的数据一旦被赋值，就不能被修改；</li>
<li>但是如果赋值的是引用类型，那么可以通过引用找到对应的对象，修改对象的内容；</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>另外 let、const 不允许重复声明变量,否则会报错</li>
<li>var 声明过的变量也不能再通过 let &#x2F; const 再次声明,否则会报错</li>
</ul>
</li>
</ul>
<h3 id="let-const无作用域提升"><a href="#let-const无作用域提升" class="headerlink" title="let&#x2F;const无作用域提升"></a>let&#x2F;const无作用域提升</h3><ul>
<li>let、const 和 var 的另一个重要区别是作用域提升：<ul>
<li>我们知道 var 声明的变量是会进行作用域提升的；</li>
<li>但是如果我们使用 let 声明的变量，在声明之前访问会报错；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo) <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>那么是不是意味着foo变量只有在代码执行阶段才会创建的呢？<ul>
<li>事实上并不是这样的，我们可以看一下 ECMA262 对 let 和 const 的描述；</li>
<li>这些变量会被创建在包含他们的词法环境被实例化时，但是是不可以访问它们的，直到词法绑定被求值；</li>
</ul>
</li>
<li>从上面我们可以看出，在执行上下文的词法环境创建出来的时候，<strong>变量事实上已经被创建了，只是这个变量是不能被访问</strong>的。</li>
<li>那么变量已经有了，但是不能被访问，是不是一种作用域的提升呢？<ul>
<li>事实上维基百科并没有对作用域提升有严格的概念解释，那么我们自己从字面量上理解；<ul>
<li><strong>作用域提升：在声明变量的作用域中，如果这个变量可以在声明之前被访问，那么我们可以称之为作用域提升；</strong></li>
<li>在这里，它虽然被创建出来了，但是不能被访问，我认为不能称之为作用域提升；</li>
</ul>
</li>
<li>所以我的观点是 <strong>let、const 没有进行作用域提升，但是会在解析阶段被创建出来</strong>。</li>
</ul>
</li>
</ul>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><ul>
<li>我们知道，在let、const定义的标识符真正执行到声明的代码之前，是不能被访问的<ul>
<li>从块作用域的顶部一直到变量声明完成之前，这个变量处在暂时性死区（TDZ，temporal dead zone）</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">	<span class="keyword">let</span> name = <span class="string">&quot;why&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用术语 “temporal” 是因为区域取决于执行顺序（时间），而不是编写代码的位置；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<h3 id="window对象添加属性"><a href="#window对象添加属性" class="headerlink" title="window对象添加属性"></a>window对象添加属性</h3><ul>
<li><p>我们知道，在全局通过 var 来声明一个变量，事实上会在 window 上添加一个属性：</p>
</li>
<li><p>但是 let、const 是不会给 window 上添加任何属性的。</p>
</li>
<li><p>那么我们可能会想这个变量是保存在哪里呢？</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/3ae09183701e4358904d45161d63038c" alt="1674715256606"></p>
<h3 id="var-的作用域"><a href="#var-的作用域" class="headerlink" title="var 的作用域"></a>var 的作用域</h3><ul>
<li>在我们前面的学习中，JavaScript只会形成两个作用域：<strong>全局作用域和函数作用域</strong>。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/28b0e492f8e448a29a8a48442aaaa4da" alt="1674715309954"></p>
<ul>
<li>ES5中放到一个代码中定义的变量，外面是可以访问的：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/5178084a46584889811f09ce817c54a7" alt="1674715335028"></p>
<h3 id="let-const的块级作用域"><a href="#let-const的块级作用域" class="headerlink" title="let&#x2F;const的块级作用域"></a>let&#x2F;const的块级作用域</h3><ul>
<li>在ES6中新增了块级作用域，并且通过let、const、function、class声明的标识符是具备块级作用域的限制的：<ul>
<li>使用 let 和 const 声明的变量是有块级作用域的</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&quot;foo&quot;</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Person</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(foo) // 报错: Uncaught ReferenceError: foo is not defined</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// let p = new Person; // 报错: Uncaught ReferenceError: Person is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>但是我们会发现函数拥有块级作用域，但是外面依然是可以访问的：<ul>
<li>这是因为引擎会对函数的声明进行特殊的处理，允许像 var 那样进行提升；</li>
</ul>
</li>
</ul>
<h3 id="块级作用域的应用"><a href="#块级作用域的应用" class="headerlink" title="块级作用域的应用"></a>块级作用域的应用</h3><ul>
<li>点击按钮,输出不同的索引值:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btnEl = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;button&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; btnEl.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    btnEl[i].<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="var-let-const的选择"><a href="#var-let-const的选择" class="headerlink" title="var&#x2F;let&#x2F;const的选择"></a>var&#x2F;let&#x2F;const的选择</h3><ul>
<li>那么在开发中，我们到底应该选择使用哪一种方式来定义我们的变量呢？</li>
<li>对于var的使用：<ul>
<li>我们需要明白一个事实，var所表现出来的特殊性：比如作用域提升、window全局对象、没有块级作用域等都是一些历史遗留问题；</li>
<li>其实是JavaScript在设计之初的一种语言缺陷；</li>
<li>当然目前市场上也在利用这种缺陷出一系列的面试题，来考察大家对JavaScript语言本身以及底层的理解；</li>
<li>但是在实际工作中，我们可以使用最新的规范来编写，也就是<strong>不再使用var来定义变量</strong>了；</li>
</ul>
</li>
<li>对于let、const：<ul>
<li><strong>对于let和const来说，是目前开发中推荐使用的；</strong></li>
<li>我们会优先推荐使用const，这样可以保证数据的安全性不会被随意的篡改；</li>
<li>只有当我们明确知道一个变量后续会需要被重新赋值时，这个时候再使用let；</li>
<li>这种在很多其他语言里面也都是一种约定俗成的规范，尽量我们也遵守这种规范；</li>
</ul>
</li>
</ul>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><ul>
<li>在ES6之前，如果我们想要将字符串和一些动态的变量（标识符）拼接到一起，是非常麻烦和丑陋的（ugly）。</li>
<li>ES6允许我们使用字符串模板来嵌入JS的变量或者表达式来进行拼接：<ul>
<li>首先，我们会使用 &#96;&#96; 符号来编写字符串，称之为模板字符串；</li>
<li>其次，在模板字符串中，我们可以通过 ${expression} 来嵌入动态的内容；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1.ES6之前</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;why&quot;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">&quot;my name is&quot;</span> + name + <span class="string">&quot;, age is &quot;</span> + age</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info); <span class="comment">// my name iswhy, age is 18</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.2.ES6之后</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;why&quot;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, age is <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info) <span class="comment">// my name is why, age is 18</span></span><br></pre></td></tr></table></figure>

<h3 id="标签模板字符串使用"><a href="#标签模板字符串使用" class="headerlink" title="标签模板字符串使用"></a>标签模板字符串使用</h3><ul>
<li>模板字符串还有另外一种用法：标签模板字符串（Tagged Template Literals）。</li>
<li>我们一起来看一个普通的JavaScript的函数：</li>
<li>如果我们使用标签模板字符串，并且在调用的时候插入其他的变量：<ul>
<li>模板字符串被拆分了；</li>
<li>第一个元素是数组，是被模块字符串拆分的字符串组合；</li>
<li>后面的元素是一个个模块字符串传入的内容；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.标签模板字符串的用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;参数:&quot;</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;why&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>) <span class="comment">//  [&#x27;why&#x27;, 18, 1.88]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;why&quot;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line">foo <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, age is <span class="subst">$&#123;age&#125;</span>, height is <span class="subst">$&#123;<span class="number">1.88</span>&#125;</span>`</span> <span class="comment">//  [Array(4), &#x27;why&#x27;, 18, 1.88]  // 也是函数调用的一种方式</span></span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="箭头函数简介"><a href="#箭头函数简介" class="headerlink" title="箭头函数简介"></a>箭头函数简介</h3><ul>
<li>箭头函数是 ES6 之后增加的一种编写函数的方法，并且它比函数表达式要更加简洁：</li>
<li>箭头函数 不会绑定 this 、arguments 属性</li>
<li>箭头函数 不能作为构造函数来使用 （不能和 new 一起来使用，会抛出错误）；</li>
</ul>
<h3 id="箭头函数的格式"><a href="#箭头函数的格式" class="headerlink" title="箭头函数的格式"></a>箭头函数的格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.之前声明函数的方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo2 = <span class="keyword">function</span> (<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数体代码&#x27;</span>, <span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.箭头函数完整写法</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">foo3</span> = (<span class="params">name, age</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;箭头函数的函数体&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo3</span>(<span class="string">&#x27;why&#x27;</span>, <span class="number">18</span>) <span class="comment">// 函数调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.箭头函数的练习</span></span><br><span class="line"><span class="comment">// 3.1. forEach , forEach的三个参数依次分别为:每次遍历的数组元素,数组索引,被遍历的数组</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>, <span class="string">&#x27;nba&#x27;</span>]</span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item, index, arr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2. setTimeout</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数的简写"><a href="#箭头函数的简写" class="headerlink" title="箭头函数的简写"></a>箭头函数的简写</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>, <span class="string">&#x27;nba&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">20</span>, <span class="number">30</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">111</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.优化一: 如果箭头函数只有一个参数, 那么()可以省略</span></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// abc cba nba</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> newNums = nums.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNums) <span class="comment">// [20, 30]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>, <span class="string">&#x27;nba&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">20</span>, <span class="number">30</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">111</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.优化二: 如果函数体中只有一行执行代码, 那么&#123;&#125;可以省略,并且这行代码的返回值会作为整个函数的返回值</span></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item))</span><br><span class="line"><span class="comment">// 一行代码中不能带return关键字, 如果省略, 需要带return一起省略</span></span><br><span class="line"><span class="keyword">var</span> newNums = nums.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNums) <span class="comment">// [20, 30]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.优化三: 只有一行代码时, 这行代码的表达式结果会作为函数的返回值默认返回的</span></span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">20</span>, <span class="number">30</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">111</span>]</span><br><span class="line"><span class="keyword">var</span> newNums = nums.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;newNums:&#x27;</span>, newNums) <span class="comment">// newNums: [20, 30]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.优化四: 如果默认返回值是一个对象, 那么这个对象必须加()</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">arrFn</span> = (<span class="params"></span>) =&gt; [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>] <span class="comment">// [&#x27;abc&#x27;, &#x27;cba&#x27;] 将会作为返回值</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">arrFn</span> = (<span class="params"></span>) =&gt; &#123;&#125; <span class="comment">// 注意: 这里是&#123;&#125;执行体</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">arrFn</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span> &#125;) <span class="comment">// &#123;name: &#x27;why&#x27;&#125; ,要返回一个对象,必须加小括号才能作为返回值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrFn</span>())</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数实现nums的所有偶数平方的和</span></span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">20</span>, <span class="number">30</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">111</span>]</span><br><span class="line"><span class="keyword">var</span> result = nums</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item * item)</span><br><span class="line">  .<span class="title function_">reduce</span>(<span class="function">(<span class="params">prevValue, item</span>) =&gt;</span> prevValue + item)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// 1300</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数的-this-指向"><a href="#箭头函数的-this-指向" class="headerlink" title="箭头函数的 this 指向"></a>箭头函数的 this 指向</h3><ul>
<li>箭头函数根据外层作用域来决定 this 的指向</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 普通函数中是有this的标识符</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// window</span></span><br><span class="line">foo.<span class="title function_">apply</span>(<span class="string">&#x27;aaa&#x27;</span>) <span class="comment">// String &#123;&#x27;aaa&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.箭头函数中, 压根没有this</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar:&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// window</span></span><br><span class="line">bar.<span class="title function_">apply</span>(<span class="string">&#x27;aaaa&#x27;</span>) <span class="comment">// window , 通过apply调用时, 也是没有this</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;全局this:&#x27;</span>, <span class="variable language_">this</span>) <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.this的查找规则</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar222:&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = obj.<span class="title function_">foo</span>()</span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="string">&#x27;bbb&#x27;</span>) <span class="comment">// window ,如果 foo 是一个普通函数,this 就是指向 obj 对象</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数中-this-的应用"><a href="#箭头函数中-this-的应用" class="headerlink" title="箭头函数中 this 的应用"></a>箭头函数中 this 的应用</h3><ul>
<li>案例一:调用 obj 对象中的一个方法发起网络请求获取数据,并存放在 obj 的 name 属性中</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络请求的工具函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url, callbackFn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> results = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>, <span class="string">&#x27;nba&#x27;</span>]</span><br><span class="line">  <span class="title function_">callbackFn</span>(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际操作的位置(业务)</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">names</span>: [],</span><br><span class="line">  <span class="attr">network</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 普通方法中的this指向 obj 对象</span></span><br><span class="line">    <span class="comment">// 1.早期的时候</span></span><br><span class="line">    <span class="comment">// var _this = this</span></span><br><span class="line">    <span class="comment">// request(&quot;/names&quot;, function(res) &#123;</span></span><br><span class="line">    <span class="comment">//   _this.names = [].concat(res)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.箭头函数写法</span></span><br><span class="line">    <span class="title function_">request</span>(<span class="string">&#x27;/names&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">names</span> = [].<span class="title function_">concat</span>(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">network</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br></pre></td></tr></table></figure>

<ul>
<li>案例二:定时器中的 this 的使用<ul>
<li>调用 obj 对象中的一个方法发起网络请求获取数据,并存放在 obj 的 name 属性中</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">data</span>: [],</span><br><span class="line">  <span class="attr">getData</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> res = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>, <span class="string">&#x27;nba&#x27;</span>]</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(...res)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// this 的指向为 obj2 对象</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj2.<span class="title function_">getData</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2)</span><br></pre></td></tr></table></figure>

<h3 id="常见-this-指向的面试题"><a href="#常见-this-指向的面试题" class="headerlink" title="常见 this 指向的面试题"></a>常见 this 指向的面试题</h3><h4 id="面试题一"><a href="#面试题一" class="headerlink" title="面试题一"></a>面试题一</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.<span class="property">sayName</span></span><br><span class="line">  <span class="title function_">sss</span>() <span class="comment">// 绑定: 默认绑定, window -&gt; window</span></span><br><span class="line">  person.<span class="title function_">sayName</span>() <span class="comment">// 绑定: 隐式绑定, person -&gt; person</span></span><br><span class="line">  person.<span class="title function_">sayName</span>() <span class="comment">// 绑定: 隐式绑定, person -&gt; person</span></span><br><span class="line">  ;(b = person.<span class="property">sayName</span>)() <span class="comment">// 术语: 间接函数引用, window -&gt; window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayName</span>()</span><br></pre></td></tr></table></figure>

<h4 id="面试题二"><a href="#面试题二" class="headerlink" title="面试题二"></a>面试题二</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo2</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line">  <span class="attr">foo3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo4</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;person2&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始题目:</span></span><br><span class="line">person1.<span class="title function_">foo1</span>() <span class="comment">// 隐式绑定: person1</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2) <span class="comment">// 显式绑定: person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo2</span>() <span class="comment">// 上层作用域: window</span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2) <span class="comment">// 上层作用域: window</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo3</span>()() <span class="comment">// 默认绑定: window</span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)() <span class="comment">// 默认绑定: window</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2) <span class="comment">// 显式绑定: person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo4</span>()() <span class="comment">// person1</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)() <span class="comment">// person2</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2) <span class="comment">// person1</span></span><br></pre></td></tr></table></figure>

<h4 id="面试题三"><a href="#面试题三" class="headerlink" title="面试题三"></a>面试题三</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.创建一个空的对象</span></span><br><span class="line"><span class="comment">  2.将这个空的对象赋值给this</span></span><br><span class="line"><span class="comment">  3.执行函数体中代码</span></span><br><span class="line"><span class="comment">  4.将这个新的对象默认返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  ;(<span class="variable language_">this</span>.<span class="property">foo1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">    (<span class="variable language_">this</span>.<span class="property">foo2</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)),</span><br><span class="line">    (<span class="variable language_">this</span>.<span class="property">foo3</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    (<span class="variable language_">this</span>.<span class="property">foo4</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person1/person2都是对象(实例instance)</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面试题目:</span></span><br><span class="line">person1.<span class="title function_">foo1</span>() <span class="comment">// 隐式绑定: person1</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2) <span class="comment">// 显式绑定: person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo2</span>() <span class="comment">// 上层作用域查找: person1</span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2) <span class="comment">// 上层作用域查找: person1</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo3</span>()() <span class="comment">// 默认绑定: window</span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)() <span class="comment">// 默认绑定: window</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2) <span class="comment">// 显式绑定: person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo4</span>()() <span class="comment">// 上层作用域查找: person1(隐式绑定)</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)() <span class="comment">//  上层作用域查找: person2(显式绑定)</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2) <span class="comment">// 上层作用域查找: person1(隐式绑定)</span></span><br></pre></td></tr></table></figure>

<h4 id="面试题四"><a href="#面试题四" class="headerlink" title="面试题四"></a>面试题四</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">foo2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>()() <span class="comment">// 默认绑定: window</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo1</span>.<span class="title function_">call</span>(person2)() <span class="comment">// 默认绑定: window</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>().<span class="title function_">call</span>(person2) <span class="comment">// 显式绑定: person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>()() <span class="comment">// 上层作用域查找: obj(隐式绑定)</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo2</span>.<span class="title function_">call</span>(person2)() <span class="comment">// 上层作用域查找: person2(显式绑定)</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>().<span class="title function_">call</span>(person2) <span class="comment">// 上层作用域查找: obj(隐式绑定)</span></span><br></pre></td></tr></table></figure>

<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul>
<li><p>在ES6之前，我们编写的函数参数是没有默认值的，所以我们在编写函数时，如果有下面的需求：</p>
<ul>
<li>传入了参数，那么使用传入的参数；</li>
<li>没有传入参数，那么使用一个默认值；</li>
<li>而在ES6中，我们允许给函数一个默认值：</li>
</ul>
</li>
<li><p>不严谨的默认值写法:</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.1 这种写法不严谨, 像 0 , &quot;&quot; , false , null , undefined 等值会被判为 false ,得到默认值,而不是传递的参数</span></span><br><span class="line">  <span class="comment">// 默认值写法一:</span></span><br><span class="line">  arg1 =  arg1 ? arg1 : <span class="string">&quot;我是默认值&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">123</span>, <span class="number">321</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 我是默认值</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>) <span class="comment">// 我是默认值</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// 我是默认值</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">false</span>) <span class="comment">// 我是默认值</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">null</span>) <span class="comment">// 我是默认值</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">undefined</span>) <span class="comment">// 我是默认值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.2 这种写法不严谨, 像 0 , &quot;&quot; , false , null , undefined 等值会得到默认值,而不是传递的参数</span></span><br><span class="line">  <span class="comment">// 默认值写法二:</span></span><br><span class="line">  arg1 = arg1 || <span class="string">&quot;我是默认值&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">123</span>, <span class="number">321</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 我是默认值</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>) <span class="comment">// 我是默认值</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// 我是默认值</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">false</span>) <span class="comment">// 我是默认值</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">null</span>) <span class="comment">// 我是默认值</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">undefined</span>) <span class="comment">// 我是默认值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>严谨的写法:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1</span>) &#123;</span><br><span class="line">  <span class="comment">// 2.1 严谨的写法</span></span><br><span class="line">  <span class="comment">// 三元运算符</span></span><br><span class="line">  arg1 = (arg1 === <span class="literal">undefined</span> || arg1 === <span class="literal">null</span>) ? <span class="string">&quot;我是默认值&quot;</span> : arg1</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">123</span>, <span class="number">321</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 我是默认值           </span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// &quot;&quot; 空字符串</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">false</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">null</span>) <span class="comment">// 我是默认值       </span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">undefined</span>) <span class="comment">// 我是默认值 </span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.2 ES6之后新增语法: ??</span></span><br><span class="line">    arg1 = arg1 ?? <span class="string">&quot;我是默认值&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg1)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="number">123</span>, <span class="number">321</span>) <span class="comment">// 123</span></span><br><span class="line">  <span class="title function_">foo</span>() <span class="comment">// 我是默认值           // 不传参就会使用默认值</span></span><br><span class="line">  <span class="title function_">foo</span>(<span class="number">0</span>) <span class="comment">// 0                  </span></span><br><span class="line">  <span class="title function_">foo</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// &quot;&quot; 空字符串</span></span><br><span class="line">  <span class="title function_">foo</span>(<span class="literal">false</span>) <span class="comment">// false</span></span><br><span class="line">  <span class="title function_">foo</span>(<span class="literal">null</span>) <span class="comment">// 我是默认值       // null 会被判为空</span></span><br><span class="line">  <span class="title function_">foo</span>(<span class="literal">undefined</span>) <span class="comment">// 我是默认值 // undefined 会被判为空</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1 = <span class="string">&quot;我是默认值&quot;</span>, arg2 = <span class="string">&quot;我也是默认值&quot;</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 3.简便的写法: 默认参数,在形参使用默认值, 注意: 默认参数是不会对null进行处理的</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">123</span>, <span class="number">321</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 我是默认值 , 没有传实参而使用默认值</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// &quot;&quot; 空字符串</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">false</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">null</span>) <span class="comment">// null</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">undefined</span>) <span class="comment">// 我是默认值 , undefined 会被判为没有传实参而使用默认值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认值也可以和解构一起来使用：</li>
<li>另外参数的默认值我们通常会将其放到最后（在很多语言中，如果不放到最后其实会报错的）：</li>
<li>但是JavaScript允许不将其放到最后，但是意味着还是会按照顺序来匹配；</li>
<li>另外默认值会改变函数的length的个数，默认值以及后面的参数都不计算在length之内了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.解构的回顾</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name = <span class="string">&quot;kobe&quot;</span>, age = <span class="number">18</span> &#125; = obj  <span class="comment">// 对对象解构的同时赋予默认值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age); <span class="comment">// why 18</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.1 函数的默认值是一个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">obj = &#123; name: <span class="string">&quot;why&quot;</span>, age: <span class="number">18</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>, obj.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// why 18  函数调用,不传参</span></span><br><span class="line"><span class="title function_">foo</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;qwe&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">height</span>: <span class="number">1.88</span> &#125;) <span class="comment">// qwe 20  函数调用,并传递实参</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.2 函数的默认值是一个对象,同时进行解构</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123; name, age &#125; = &#123; name: <span class="string">&quot;why&quot;</span>, age: <span class="number">18</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// why 18  函数调用,不传参</span></span><br><span class="line"><span class="title function_">foo</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;abc&quot;</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">height</span>: <span class="number">1.88</span> &#125;) <span class="comment">// abc 19  函数调用,并传递参数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.3 函数的默认值是一个空对象,同时进行解构</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123; name = <span class="string">&quot;why&quot;</span>, age = <span class="number">18</span> &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// why 18  函数调用,不传参</span></span><br><span class="line"><span class="title function_">foo</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;qwe&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">height</span>: <span class="number">1.88</span> &#125;) <span class="comment">// qwe 20  函数调用,并传递参数</span></span><br></pre></td></tr></table></figure>

<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><ul>
<li>ES6中引用了rest parameter，可以将不定数量的参数放入到一个数组中：<ul>
<li>如果最后一个参数是 … 为前缀的，那么它会将剩余的参数放到该参数中，并且作为一个数组；</li>
</ul>
</li>
<li>那么剩余参数和arguments有什么区别呢？<ul>
<li>剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参；</li>
<li>arguments对象不是一个真正的数组，而rest参数是一个真正的数组，可以进行数组的所有操作；</li>
<li>arguments是早期的ECMAScript中为了方便去获取所有的参数提供的一个数据结构，而rest参数是ES6中提供并且希望以此来替代arguments的；</li>
<li>注意：剩余参数必须放到最后一个位置，否则会报错。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.function定义的函数是有两个原型的:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// new foo() -&gt; f.__proto__ = foo.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">__proto__</span>) <span class="comment">// -&gt; Function.prototype</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.箭头函数是没有显式原型</span></span><br><span class="line"><span class="comment">// 在ES6之后, 定义一个类要使用class定义</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 没有显式原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// var b = new bar() // 报错 bar is not a constructor</span></span><br></pre></td></tr></table></figure>

<h2 id="展开语法"><a href="#展开语法" class="headerlink" title="展开语法"></a>展开语法</h2><h3 id="展开语法-1"><a href="#展开语法-1" class="headerlink" title="展开语法"></a>展开语法</h3><ul>
<li>展开语法(Spread syntax)：<ul>
<li>可以在函数调用&#x2F;数组构造时，将数组表达式或者string在语法层面展开；</li>
<li>还可以在构造字面量对象时, 将对象表达式按key-value的方式展开；</li>
</ul>
</li>
<li>展开语法的场景：<ul>
<li>在函数调用时使用；</li>
<li>在数组构造时使用；</li>
<li>在构建对象字面量时，也可以使用展开运算符，这个是在ES2018（ES9）中添加的新特性；</li>
</ul>
</li>
<li>注意：展开运算符其实是一种浅拷贝；</li>
</ul>
<h3 id="数组展开"><a href="#数组展开" class="headerlink" title="数组展开"></a>数组展开</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="comment">// 1.1 将一个数组展开</span></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>, <span class="string">&quot;mba&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">const</span> newNames = [...names, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNames) <span class="comment">//  [&#x27;abc&#x27;, &#x27;cba&#x27;, &#x27;nba&#x27;, &#x27;mba&#x27;, &#x27;aaa&#x27;, &#x27;bbb&#x27;]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.2 函数调用时,将数组或字符串展开作为实参使用</span></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>, <span class="string">&quot;mba&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">name1, name2, ...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name1, name2, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(...names) <span class="comment">// abc cba  [&#x27;nba&#x27;, &#x27;mba&#x27;]</span></span><br><span class="line"><span class="title function_">foo</span>(...str) <span class="comment">// H e [&#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="对象展开"><a href="#对象展开" class="headerlink" title="对象展开"></a>对象展开</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES9(ES2018)  在构建对象字面量时，也可以使用展开运算符，这个是在ES2018（ES9）中添加的新特性；</span></span><br><span class="line"><span class="comment">// 2.1 在一个函数调用时,对一个对象进行展开作为形参使用,会报错,不可以这样来使用</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">name1, name2, ...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name1, name2, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在函数的调用时, 用展开运算符, 将对应的展开数据, 进行迭代  可迭代对象: 数组/string/arguments</span></span><br><span class="line"><span class="title function_">foo</span>(...obj) <span class="comment">// 报错 Found non-callable @@iterator</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.2 在构建一个对象字面量时,可以将已有的对象展开作为另一个对象的属性和属性值</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  ...obj,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info) <span class="comment">// &#123;name: &#x27;why&#x27;, age: 18, height: 1.88, address: &#x27;广州市&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.引用赋值 , 赋值的是引用的内存地址</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">friend</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;curry&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> info1 = obj <span class="comment">// info1 和 obj 是同一个对象 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info1) <span class="comment">// &#123;name: &#x27;why&#x27;, age: 18, height: 1.88, friend: &#123;…&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.浅拷贝  </span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">friend</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;curry&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> info2 = &#123;</span><br><span class="line">  <span class="comment">// 展开运算符其实是一种浅拷贝；info2 对象会开辟新的内存空间,将 obj 对象的属性和属性值拷贝到 info2 中作为属性使用</span></span><br><span class="line">  <span class="comment">// 若原对象 obj 中还有对象,则拷贝的是引用的内存地址,,此时obj和info2对象的 firend 对象是同一个对象. (相当于赋值引用的内存地址)</span></span><br><span class="line">  ...obj,</span><br><span class="line">&#125;</span><br><span class="line">info2.<span class="property">name</span> = <span class="string">&quot;kobe&quot;</span> <span class="comment">// 修改 info2 的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info2.<span class="property">name</span>) <span class="comment">// kobe </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// why  原对象 obj 的属性并没有被更改 </span></span><br><span class="line">info2.<span class="property">friend</span>.<span class="property">name</span> = <span class="string">&quot;james&quot;</span> <span class="comment">// 修改 info2 对象中 friend 对象的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">friend</span>.<span class="property">name</span>) <span class="comment">// james 原对象 obj 的属性会被更改,因为拷贝时拷贝的是引用的内存地址 </span></span><br></pre></td></tr></table></figure>

<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.深拷贝</span></span><br><span class="line"><span class="comment">// 方式一: 第三方库</span></span><br><span class="line"><span class="comment">// 方式二: 自己实现</span></span><br><span class="line"><span class="comment">// function deepCopy(obj) &#123;&#125;</span></span><br><span class="line"><span class="comment">// 方式三: 利用先有的js机制, 实现深拷贝JSON</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">friend</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;curry&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> info3 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)) <span class="comment">// 将一个对象转为字符串型,再转回对象,可以实现深拷贝(在转回对象时就会开辟新的内存空间)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info3.<span class="property">friend</span>.<span class="property">name</span>) <span class="comment">// curry</span></span><br><span class="line">info3.<span class="property">friend</span>.<span class="property">name</span> = <span class="string">&quot;james&quot;</span> <span class="comment">// 修改新对象 info3 中的 friend 对象中的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info3.<span class="property">friend</span>.<span class="property">name</span>) <span class="comment">// james</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">friend</span>.<span class="property">name</span>) <span class="comment">// curry 相当于从obj拷贝出一新的对象,新旧两个对象之间互相不干扰</span></span><br></pre></td></tr></table></figure>

<h2 id="进制与数值的表示"><a href="#进制与数值的表示" class="headerlink" title="进制与数值的表示"></a>进制与数值的表示</h2><h3 id="进制的表示"><a href="#进制的表示" class="headerlink" title="进制的表示"></a>进制的表示</h3><p>在ES6中规范了二进制和八进制的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">100</span>) <span class="comment">// 100   十进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0b100</span>) <span class="comment">// 4   二进制, 0b开头</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0o100</span>) <span class="comment">// 64   八进制, 0o开头</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0x100</span>) <span class="comment">// 256  十六进制, 0x开头</span></span><br></pre></td></tr></table></figure>

<h3 id="数值的表示"><a href="#数值的表示" class="headerlink" title="数值的表示"></a>数值的表示</h3><p>另外在ES2021新增特性：数字过长时，可以使用_作为连接符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.长数字的表示,下划线的位置不能放到开头,仅可用于数字中,便于阅读,对多少个0就分隔一次没有限制</span></span><br><span class="line"><span class="keyword">const</span> money1 = <span class="number">100_00_00_0000_00_00</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(money1) <span class="comment">// 100000000000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> money2 = <span class="number">100_0000_0000_0000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(money2) <span class="comment">// 100000000000000</span></span><br></pre></td></tr></table></figure>

<h2 id="Symbol的使用"><a href="#Symbol的使用" class="headerlink" title="Symbol的使用"></a>Symbol的使用</h2><h3 id="Symbol的基本使用"><a href="#Symbol的基本使用" class="headerlink" title="Symbol的基本使用"></a>Symbol的基本使用</h3><ul>
<li>Symbol是什么呢？Symbol是ES6中新增的一个基本数据类型，翻译为符号。</li>
<li>那么为什么需要Symbol呢？<ul>
<li>在ES6之前，对象的属性名都是字符串形式，那么很容易造成属性名的冲突；</li>
<li>比如原来有一个对象，我们希望在其中添加一个新的属性和值，但是我们在不确定它原来内部有什么内容的情况下，很容易造成冲突，从而覆盖掉它内部的某个属性；</li>
<li>比如我们前面在讲apply、call、bind实现时，我们有给其中添加一个fn属性，那么如果它内部原来已经有了fn属性了呢？</li>
<li>比如开发中我们使用混入，那么混入中出现了同名的属性，必然有一个会被覆盖掉；</li>
</ul>
</li>
<li>Symbol就是为了解决上面的问题，用来生成一个独一无二的值。<ul>
<li>Symbol值是通过Symbol函数来生成的，生成后可以作为属性名；</li>
<li>也就是在ES6中，对象的属性名可以使用字符串，也可以使用Symbol值；</li>
</ul>
</li>
<li>Symbol即使多次创建值，它们也是不同的：Symbol函数执行后每次创建出来的值都是独一无二的；</li>
<li>我们也可以在创建Symbol值的时候传入一个描述description：这个是ES2019（ES10）新增的特性；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6之前存在的问题: (命名冲突问题)</span></span><br><span class="line"><span class="comment">// 比如原来有一个对象，我们希望在其中添加一个新的属性和值，但是我们在不确定它原来内部有什么内容的情况下，很容易造成冲突，从而覆盖掉它内部的某个属性；</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给obj对象添加一个新的属性 name</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj.<span class="property">fn</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125; <span class="comment">// 不确定 obj 对象中是否已经存在 fn 属性,如已经存在,则会被覆盖. (命名冲突问题)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;name: &#x27;why&#x27;, fn: ƒ&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">fn</span>) <span class="comment">// ƒ () &#123; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol作为属性名"><a href="#Symbol作为属性名" class="headerlink" title="Symbol作为属性名"></a>Symbol作为属性名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6之后可以使用Symbol生成一个独一无二的值</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>(); <span class="comment">// 调用 Symbol 函数生成一个独一无二的值</span></span><br><span class="line"><span class="comment">// const info = &#123; name: &quot;why&quot; &#125; // 不能将对象作为另一个对象的 key. 若使用,则会将对象转为字符串作为 key 使用,结果例如: &#123;[object Object]: &#x27;aaa&#x27;&#125;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [s1]: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;Symbol(): &#x27;aaa&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>() <span class="comment">// 调用 Symbol 函数生成一个独一无二的值</span></span><br><span class="line">obj[s2] = <span class="string">&quot;bbb&quot;</span> <span class="comment">// 修改对象中的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;Symbol(): &#x27;aaa&#x27;, Symbol(): &#x27;bbb&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> sKey = <span class="title class_">Symbol</span>() <span class="comment">// 调用 Symbol 函数生成一个独一无二的值</span></span><br><span class="line">  obj[sKey] = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125; <span class="comment">// 修改对象中的属性</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;Symbol(): &#x27;aaa&#x27;, Symbol(): &#x27;bbb&#x27;, Symbol(): ƒ&#125;</span></span><br><span class="line">  <span class="keyword">delete</span> obj[sKey] <span class="comment">// 删除对象中的属性</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;Symbol(): &#x27;aaa&#x27;, Symbol(): &#x27;bbb&#x27;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(obj)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1 将生成的唯一值加入对象中,作为属性使用</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  [s1]: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">  [s2]: <span class="string">&quot;bbb&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;name: &#x27;why&#x27;, age: 18, Symbol(): &#x27;aaa&#x27;, Symbol(): &#x27;bbb&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line">obj1[s1] = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">obj1[s2] = <span class="string">&quot;bbb&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1) <span class="comment">// &#123;Symbol(): &#x27;aaa&#x27;, Symbol(): &#x27;bbb&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj2, s1, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;aaa&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2) <span class="comment">// &#123;Symbol(): &#x27;aaa&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.获取symbol对应的key</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  [s1]: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">  [s2]: <span class="string">&quot;bbb&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]  获取到指定对象的 key ,但是获取不到 symbol 类型的 key</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj)) <span class="comment">// [Symbol(), Symbol()] 获取指定对象中 symbol 类型的 key,获取不到普通的 key</span></span><br><span class="line"><span class="comment">// 根据 symbol 类型的 key 获取到对应的属性值:</span></span><br><span class="line"><span class="keyword">const</span> symbolKeys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> symbolKeys) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[key]) <span class="comment">// aaa / bbb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相同值的Symbol"><a href="#相同值的Symbol" class="headerlink" title="相同值的Symbol"></a>相同值的Symbol</h3><ul>
<li>前面我们讲Symbol的目的是为了创建一个独一无二的值，那么如果我们现在就是想创建相同的Symbol应该怎么来做呢？<ul>
<li>我们可以使用Symbol.for方法来做到这一点；</li>
<li>并且我们可以通过Symbol.keyFor方法来获取对应的key；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.description</span></span><br><span class="line"><span class="comment">// 3.1. Symbol函数直接生成的值, 都是独一无二</span></span><br><span class="line"><span class="keyword">const</span> s3 = <span class="title class_">Symbol</span>(<span class="string">&quot;ccc&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3.<span class="property">description</span>) <span class="comment">// ccc</span></span><br><span class="line"><span class="keyword">const</span> s4 = <span class="title class_">Symbol</span>(s3.<span class="property">description</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3 === s4) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2. 通过 Symbol.for 可以生成相同的 Symbol 值</span></span><br><span class="line"><span class="keyword">const</span> s5 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> s6 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s5 === s6) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3 获取传入的key</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s5)) <span class="comment">// ddd</span></span><br></pre></td></tr></table></figure>

<h2 id="Set的使用"><a href="#Set的使用" class="headerlink" title="Set的使用"></a>Set的使用</h2><h3 id="Set的基本使用"><a href="#Set的基本使用" class="headerlink" title="Set的基本使用"></a>Set的基本使用</h3><ul>
<li><p>在ES6之前，我们存储数据的结构主要有两种：数组、对象。</p>
<ul>
<li>在ES6中新增了另外两种数据结构：Set、Map，以及它们的另外形式WeakSet、WeakMap。</li>
</ul>
</li>
<li><p>Set是一个新增的数据结构，可以用来保存数据，类似于数组，但是和数组的区别是元素不能重复。</p>
<ul>
<li>创建Set我们需要通过Set构造函数（暂时没有字面量创建的方式）：</li>
<li>我们可以发现Set中存放的元素是不会重复的，那么Set有一个非常常用的功能就是给数组去重。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建Set</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set) <span class="comment">// Set(0) &#123;size: 0&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 2.添加元素   </span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  set.<span class="title function_">add</span>(<span class="number">10</span>)</span><br><span class="line">  set.<span class="title function_">add</span>(<span class="number">22</span>)</span><br><span class="line">  set.<span class="title function_">add</span>(<span class="number">35</span>)</span><br><span class="line">  set.<span class="title function_">add</span>(<span class="number">22</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(set) <span class="comment">// Set(3) &#123;10, 22, 35&#125;</span></span><br><span class="line">  <span class="keyword">const</span> info = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>&#125;</span><br><span class="line">  set.<span class="title function_">add</span>(info)</span><br><span class="line">  set.<span class="title function_">add</span>(obj)</span><br><span class="line">  set.<span class="title function_">add</span>(obj)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(set) <span class="comment">// Set(5) &#123;10, 22, 35, &#123;…&#125;, &#123;…&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.应用场景: 数组的去重</span></span><br><span class="line"><span class="comment">// 数组去重方法一:</span></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> newNames = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> names) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!newNames.<span class="title function_">includes</span>(item)) &#123;</span><br><span class="line">    newNames.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNames)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重方法二:</span></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> newNamesSet = <span class="keyword">new</span> <span class="title class_">Set</span>(names)</span><br><span class="line"><span class="keyword">const</span> newNames = <span class="title class_">Array</span>.<span class="title function_">from</span>(newNamesSet) <span class="comment">// 将 set 对象转为数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNames) <span class="comment">// [&#x27;abc&#x27;, &#x27;cba&#x27;, &#x27;nba&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="Set的常见方法"><a href="#Set的常见方法" class="headerlink" title="Set的常见方法"></a>Set的常见方法</h3><ul>
<li>Set常见的属性：<ul>
<li>size：返回Set中元素的个数；</li>
</ul>
</li>
<li>Set常用的方法：<ul>
<li>add(value)：添加某个元素，返回Set对象本身；</li>
<li>delete(value)：从set中删除和这个值相等的元素，返回boolean类型；</li>
<li>has(value)：判断set中是否存在某个元素，返回boolean类型；</li>
<li>clear()：清空set中所有的元素，没有返回值；</li>
<li>forEach(callback, [, thisArg])：通过forEach遍历set；</li>
</ul>
</li>
<li>另外Set是支持for of的遍历的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.Set的其他属性和方法</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="comment">// 4.0 size 属性: 对象的长度</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="property">size</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="comment">// 4.1. add方法 往 set 对象中添加属性</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> info = &#123;&#125;</span><br><span class="line">set.<span class="title function_">add</span>(obj)</span><br><span class="line">set.<span class="title function_">add</span>(info)</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">100</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set) <span class="comment">// Set(3) &#123;&#123;…&#125;, &#123;…&#125;, 100&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.2. delete方法 删除 set 对象中的某个属性</span></span><br><span class="line">set.<span class="title function_">delete</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set) <span class="comment">// Set(2) &#123;&#123;…&#125;, 100&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.3. has方法 判断 set 对象中是否包含有指定的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(info)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.4. clear方法 清空 set 对象</span></span><br><span class="line"><span class="comment">// set.clear()</span></span><br><span class="line"><span class="comment">// console.log(set) // Set(0) &#123;size: 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.5. forEach 遍历 set 对象</span></span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item)) <span class="comment">// &#123;&#125; / 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. set 支持 for...of</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// &#123;&#125; / 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WeakSet的使用"><a href="#WeakSet的使用" class="headerlink" title="WeakSet的使用"></a>WeakSet的使用</h2><h3 id="WeakSet的使用-1"><a href="#WeakSet的使用-1" class="headerlink" title="WeakSet的使用"></a>WeakSet的使用</h3><ul>
<li>和Set类似的另外一个数据结构称之为WeakSet，也是内部元素不能重复的数据结构。</li>
<li>那么和Set有什么区别呢？<ul>
<li>区别一：WeakSet中只能存放对象类型，不能存放基本数据类型；</li>
<li>区别二：WeakSet对元素的引用是弱引用，如果没有其他引用对某个对象进行引用，那么GC可以对该对象进行回收；</li>
</ul>
</li>
<li>WeakSet常见的方法：<ul>
<li>add(value)：添加某个元素，返回WeakSet对象本身；</li>
<li>delete(value)：从WeakSet中删除和这个值相等的元素，返回boolean类型；</li>
<li>has(value)：判断WeakSet中是否存在某个元素，返回boolean类型；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.Weak Reference(弱引用) 和 Strong Reference(强引用)</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123; <span class="attr">name</span>: <span class="string">&quot;jame&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [obj1, obj2, obj3]</span><br><span class="line">obj1 = <span class="literal">null</span> <span class="comment">// 此处将 obj1 赋值为 null,但是 arr 还在引用该对象的内存地址,因此不会被回收</span></span><br><span class="line">obj2 = <span class="literal">null</span> <span class="comment">// 同上</span></span><br><span class="line">obj3 = <span class="literal">null</span> <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// Set(3) &#123;&#123;…&#125;, &#123;…&#125;, &#123;…&#125;&#125;</span></span><br><span class="line">arr = <span class="literal">null</span> <span class="comment">// 此时将 arr 赋值 null , obj1,obj2,obj3 的内存地址不再被其他对象引用,就会被回收</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.WeakSet的用法</span></span><br><span class="line"><span class="comment">// 2.1 和Set的区别一: 只能存放对象类型,放其他类型的数据会报错</span></span><br><span class="line"><span class="comment">// 2.2 和Set的区别二: 对对象的引用都是弱引用,添加的对象将会被回收</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123; <span class="attr">name</span>: <span class="string">&quot;jame&quot;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> weakSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line">weakSet.<span class="title function_">add</span>(obj1) <span class="comment">// obj1 将会被回收</span></span><br><span class="line">weakSet.<span class="title function_">add</span>(obj2) <span class="comment">// 同上</span></span><br><span class="line">weakSet.<span class="title function_">add</span>(obj3) <span class="comment">// 同上</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet); <span class="comment">// WeakSet &#123;&#123;…&#125;, &#123;…&#125;, &#123;…&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="WeakSet的应用"><a href="#WeakSet的应用" class="headerlink" title="WeakSet的应用"></a>WeakSet的应用</h3><ul>
<li>注意：WeakSet不能遍历<ul>
<li>因为WeakSet只是对对象的弱引用，如果我们遍历获取到其中的元素，那么有可能造成对象不能正常的销毁。</li>
<li>所以存储到WeakSet中的对象是没办法获取的；</li>
</ul>
</li>
<li>那么这个东西有什么用呢？<ul>
<li>事实上这个问题并不好回答，我们来使用一个Stack Overflow上的答案；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.WeakSet的应用</span></span><br><span class="line"><span class="keyword">const</span> pWeakSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pWeakSet.<span class="title function_">add</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pWeakSet.<span class="title function_">has</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Type error: 调用的方式不对&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;running~&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="comment">// p = null</span></span><br><span class="line">p.<span class="title function_">running</span>()</span><br><span class="line"><span class="keyword">const</span> runFn = p.<span class="property">running</span></span><br><span class="line"><span class="title function_">runFn</span>()</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">run</span>: runFn &#125;</span><br><span class="line">obj.<span class="title function_">run</span>()</span><br></pre></td></tr></table></figure>

<h2 id="Map的使用"><a href="#Map的使用" class="headerlink" title="Map的使用"></a>Map的使用</h2><h3 id="Map的基本使用"><a href="#Map的基本使用" class="headerlink" title="Map的基本使用"></a>Map的基本使用</h3><ul>
<li>另外一个新增的数据结构是Map，用于存储映射关系。</li>
<li>但是我们可能会想，在之前我们可以使用对象来存储映射关系，他们有什么区别呢？</li>
<li>事实上我们对象存储映射关系只能用字符串（ES6新增了Symbol）作为属性名（key）；</li>
<li>某些情况下我们可能希望通过其他类型作为key，比如对象，这个时候会自动将对象转成字符串来作为key；</li>
<li>那么我们就可以使用Map：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.对象类型的局限性: 不可以使用复杂类型作为key</span></span><br><span class="line"><span class="keyword">const</span> info = &#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> info2 = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;北京市&quot;</span>,</span><br><span class="line">  [info]: <span class="string">&quot;哈哈哈&quot;</span>,</span><br><span class="line">  [info2]: <span class="string">&quot;呵呵呵&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;address: &#x27;北京市&#x27;, [object Object]: &#x27;呵呵呵&#x27;&#125;  ,若写多个这样的 key,会使用后面的那个 key 和 值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.Map映射类型</span></span><br><span class="line"><span class="keyword">const</span> info = &#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> info2 = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(info, <span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(info2, <span class="string">&quot;bbbb&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(2) &#123;&#123;…&#125; =&gt; &#x27;aaaa&#x27;, &#123;…&#125; =&gt; &#x27;bbbb&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Map的常用方法"><a href="#Map的常用方法" class="headerlink" title="Map的常用方法"></a>Map的常用方法</h3><ul>
<li>Map常见的属性：<ul>
<li>size：返回Map中元素的个数；</li>
</ul>
</li>
<li>Map常见的方法：<ul>
<li>set(key, value)：在Map中添加key、value，并且返回整个Map对象；</li>
<li>get(key)：根据key获取Map中的value；</li>
<li>has(key)：判断是否包括某一个key，返回Boolean类型；</li>
<li>delete(key)：根据key删除一个键值对，返回Boolean类型；</li>
<li>clear()：清空所有的元素；</li>
<li>forEach(callback, [, thisArg])：通过forEach遍历Map；</li>
</ul>
</li>
<li>Map也可以通过for of进行遍历。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.Map的常见属性和方法</span></span><br><span class="line"><span class="keyword">const</span> info = &#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> info2 = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.0 map 对象的长度</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1. set方法, 设置内容</span></span><br><span class="line">map.<span class="title function_">set</span>(info, <span class="string">&quot;cccc&quot;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(info2, <span class="string">&quot;bbbb&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(2) &#123;&#123;…&#125; =&gt; &#x27;cccc&#x27;, &#123;…&#125; =&gt; &#x27;bbbb&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2. get方法, 获取内容</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(info)) <span class="comment">// cccc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3. delete方法, 删除内容</span></span><br><span class="line">map.<span class="title function_">delete</span>(info)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(1) &#123;&#123;…&#125; =&gt; &#x27;bbbb&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.4. has方法, 判断内容</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(info2)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.5. clear方法, 清空内容</span></span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(0) &#123;size: 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.6. forEach方法</span></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.for...of遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="keyword">const</span> [key, value] = item</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WeakMap的使用"><a href="#WeakMap的使用" class="headerlink" title="WeakMap的使用"></a>WeakMap的使用</h2><h3 id="WeakMap的使用-1"><a href="#WeakMap的使用-1" class="headerlink" title="WeakMap的使用"></a>WeakMap的使用</h3><ul>
<li>和Map类型的另外一个数据结构称之为WeakMap，也是以键值对的形式存在的。</li>
<li>那么和Map有什么区别呢？<ul>
<li>区别一：WeakMap的key只能使用对象，不接受其他的类型作为key；</li>
<li>区别二：WeakMap的key对对象想的引用是弱引用，如果没有其他引用引用这个对象，那么GC可以回收该对象；</li>
</ul>
</li>
<li>WeakMap常见的方法有四个：<ul>
<li>set(key, value)：在Map中添加key、value，并且返回整个Map对象；</li>
<li>get(key)：根据key获取Map中的value；</li>
<li>has(key)：判断是否包括某一个key，返回Boolean类型；</li>
<li>delete(key)：根据key删除一个键值对，返回Boolean类型；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.WeakMap的基本使用</span></span><br><span class="line"><span class="keyword">const</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="comment">// weakMap.set(123, &quot;aaa&quot;) // 报错,WeakMap的key只能使用对象，不接受其他的类型作为key</span></span><br><span class="line">weakMap.<span class="title function_">set</span>(obj1, <span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">weakMap.<span class="title function_">set</span>(obj2, <span class="string">&quot;bbb&quot;</span>)</span><br><span class="line"></span><br><span class="line">obj1 = <span class="literal">null</span> <span class="comment">// 回收obj1</span></span><br><span class="line">obj2 = <span class="literal">null</span> <span class="comment">// 回收obj2</span></span><br></pre></td></tr></table></figure>

<h3 id="WeakMap的应用"><a href="#WeakMap的应用" class="headerlink" title="WeakMap的应用"></a>WeakMap的应用</h3><ul>
<li>注意：WeakMap也是不能遍历的</li>
<li>没有forEach方法，也不支持通过for of的方式进行遍历；</li>
<li>那么我们的WeakMap有什么作用呢？（后续专门讲解）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ES6-的其他说明"><a href="#ES6-的其他说明" class="headerlink" title="ES6 的其他说明"></a>ES6 的其他说明</h2><ul>
<li>事实上ES6（ES2015）是一次非常大的版本更新，所以里面重要的特性非常多：</li>
<li>除了前面讲到的特性外还有很多其他特性；<ul>
<li>Proxy、Reflect，我们会在后续专门进行学习。</li>
<li>并且会利用Proxy、Reflect来讲解Vue3的响应式原理；</li>
</ul>
</li>
<li>Promise，用于处理异步的解决方案<ul>
<li>后续会详细学习；</li>
<li>并且会学习如何手写Promise；</li>
</ul>
</li>
<li>ES Module模块化开发：<ul>
<li>从ES6开发，JavaScript可以进行原生的模块化开发；</li>
<li>这部分内容会在工程化部分学习；</li>
<li>包括其他模块化方案：CommonJS、AMD、CMD等方案；</li>
</ul>
</li>
</ul>
<h2 id="ES7-ES13"><a href="#ES7-ES13" class="headerlink" title="ES7-ES13"></a>ES7-ES13</h2><h3 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h3><h4 id="Array-Includes"><a href="#Array-Includes" class="headerlink" title="Array Includes"></a>Array Includes</h4><ul>
<li>在ES7之前，如果我们想判断一个数组中是否包含某个元素，需要通过 indexOf 获取结果，并且判断是否为 -1。</li>
<li>在ES7中，我们可以通过includes来判断一个数组中是否包含一个指定的元素，根据情况，如果包含则返回 true，否则返回false。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h4><ul>
<li>在ES7之前，计算数字的乘方需要通过 Math.pow 方法来完成。</li>
<li>在ES7中，增加了<code> **</code> 运算符，可以对数字来计算乘方。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ES8"><a href="#ES8" class="headerlink" title="ES8"></a>ES8</h3><h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object values"></a>Object values</h4><ul>
<li>之前我们可以通过 Object.keys 获取一个对象所有的key</li>
<li>在ES8中提供了 Object.values 来获取所有的value值：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object entries"></a>Object entries</h4><ul>
<li>通过 Object.entries 可以获取到一个数组，数组中会存放可枚举属性的键值对数组。</li>
<li>可以针对对象、数组、字符串进行操作；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="String-Padding"><a href="#String-Padding" class="headerlink" title="String Padding"></a>String Padding</h4><ul>
<li>某些字符串我们需要对其进行前后的填充，来实现某种格式化效果，ES8中增加了 padStart 和 padEnd 方法，分别是对字符串的首尾进行填充的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>我们简单具一个应用场景：比如需要对身份证、银行卡的前面位数进行隐藏：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Trailing-Commas"><a href="#Trailing-Commas" class="headerlink" title="Trailing Commas"></a>Trailing Commas</h4><ul>
<li>在ES8中，我们允许在函数定义和调用时多加一个逗号：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Object-Descriptors"><a href="#Object-Descriptors" class="headerlink" title="Object Descriptors"></a>Object Descriptors</h4><ul>
<li>Object.getOwnPropertyDescriptors ：<ul>
<li>这个在之前已经讲过了，这里不再重复。</li>
</ul>
</li>
<li>Async Function：async、await<ul>
<li>后续讲完Promise讲解</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ES9"><a href="#ES9" class="headerlink" title="ES9"></a>ES9</h3><ul>
<li>Async iterators：后续迭代器讲解</li>
<li>Object spread operators：前面讲过了</li>
<li>Promise finally：后续讲Promise讲解</li>
</ul>
<h3 id="ES10"><a href="#ES10" class="headerlink" title="ES10"></a>ES10</h3><h4 id="flat-flatMap"><a href="#flat-flatMap" class="headerlink" title="flat flatMap"></a>flat flatMap</h4><ul>
<li>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。<ul>
<li>注意一：flatMap是先进行map操作，再做flat的操作；</li>
<li>注意二：flatMap中的flat相当于深度为1；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object fromEntries"></a>Object fromEntries</h4><ul>
<li>在前面，我们可以通过 Object.entries 将一个对象转换成 entries</li>
<li>那么如果我们有一个entries了，如何将其转换成对象呢？</li>
<li>ES10提供了 Object.formEntries来完成转换：</li>
<li>那么这个方法有什么应用场景呢？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="rimStart-trimEnd"><a href="#rimStart-trimEnd" class="headerlink" title="rimStart trimEnd"></a>rimStart trimEnd</h4><ul>
<li>去除一个字符串首尾的空格，我们可以通过trim方法，如果单独去除前面或者后面呢？</li>
<li>ES10中给我们提供了trimStart和trimEnd；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h4><ul>
<li>Symbol description：已经讲过了</li>
<li>Optional catch binding：后面讲解try cach讲解</li>
</ul>
<h3 id="ES11"><a href="#ES11" class="headerlink" title="ES11"></a>ES11</h3><h4 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h4><ul>
<li>在早期的JavaScript中，我们不能正确的表示过大的数字：<ul>
<li>大于MAX_SAFE_INTEGER的数值，表示的可能是不正确的。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>那么ES11中，引入了新的数据类型BigInt，用于表示大的整数：<ul>
<li>BitInt的表示方法是在数值的后面加上n</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="空值合并操作符"><a href="#空值合并操作符" class="headerlink" title="空值合并操作符"></a>空值合并操作符</h4><ul>
<li>ES11，Nullish Coalescing Operator增加了空值合并操作符：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h4><ul>
<li>可选链也是ES11中新增一个特性，主要作用是让我们的代码在进行null和undefined判断时更加清晰和简洁：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Global-This"><a href="#Global-This" class="headerlink" title="Global This"></a>Global This</h4><ul>
<li>在之前我们希望获取JavaScript环境的全局对象，不同的环境获取的方式是不一样的</li>
<li>比如在浏览器中可以通过this、window来获取；</li>
<li>比如在Node中我们需要通过global来获取；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>在ES11中对获取全局对象进行了统一的规范：globalThis</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="for-in标准化"><a href="#for-in标准化" class="headerlink" title="for..in标准化"></a>for..in标准化</h4><ul>
<li>在ES11之前，虽然很多浏览器支持for…in来遍历对象类型，但是并没有被ECMA标准化。</li>
<li>在ES11中，对其进行了标准化，for…in是用于遍历对象的key的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="其他内容-1"><a href="#其他内容-1" class="headerlink" title="其他内容"></a>其他内容</h4><ul>
<li>Dynamic Import：后续ES Module模块化中讲解。</li>
<li>Promise.allSettled：后续讲Promise的时候讲解。</li>
<li>import meta：后续ES Module模块化中讲解。</li>
</ul>
<h3 id="ES12"><a href="#ES12" class="headerlink" title="ES12"></a>ES12</h3><h4 id="FinalizationRegistry"><a href="#FinalizationRegistry" class="headerlink" title="FinalizationRegistry"></a>FinalizationRegistry</h4><ul>
<li>FinalizationRegistry 对象可以让你在对象被垃圾回收时请求一个回调。</li>
<li>FinalizationRegistry 提供了这样的一种方法：当一个在注册表中注册的对象被回收时，请求在某个时间点上调用一个清理回调。（清理回调有时被称为 finalizer ）;</li>
<li>你可以通过调用register方法，注册任何你想要清理回调的对象，传入该对象和所含的值;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="WeakRefs"><a href="#WeakRefs" class="headerlink" title="WeakRefs"></a>WeakRefs</h4><ul>
<li>如果我们默认将一个对象赋值给另外一个引用，那么这个引用是一个强引用：</li>
<li>如果我们希望是一个弱引用的话，可以使用WeakRef；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="其他内容-2"><a href="#其他内容-2" class="headerlink" title="其他内容"></a>其他内容</h4><ul>
<li>Numeric Separator：讲过了；</li>
<li>String.replaceAll：字符串替换；</li>
</ul>
<h3 id="ES13"><a href="#ES13" class="headerlink" title="ES13"></a>ES13</h3><h4 id="method-at"><a href="#method-at" class="headerlink" title="method.at()"></a>method.at()</h4><ul>
<li>前面我们有学过字符串、数组的at方法，它们是作为ES13中的新特性加入的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Object-hasOwn"><a href="#Object-hasOwn" class="headerlink" title="Object.hasOwn()"></a>Object.hasOwn()</h4><ul>
<li>Object中新增了一个静态方法（类方法）： hasOwn(obj, propKey)<ul>
<li>该方法用于判断一个对象中是否有某个自己的属性；</li>
<li>那么和之前学习的Object.prototype.hasOwnProperty有什么区别呢？<ul>
<li>区别一：防止对象内部有重写hasOwnProperty</li>
<li>区别二：对于隐式原型指向null的对象， hasOwnProperty无法进行判断</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="class类成员字段"><a href="#class类成员字段" class="headerlink" title="class类成员字段"></a>class类成员字段</h4><ul>
<li>在ES13中，新增了定义class类中成员字段（field）的其他方式：<ul>
<li>Instance public fields</li>
<li>Static public fields</li>
<li>Instance private fields</li>
<li>static private fields</li>
<li>static block</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Proxy使用详解"><a href="#Proxy使用详解" class="headerlink" title="Proxy使用详解"></a>Proxy使用详解</h2><h3 id="监听对象的操作"><a href="#监听对象的操作" class="headerlink" title="监听对象的操作"></a>监听对象的操作</h3><ul>
<li><p>我们先来看一个需求：有一个对象，我们希望监听这个对象中的属性被设置或获取的过程</p>
<ul>
<li>通过我们前面所学的知识，能不能做到这一点呢？</li>
<li>其实是可以的，我们可以通过之前的属性描述符中的存储属性描述符来做到；</li>
</ul>
</li>
<li><p>左边这段代码就利用了前面讲过的 Object.defineProperty 的存储属性描述符来对属性的操作进行监听。<br>但是这样做有什么缺点呢？</p>
<ul>
<li>首先，Object.defineProperty设计的初衷，不是为了去监听截止一个对象中所有的属性的。<ul>
<li>我们在定义某些属性的时候，初衷其实是定义普通的属性，但是后面我们强行将它变成了数据属性描述符。</li>
</ul>
</li>
<li>其次，如果我们想监听更加丰富的操作，比如新增属性、删除属性，那么 Object.defineProperty是无能为力的。</li>
</ul>
</li>
<li><p>所以我们要知道，存储数据描述符设计的初衷并不是为了去监听一个完整的对象。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Proxy基本使用"><a href="#Proxy基本使用" class="headerlink" title="Proxy基本使用"></a>Proxy基本使用</h3><ul>
<li>在ES6中，新增了一个Proxy类，这个类从名字就可以看出来，是用于帮助我们创建一个代理的：</li>
<li>也就是说，如果我们希望监听一个对象的相关操作，那么我们可以先创建一个代理对象（Proxy对象）；</li>
<li>之后对该对象的所有操作，都通过代理对象来完成，代理对象可以监听我们想要对原对象进行哪些操作；</li>
<li>我们可以将上面的案例用Proxy来实现一次：<ul>
<li>首先，我们需要new Proxy对象，并且传入需要侦听的对象以及一个处理对象，可以称之为handler；<ul>
<li><code>const p = new Proxy(target, handler)</code></li>
</ul>
</li>
</ul>
</li>
<li>其次，我们之后的操作都是直接对Proxy的操作，而不是原有的对象，因为我们需要在handler里面进行侦听；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Proxy的set和get捕获器"><a href="#Proxy的set和get捕获器" class="headerlink" title="Proxy的set和get捕获器"></a>Proxy的set和get捕获器</h3><ul>
<li><p>如果我们想要侦听某些具体的操作，那么就可以在handler中添加对应的捕捉器（Trap）：</p>
</li>
<li><p>set和get分别对应的是函数类型；</p>
<ul>
<li>set函数有四个参数：<ul>
<li>target：目标对象（侦听的对象）；</li>
<li>property：将被设置的属性key；</li>
<li>value：新属性值；</li>
<li>receiver：调用的代理对象；</li>
</ul>
</li>
<li>get函数有三个参数：<ul>
<li>target：目标对象（侦听的对象）；</li>
<li>property：被获取的属性key；</li>
<li>receiver：调用的代理对象；</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Proxy的所有捕获器"><a href="#Proxy的所有捕获器" class="headerlink" title="Proxy的所有捕获器"></a>Proxy的所有捕获器</h3><p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/5efd6284e2674a76a4001d387a529641" alt="1674720558176"></p>
<h3 id="construct和apply"><a href="#construct和apply" class="headerlink" title="construct和apply"></a>construct和apply</h3><ul>
<li>当然，我们还会看到捕捉器中还有construct和apply，它们是应用于函数对象的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Reflect使用详解"><a href="#Reflect使用详解" class="headerlink" title="Reflect使用详解"></a>Reflect使用详解</h2><h3 id="Reflect的作用"><a href="#Reflect的作用" class="headerlink" title="Reflect的作用"></a>Reflect的作用</h3><ul>
<li>Reflect也是ES6新增的一个API，它是一个对象，字面的意思是反射。</li>
<li>那么这个Reflect有什么用呢？<ul>
<li>它主要提供了很多操作JavaScript对象的方法，有点像Object中操作对象的方法；</li>
<li>比如Reflect.getPrototypeOf(target)类似于 Object.getPrototypeOf()；</li>
<li>比如Reflect.defineProperty(target, propertyKey, attributes)类似于Object.defineProperty() ；</li>
</ul>
</li>
<li>如果我们有Object可以做这些操作，那么为什么还需要有Reflect这样的新增对象呢？<ul>
<li>这是因为在早期的ECMA规范中没有考虑到这种对 对象本身 的操作如何设计会更加规范，所以将这些API放到了Object上面；</li>
<li>但是Object作为一个构造函数，这些操作实际上放到它身上并不合适；</li>
<li>另外还包含一些类似于 in、delete操作符，让JS看起来是会有一些奇怪的；</li>
<li>所以在ES6中新增了Reflect，让我们这些操作都集中到了Reflect对象上；</li>
<li>另外在使用Proxy时，可以做到不操作原对象；</li>
</ul>
</li>
<li>那么Object和Reflect对象之间的API关系，可以参考MDN文档：<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods</a></li>
</ul>
</li>
</ul>
<h3 id="Reflect的常见方法"><a href="#Reflect的常见方法" class="headerlink" title="Reflect的常见方法"></a>Reflect的常见方法</h3><p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/bf91345b42444b71b9ebe5a941459449" alt="1674720719657"></p>
<h3 id="Reflect的使用"><a href="#Reflect的使用" class="headerlink" title="Reflect的使用"></a>Reflect的使用</h3><ul>
<li>那么我们可以将之前Proxy案例中对原对象的操作，都修改为Reflect来操作：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Receiver的作用"><a href="#Receiver的作用" class="headerlink" title="Receiver的作用"></a>Receiver的作用</h3><ul>
<li>我们发现在使用getter、setter的时候有一个receiver的参数，它的作用是什么呢？<ul>
<li>如果我们的源对象（obj）有setter、getter的访问器属性，那么可以通过receiver来改变里面的this；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Reflect的construct"><a href="#Reflect的construct" class="headerlink" title="Reflect的construct"></a>Reflect的construct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="迭代器与生成器详解"><a href="#迭代器与生成器详解" class="headerlink" title="迭代器与生成器详解"></a>迭代器与生成器详解</h2><h3 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h3><ul>
<li>迭代器（iterator），使用户在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。<ul>
<li>其行为像数据库中的光标，迭代器最早出现在1974年设计的CLU编程语言中；</li>
<li>在各种编程语言的实现中，迭代器的实现方式各不相同，但是基本都有迭代器，比如Java、Python等；</li>
</ul>
</li>
<li>从迭代器的定义我们可以看出来，迭代器是帮助我们对某个数据结构进行遍历的对象。</li>
<li>在JavaScript中，迭代器也是一个具体的对象，这个对象需要符合迭代器协议（iterator protocol）：<ul>
<li>迭代器协议定义了产生一系列值（无论是有限还是无限个）的标准方式；</li>
<li>在JavaScript中这个标准就是一个特定的next方法；</li>
</ul>
</li>
<li>next方法有如下的要求：<ul>
<li>一个无参数或者一个参数的函数，返回一个应当拥有以下两个属性的对象：</li>
<li>done（boolean）<ul>
<li>如果迭代器可以产生序列中的下一个值，则为 false。（这等价于没有指定 done 这个属性。）</li>
<li>如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。</li>
</ul>
</li>
<li>value<ul>
<li>迭代器返回的任何 JavaScript 值。done 为 true 时可省略。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><ul>
<li>但是上面的代码整体来说看起来是有点奇怪的：<ul>
<li>我们获取一个数组的时候，需要自己创建一个index变量，再创建一个所谓的迭代器对象；</li>
<li>事实上我们可以对上面的代码进行进一步的封装，让其变成一个可迭代对象；</li>
</ul>
</li>
<li>什么又是可迭代对象呢？<ul>
<li>它和迭代器是不同的概念；</li>
<li>当一个对象实现了iterable protocol协议时，它就是一个可迭代对象；</li>
<li>这个对象的要求是必须实现 @@iterator 方法，在代码中我们使用 Symbol.iterator 访问该属性；</li>
</ul>
</li>
<li>当然我们要问一个问题，我们转成这样的一个东西有什么好处呢？<ul>
<li>当一个对象变成一个可迭代对象的时候，就可以进行某些迭代操作；</li>
<li>比如 for…of 操作时，其实就会调用它的 @@iterator 方法；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="原生迭代器对象"><a href="#原生迭代器对象" class="headerlink" title="原生迭代器对象"></a>原生迭代器对象</h3><ul>
<li>事实上我们平时创建的很多原生对象已经实现了可迭代协议，会生成一个迭代器对象的：<ul>
<li>String、Array、Map、Set、arguments对象、NodeList集合；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="可迭代对象的应用"><a href="#可迭代对象的应用" class="headerlink" title="可迭代对象的应用"></a>可迭代对象的应用</h3><ul>
<li>那么这些东西可以被用在哪里呢？<ul>
<li>JavaScript中语法：for …of、展开语法（spread syntax）、yield*（后面讲）、解构赋值（Destructuring_assignment）；</li>
<li>创建一些对象时：new Map([Iterable])、new WeakMap([iterable])、new Set([iterable])、new WeakSet([iterable]);</li>
<li>一些方法的调用：Promise.all(iterable)、Promise.race(iterable)、Array.from(iterable);</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义类的迭代"><a href="#自定义类的迭代" class="headerlink" title="自定义类的迭代"></a>自定义类的迭代</h3><ul>
<li><p>在前面我们看到Array、Set、String、Map等类创建出来的对象都是可迭代对象：</p>
<ul>
<li>在面向对象开发中，我们可以通过class定义一个自己的类，这个类可以创建很多的对象：</li>
<li>如果我们也希望自己的类创建出来的对象默认是可迭代的，那么在设计类的时候我们就可以添加上 @@iterator 方法；</li>
</ul>
</li>
<li><p>案例：创建一个classroom的类</p>
<ul>
<li>教室中有自己的位置、名称、当前教室的学生；</li>
<li>这个教室可以进来新学生（push）；</li>
<li>创建的教室对象是可迭代对象；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="迭代器的中断"><a href="#迭代器的中断" class="headerlink" title="迭代器的中断"></a>迭代器的中断</h3><ul>
<li>迭代器在某些情况下会在没有完全迭代的情况下中断：<ul>
<li>比如遍历的过程中通过break、return、throw中断了循环操作；</li>
<li>比如在解构的时候，没有解构所有的值；</li>
</ul>
</li>
<li>那么这个时候我们想要监听中断的话，可以添加return方法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h3><ul>
<li><p>生成器是ES6中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等。</p>
<ul>
<li>平时我们会编写很多的函数，这些函数终止的条件通常是返回值或者发生了异常。</li>
</ul>
</li>
<li><p>生成器函数也是一个函数，但是和普通的函数有一些区别：</p>
<ul>
<li>首先，生成器函数需要在function的后面加一个符号：*</li>
<li>其次，生成器函数可以通过yield关键字来控制函数的执行流程：</li>
<li>最后，生成器函数的返回值是一个Generator（生成器）：<ul>
<li>生成器事实上是一种特殊的迭代器；</li>
<li>MDN：Instead, they return a special type of iterator, called a Generator</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="生成器函数执行"><a href="#生成器函数执行" class="headerlink" title="生成器函数执行"></a>生成器函数执行</h3><ul>
<li>我们发现下面的生成器函数foo的执行体压根没有执行，它只是返回了一个生成器对象。<ul>
<li>那么我们如何可以让它执行函数中的东西呢？调用next即可；</li>
<li>我们之前学习迭代器时，知道迭代器的next是会有返回值的；</li>
<li>但是我们很多时候不希望next返回的是一个undefined，这个时候我们可以通过yield来返回结果；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="next函数"><a href="#next函数" class="headerlink" title="next函数"></a>next函数</h3><ul>
<li>函数既然可以暂停来分段执行，那么函数应该是可以传递参数的，我们是否可以给每个分段来传递参数呢？<ul>
<li>答案是可以的；</li>
<li>我们在调用next函数的时候，可以给它传递参数，那么这个参数会作为上一个yield语句的返回值；</li>
<li>注意：也就是说我们是为本次的函数代码块执行提供了一个值；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="return函数"><a href="#return函数" class="headerlink" title="return函数"></a>return函数</h3><ul>
<li>还有一个可以给生成器函数传递参数的方法是通过return函数：<ul>
<li>return传值后这个生成器函数就会结束，之后调用next不会继续生成值了；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="throw函数"><a href="#throw函数" class="headerlink" title="throw函数"></a>throw函数</h3><ul>
<li>除了给生成器函数内部传递参数之外，也可以给生成器函数内部抛出异常：<ul>
<li>抛出异常后我们可以在生成器函数中捕获异常；</li>
<li>但是在catch语句中不能继续yield新的值了，但是可以在catch语句外使用yield继续中断函数的执行；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="生成器替代迭代器"><a href="#生成器替代迭代器" class="headerlink" title="生成器替代迭代器"></a>生成器替代迭代器</h3><ul>
<li>我们发现生成器是一种特殊的迭代器，那么在某些情况下我们可以使用生成器来替代迭代器：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>事实上我们还可以使用yield*来生产一个可迭代对象：<ul>
<li>这个时候相当于是一种yield的语法糖，只不过会依次迭代这个可迭代对象，每次迭代其中的一个值；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="生成器实现"><a href="#生成器实现" class="headerlink" title="生成器实现"></a>生成器实现</h3><ul>
<li>在之前的自定义类迭代中，我们也可以换成生成器：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>既然生成器是一个迭代器，那么我们可以对其进行如下的操作：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="异步处理方案"><a href="#异步处理方案" class="headerlink" title="异步处理方案"></a>异步处理方案</h3><ul>
<li>学完了我们前面的Promise、生成器等，我们目前来看一下异步代码的最终处理方案。</li>
<li>案例需求：<ul>
<li>我们需要向服务器发送网络请求获取数据，一共需要发送三次请求；</li>
<li>第二次的请求url依赖于第一次的结果；</li>
<li>第三次的请求url依赖于第二次的结果；</li>
<li>依次类推；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Generator方案"><a href="#Generator方案" class="headerlink" title="Generator方案"></a>Generator方案</h3><ul>
<li>但是上面的代码其实看起来也是阅读性比较差的，有没有办法可以继续来对上面的代码进行优化呢？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>目前我们的写法有两个问题：<ul>
<li>第一，我们不能确定到底需要调用几层的Promise关系；</li>
<li>第二，如果还有其他需要这样执行的函数，我们应该如何操作呢？</li>
</ul>
</li>
<li>所以，我们可以封装一个工具函数execGenerator自动执行生成器函数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><h3 id="异步函数-async-function"><a href="#异步函数-async-function" class="headerlink" title="异步函数 async function"></a>异步函数 async function</h3><ul>
<li>async关键字用于声明一个异步函数：</li>
<li>async是asynchronous单词的缩写，异步、非同步；</li>
<li>sync是synchronous单词的缩写，同步、同时；</li>
<li>async异步函数可以有很多中写法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="异步函数的执行流程"><a href="#异步函数的执行流程" class="headerlink" title="异步函数的执行流程"></a>异步函数的执行流程</h3><ul>
<li><p>异步函数的内部代码执行过程和普通的函数是一致的，默认情况下也是会被同步执行。</p>
</li>
<li><p>异步函数有返回值时，和普通函数会有区别：</p>
<ul>
<li>情况一：异步函数也可以有返回值，但是异步函数的返回值相当于被包裹到Promise.resolve中；</li>
<li>情况二：如果我们的异步函数的返回值是Promise，状态由会由Promise决定；</li>
<li>情况三：如果我们的异步函数的返回值是一个对象并且实现了thenable，那么会由对象的then方法来决定；</li>
</ul>
</li>
<li><p>如果我们在async中抛出了异常，那么程序它并不会像普通函数一样报错，而是会作为Promise的reject来传递；</p>
</li>
</ul>
<h3 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h3><ul>
<li><p>async函数另外一个特殊之处就是可以在它内部使用await关键字，而普通函数中是不可以的。</p>
</li>
<li><p>await关键字有什么特点呢？</p>
<ul>
<li>通常使用await是后面会跟上一个表达式，这个表达式会返回一个Promise；</li>
<li>那么await会等到Promise的状态变成fulfilled状态，之后继续执行异步函数；</li>
</ul>
</li>
<li><p>如果await后面是一个普通的值，那么会直接返回这个值；</p>
</li>
<li><p>如果await后面是一个thenable的对象，那么会根据对象的then方法调用来决定后续的值；</p>
</li>
<li><p>如果await后面的表达式，返回的Promise是reject的状态，那么会将这个reject结果直接作为函数的Promise的reject值；</p>
</li>
</ul>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程和线程-1"><a href="#进程和线程-1" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul>
<li>线程和进程是操作系统中的两个概念：<ul>
<li>进程（process）：计算机已经运行的程序，是操作系统管理程序的一种方式；</li>
<li>线程（thread）：操作系统能够运行运算调度的最小单位，通常情况下它被包含在进程中；</li>
</ul>
</li>
<li>听起来很抽象，这里还是给出我的解释：<ul>
<li>进程：我们可以认为，启动一个应用程序，就会默认启动一个进程（也可能是多个进程）；</li>
<li>线程：每一个进程中，都会启动至少一个线程用来执行程序中的代码，这个线程被称之为主线程；</li>
<li>所以我们也可以说进程是线程的容器；</li>
</ul>
</li>
<li>再用一个形象的例子解释：<ul>
<li>操作系统类似于一个大工厂；</li>
<li>工厂中里有很多车间，这个车间就是进程；</li>
<li>每个车间可能有一个以上的工人在工厂，这个工人就是线程；</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/bef31c8e60a046099bab2d697dfe556d" alt="1674722890059"></p>
<h3 id="操作系统的工作方式"><a href="#操作系统的工作方式" class="headerlink" title="操作系统的工作方式"></a>操作系统的工作方式</h3><ul>
<li>操作系统是如何做到同时让多个进程（边听歌、边写代码、边查阅资料）同时工作呢？</li>
<li>这是因为CPU的运算速度非常快，它可以快速的在多个进程之间迅速的切换；</li>
<li>当我们进程中的线程获取到时间片时，就可以快速执行我们编写的代码；</li>
<li>对于用户来说是感受不到这种快速的切换的；</li>
<li>你可以在Mac的活动监视器或者Windows的资源管理器中查看到很多进程：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/9f3475fcb0514b98a92ec335af54652e" alt="1674722932898"></p>
<h3 id="浏览器中的JS线程"><a href="#浏览器中的JS线程" class="headerlink" title="浏览器中的JS线程"></a>浏览器中的JS线程</h3><ul>
<li>我们经常会说JavaScript是单线程（可以开启workers）的，但是JavaScript的线程应该有自己的容器进程：浏览器或者Node。</li>
<li>浏览器是一个进程吗，它里面只有一个线程吗？</li>
<li>目前多数的浏览器其实都是多进程的，当我们打开一个tab页面时就会开启一个新的进程，这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出；</li>
<li>每个进程中又有很多的线程，其中包括执行JavaScript代码的线程；</li>
<li>JavaScript的代码执行是在一个单独的线程中执行的：</li>
<li>这就意味着JavaScript的代码，在同一个时刻只能做一件事；</li>
<li>如果这件事是非常耗时的，就意味着当前的线程就会被阻塞；</li>
<li>所以真正耗时的操作，实际上并不是由JavaScript线程在执行的：</li>
<li>浏览器的每个进程是多线程的，那么其他线程可以来完成这个耗时的操作；</li>
<li>比如网络请求、定时器，我们只需要在特性的时候执行应该有的回调即可；</li>
</ul>
<h2 id="浏览器的事件循环"><a href="#浏览器的事件循环" class="headerlink" title="浏览器的事件循环"></a>浏览器的事件循环</h2><h3 id="浏览器的事件循环-1"><a href="#浏览器的事件循环-1" class="headerlink" title="浏览器的事件循环"></a>浏览器的事件循环</h3><ul>
<li>如果在执行JavaScript代码的过程中，有异步操作呢？</li>
<li>中间我们插入了一个setTimeout的函数调用；</li>
<li>这个函数被放到入调用栈中，执行会立即结束，并不会阻塞后续代码的执行；</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/7b073eaa828044b19177c77e70a456f9" alt="1674723346457"></p>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><ul>
<li>但是事件循环中并非只维护着一个队列，事实上是有两个队列：</li>
<li>宏任务队列（macrotask queue）：ajax、setTimeout、setInterval、DOM监听、UI Rendering等</li>
<li>微任务队列（microtask queue）：Promise的then回调、 Mutation Observer API、queueMicrotask()等</li>
<li>那么事件循环对于两个队列的优先级是怎么样的呢？<ul>
<li>1.main script中的代码优先执行（编写的顶层script代码）；</li>
<li>2.在执行任何一个宏任务之前（不是队列，是一个宏任务），都会先查看微任务队列中是否有任务需要执行<ul>
<li>	也就是宏任务执行之前，必须保证微任务队列是空的；</li>
<li>	如果不为空，那么就优先执行微任务队列中的任务（回调）；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Node的事件循环"><a href="#Node的事件循环" class="headerlink" title="Node的事件循环"></a>Node的事件循环</h2><h3 id="Node的事件循环-1"><a href="#Node的事件循环-1" class="headerlink" title="Node的事件循环"></a>Node的事件循环</h3><ul>
<li>浏览器中的EventLoop是根据HTML5定义的规范来实现的，不同的浏览器可能会有不同的实现，而Node中是由libuv实现的。</li>
<li>这里我们来给出一个Node的架构图：</li>
<li>我们会发现libuv中主要维护了一个EventLoop和worker threads（线程池）；</li>
<li>EventLoop负责调用系统的一些其他操作：文件的IO、Network、child-processes等</li>
<li>libuv是一个多平台的专注于异步IO的库，它最初是为Node开发的，但是现在也被使用到Luvit、Julia、pyuv等其他地方；</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/bfda607c7ebd4810a12320bde4644024"></p>
<h3 id="Node事件循环的阶段"><a href="#Node事件循环的阶段" class="headerlink" title="Node事件循环的阶段"></a>Node事件循环的阶段</h3><ul>
<li>我们最前面就强调过，事件循环像是一个桥梁，是连接着应用程序的JavaScript和系统调用之间的通道：</li>
<li>无论是我们的文件IO、数据库、网络IO、定时器、子进程，在完成对应的操作后，都会将对应的结果和回调函数放到事件循环（任务队列）中；</li>
<li>事件循环会不断的从任务队列中取出对应的事件（回调函数）来执行；</li>
<li>但是一次完整的事件循环Tick分成很多个阶段：</li>
<li>定时器（Timers）：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。</li>
<li>待定回调（Pending Callback）：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到ECONNREFUSED。</li>
<li>idle, prepare：仅系统内部使用。</li>
<li>轮询（Poll）：检索新的 I&#x2F;O 事件；执行与 I&#x2F;O 相关的回调；</li>
<li>检测（check）：setImmediate() 回调函数在这里执行。</li>
<li>关闭的回调函数：一些关闭的回调函数，如：socket.on(‘close’, …)。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/881320fd0355461ab0139d36c50f806d" alt="1674723568788"></p>
<h3 id="宏任务和微任务-1"><a href="#宏任务和微任务-1" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><ul>
<li>我们会发现从一次事件循环的Tick来说，Node的事件循环更复杂，它也分为微任务和宏任务：</li>
<li>宏任务（macrotask）：setTimeout、setInterval、IO事件、setImmediate、close事件；</li>
<li>微任务（microtask）：Promise的then回调、process.nextTick、queueMicrotask；</li>
<li>但是，Node中的事件循环不只是 微任务队列和 宏任务队列：</li>
<li>微任务队列：<ul>
<li>	next tick queue：process.nextTick；</li>
<li>	other queue：Promise的then回调、queueMicrotask；</li>
</ul>
</li>
<li>宏任务队列：<ul>
<li>	timer queue：setTimeout、setInterval；</li>
<li>	poll queue：IO事件；</li>
<li>	check queue：setImmediate；</li>
<li>	close queue：close事件；</li>
</ul>
</li>
</ul>
<h3 id="Node事件循环顺序"><a href="#Node事件循环顺序" class="headerlink" title="Node事件循环顺序"></a>Node事件循环顺序</h3><ul>
<li>所以，在每一次事件循环的tick中，会按照如下顺序来执行代码：</li>
<li>next tick microtask queue；</li>
<li>other microtask queue；</li>
<li>timer queue；</li>
<li>poll queue；</li>
<li>check queue；</li>
<li>close queue；</li>
</ul>
<h3 id="常见面试题-1"><a href="#常见面试题-1" class="headerlink" title="常见面试题"></a>常见面试题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="错误处理方案"><a href="#错误处理方案" class="headerlink" title="错误处理方案"></a>错误处理方案</h2><h3 id="错误处理方案-1"><a href="#错误处理方案-1" class="headerlink" title="错误处理方案"></a>错误处理方案</h3><ul>
<li>开发中我们会封装一些工具函数，封装之后给别人使用：<ul>
<li>在其他人使用的过程中，可能会传递一些参数；</li>
<li>对于函数来说，需要对这些参数进行验证，否则可能得到的是我们不想要的结果；</li>
</ul>
</li>
<li>很多时候我们可能验证到不是希望得到的参数时，就会直接return：<ul>
<li>但是return存在很大的弊端：调用者不知道是因为函数内部没有正常执行，还是执行结果就是一个undefined；</li>
<li>事实上，正确的做法应该是如果没有通过某些验证，那么应该让外界知道函数内部报错了；</li>
</ul>
</li>
<li>如何可以让一个函数告知外界自己内部出现了错误呢？<ul>
<li>通过throw关键字，抛出一个异常；</li>
</ul>
</li>
<li>throw语句：<ul>
<li>throw语句用于抛出一个用户自定义的异常；</li>
<li>当遇到throw语句时，当前的函数执行会被停止（throw后面的语句不会执行）；</li>
</ul>
</li>
<li>如果我们执行代码，就会报错，拿到错误信息的时候我们可以及时的去修正代码。</li>
</ul>
<h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><ul>
<li><p>throw表达式就是在throw后面可以跟上一个表达式来表示具体的异常信息：</p>
</li>
<li><p>throw关键字可以跟上哪些类型呢？</p>
</li>
<li><p>基本数据类型：比如number、string、Boolean</p>
</li>
<li><p>对象类型：对象类型可以包含更多的信息</p>
</li>
<li><p>但是每次写这么长的对象又有点麻烦，所以我们可以创建一个类</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Error类型"><a href="#Error类型" class="headerlink" title="Error类型"></a>Error类型</h3><ul>
<li>事实上，JavaScript已经给我们提供了一个Error类，我们可以直接创建这个类的对象：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Error包含三个属性：<ul>
<li>messsage：创建Error对象时传入的message；</li>
<li>name：Error的名称，通常和类的名称一致；</li>
<li>stack：整个Error的错误信息，包括函数的调用栈，当我们直接打印Error对象时，打印的就是stack；</li>
</ul>
</li>
<li>Error有一些自己的子类：<ul>
<li>RangeError：下标值越界时使用的错误类型；</li>
<li>SyntaxError：解析语法错误时使用的错误类型；</li>
<li>TypeError：出现类型错误时，使用的错误类型；</li>
</ul>
</li>
</ul>
<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><ul>
<li>我们会发现在之前的代码中，一个函数抛出了异常，调用它的时候程序会被强制终止：</li>
<li>这是因为如果我们在调用一个函数时，这个函数抛出了异常，但是我们并没有对这个异常进行处理，那么这个异常会继续传递到上一个函数调用中；</li>
<li>而如果到了最顶层（全局）的代码中依然没有对这个异常的处理代码，这个时候就会报错并且终止程序的运行；</li>
<li>我们先来看一下这段代码的异常传递过程：</li>
<li>foo函数在被执行时会抛出异常，也就是我们的bar函数会拿到这个异常；</li>
<li>但是bar函数并没有对这个异常进行处理，那么这个异常就会被继续传递到调用bar函数的函数，也就是test函数；</li>
<li>但是test函数依然没有处理，就会继续传递到我们的全局代码逻辑中；</li>
<li>依然没有被处理，这个时候程序会终止执行，后续代码都不会再执行了；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><ul>
<li>但是很多情况下当出现异常时，我们并不希望程序直接推出，而是希望可以正确的处理异常：</li>
<li>这个时候我们就可以使用try catch</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/6c2fb967d1cf4d399477f301fe25c34c" alt="1674723910194"></p>
<ul>
<li>在ES10（ES2019）中，catch后面绑定的error可以省略。</li>
<li>当然，如果有一些必须要执行的代码，我们可以使用finally来执行：</li>
<li>finally表示最终一定会被执行的代码结构；</li>
<li>注意：如果try和finally中都有返回值，那么会使用finally当中的返回值；</li>
</ul>
<h2 id="本地存储Storage"><a href="#本地存储Storage" class="headerlink" title="本地存储Storage"></a>本地存储Storage</h2><h3 id="认识Storage"><a href="#认识Storage" class="headerlink" title="认识Storage"></a>认识Storage</h3><ul>
<li>WebStorage主要提供了一种机制，可以让浏览器提供一种比cookie更直观的key、value存储方式：</li>
<li>localStorage：本地存储，提供的是一种永久性的存储方法，在关闭掉网页重新打开时，存储的内容依然保留；</li>
<li>sessionStorage：会话存储，提供的是本次会话的存储，在关闭掉会话时，存储的内容会被清除；</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/e47161e747d24ec5b42634993d59d241" alt="1674723980844"></p>
<ul>
<li>我们会发现localStorage和sessionStorage看起来非常的相似。</li>
<li>那么它们有什么区别呢？<ul>
<li>验证一：关闭网页后重新打开，localStorage会保留，而sessionStorage会被删除；</li>
<li>验证二：在页面内实现跳转，localStorage会保留，sessionStorage也会保留；</li>
<li>验证三：在页面外实现跳转（打开新的网页），localStorage会保留，sessionStorage不会被保留；</li>
</ul>
</li>
</ul>
<h3 id="Storage常见方法和属性"><a href="#Storage常见方法和属性" class="headerlink" title="Storage常见方法和属性"></a>Storage常见方法和属性</h3><ul>
<li>Storage有如下的属性和方法：<ul>
<li>属性：<ul>
<li>Storage.length：只读属性</li>
<li>	返回一个整数，表示存储在Storage对象中的数据项数量；</li>
</ul>
</li>
<li>方法：<ul>
<li>Storage.key(index)：该方法接受一个数值n作为参数，返回存储中的第n个key名称；</li>
<li>Storage.getItem()：该方法接受一个key作为参数，并且返回key对应的value；</li>
<li>Storage.setItem()：该方法接受一个key和value，并且将会把key和value添加到存储中。<ul>
<li>	如果key存储，则更新其对应的值；</li>
</ul>
</li>
<li>Storage.removeItem()：该方法接受一个key作为参数，并把该key从存储中删除；</li>
<li>Storage.clear()：该方法的作用是清空存储中的所有key；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="正则表达式-空"><a href="#正则表达式-空" class="headerlink" title="正则表达式(空)"></a>正则表达式(空)</h2><h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><h3 id="认识防抖和节流函数"><a href="#认识防抖和节流函数" class="headerlink" title="认识防抖和节流函数"></a>认识防抖和节流函数</h3><ul>
<li><p>防抖和节流的概念其实最早并不是出现在软件工程中，防抖是出现在电子元件中，节流出现在流体流动中</p>
<ul>
<li>而JavaScript是事件驱动的，大量的操作会触发事件，加入到事件队列中处理。</li>
<li>而对于某些频繁的事件处理会造成性能的损耗，我们就可以通过防抖和节流来限制事件频繁的发生；</li>
</ul>
</li>
<li><p>防抖和节流函数目前已经是前端实际开发中两个非常重要的函数，也是面试经常被问到的面试题。</p>
</li>
<li><p>但是很多前端开发者面对这两个功能，有点摸不着头脑：</p>
<ul>
<li>某些开发者根本无法区分防抖和节流有什么区别（面试经常会被问到）；</li>
<li>某些开发者可以区分，但是不知道如何应用；</li>
<li>某些开发者会通过一些第三方库来使用，但是不知道内部原理，更不会编写；</li>
</ul>
</li>
<li><p>接下来我们会一起来学习防抖和节流函数：</p>
<ul>
<li>我们不仅仅要区分清楚防抖和节流两者的区别，也要明白在实际工作中哪些场景会用到；</li>
<li>并且我会带着大家一点点来编写一个自己的防抖和节流的函数，不仅理解原理，也学会自己来编写；</li>
</ul>
</li>
</ul>
<h3 id="认识防抖debounce函数"><a href="#认识防抖debounce函数" class="headerlink" title="认识防抖debounce函数"></a>认识防抖debounce函数</h3><ul>
<li>我们用一副图来理解一下它的过程：<ul>
<li>当事件触发时，相应的函数并不会立即触发，而是会等待一定的时间；</li>
<li>当事件密集触发时，函数的触发会被频繁的推迟；</li>
<li>只有等待了一段时间也没有事件触发，才会真正的执行响应函数；</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/d21ac09c082c47a896924fc27a1108b5" alt="1674724232907"></p>
<ul>
<li>防抖的应用场景很多:<ul>
<li>输入框中频繁的输入内容，搜索或者提交信息;</li>
<li>频繁的点击按钮，触发某个事件;</li>
<li>监听浏览器滚动事件，完成某些特定操作;</li>
<li>用户缩放浏览器的resize事件;</li>
</ul>
</li>
</ul>
<h3 id="防抖函数的案例"><a href="#防抖函数的案例" class="headerlink" title="防抖函数的案例"></a>防抖函数的案例</h3><ul>
<li>我们都遇到过这样的场景，在某个搜索框中输入自己想要搜索的内容：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/f80110f394024a1a854b0bd2b3cabb76" alt="1674724643150"></p>
<ul>
<li>比如想要搜索一个MacBook：<ul>
<li>当我输入m时，为了更好的用户体验，通常会出现对应的联想内容，这些联想内容通常是保存在服务器的，所以需要一次网络请求；</li>
<li>当继续输入ma时，再次发送网络请求；</li>
<li>那么macbook一共需要发送7次网络请求；</li>
<li>这大大损耗我们整个系统的性能，无论是前端的事件处理，还是对于服务器的压力;</li>
</ul>
</li>
<li>但是我们需要这么多次的网络请求吗？<ul>
<li>不需要，正确的做法应该是在合适的情况下再发送网络请求；</li>
<li>比如如果用户快速的输入一个macbook，那么只是发送一次网络请求；</li>
<li>比如如果用户是输入一个m想了一会儿，这个时候m确实应该发送一次网络请求；</li>
<li>也就是我们应该监听用户在某个时间，比如500ms内，没有再次触发时间时，再发送网络请求；</li>
</ul>
</li>
<li>这就是防抖的操作：只有在某个时间内，没有再次触发某个函数时，才真正的调用这个函数；</li>
</ul>
<h4 id="案例准备"><a href="#案例准备" class="headerlink" title="案例准备"></a>案例准备</h4><ul>
<li>我们通过一个搜索框来延迟防抖函数的实现过程：<ul>
<li>监听input的输入，通过打印模拟网络请求</li>
</ul>
</li>
<li>测试发现快速输入一个macbook共发送了7次请求，显示我们需要对它进行防抖操作：</li>
</ul>
<h4 id="Underscore库的介绍"><a href="#Underscore库的介绍" class="headerlink" title="Underscore库的介绍"></a>Underscore库的介绍</h4><ul>
<li>事实上我们可以通过一些第三方库来实现防抖操作：<ul>
<li>lodash</li>
<li>underscore</li>
</ul>
</li>
<li>这里使用underscore<ul>
<li>我们可以理解成lodash是underscore的升级版，它更重量级，功能也更多；</li>
<li>但是目前我看到underscore还在维护，lodash已经很久没有更新了；</li>
</ul>
</li>
<li>Underscore的官网： <a target="_blank" rel="noopener" href="https://underscorejs.org/">https://underscorejs.org/</a></li>
<li>Underscore的安装有很多种方式：<ul>
<li>下载Underscore，本地引入；</li>
<li>通过CDN直接引入；</li>
<li>通过包管理工具（npm）管理安装；</li>
</ul>
</li>
<li>这里我们直接通过CDN：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scriptsrc=&quot;https://cdn.jsdelivr.net/npm/underscore@1.13.1/underscore-umd-min.js&quot;&gt;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="认识节流throttle函数"><a href="#认识节流throttle函数" class="headerlink" title="认识节流throttle函数"></a>认识节流throttle函数</h3><ul>
<li>我们用一副图来理解一下节流的过程<ul>
<li>当事件触发时，会执行这个事件的响应函数；</li>
<li>如果这个事件会被频繁触发，那么节流函数会按照一定的频率来执行函数；</li>
<li>不管在这个中间有多少次触发这个事件，执行函数的频繁总是固定的；</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://s1.vika.cn/space/2023/02/26/d869b21a37ef43d8b4327bac0b57215d" alt="1674724371890"></p>
<ul>
<li>节流的应用场景:<ul>
<li>监听页面的滚动事件;</li>
<li>鼠标移动事件;</li>
<li>用户频繁点击按钮操作;游戏中的一些设计;</li>
</ul>
</li>
</ul>
<h3 id="节流函数的应用场景"><a href="#节流函数的应用场景" class="headerlink" title="节流函数的应用场景"></a>节流函数的应用场景</h3><ul>
<li><p>很多人都玩过类似于飞机大战的游戏</p>
</li>
<li><p>在飞机大战的游戏中，我们按下空格会发射一个子弹：</p>
<ul>
<li>很多飞机大战的游戏中会有这样的设定，即使按下的频率非常快，子弹也会保持一定的频率来发射；</li>
<li>比如1秒钟只能发射一次，即使用户在这1秒钟按下了10次，子弹会保持发射一颗的频率来发射；</li>
<li>但是事件是触发了10次的，响应的函数只触发了一次；</li>
</ul>
</li>
<li><p>生活中防抖的例子：</p>
<ul>
<li>比如说有一天我上完课，我说大家有什么问题来问我，我会等待五分钟的时间。</li>
<li>如果在五分钟的时间内，没有同学问我问题，那么我就下课了；<ul>
<li>在此期间，a同学过来问问题，并且帮他解答，解答完后，我会再次等待五分钟的时间看有没有其他同学问问题；</li>
<li>如果我等待超过了5分钟，就点击了下课（才真正执行这个时间）；</li>
</ul>
</li>
</ul>
</li>
<li><p>生活中节流的例子：</p>
<ul>
<li>比如说有一天我上完课，我说大家有什么问题来问我，但是在一个5分钟之内，不管有多少同学来问问题，我只会解答一个问题；</li>
<li>如果在解答完一个问题后，5分钟之后还没有同学问问题，那么就下课；</li>
</ul>
</li>
</ul>
<h3 id="自定义防抖节流函数"><a href="#自定义防抖节流函数" class="headerlink" title="自定义防抖节流函数"></a>自定义防抖节流函数</h3><ul>
<li>我们按照如下思路来实现：<ul>
<li>防抖基本功能实现：可以实现防抖效果</li>
<li>优化一：优化参数和this指向</li>
<li>优化二：优化取消操作（增加取消功能）</li>
<li>优化三：优化立即执行效果（第一次立即执行）</li>
<li>优化四：优化返回值</li>
</ul>
</li>
<li>我们按照如下思路来实现：<ul>
<li>节流函数的基本实现：可以实现节流效果</li>
<li>优化一：节流最后一次也可以执行</li>
<li>优化二：优化添加取消功能</li>
<li>优化三：优化返回值问题</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义深拷贝函数"><a href="#自定义深拷贝函数" class="headerlink" title="自定义深拷贝函数"></a>自定义深拷贝函数</h3><ul>
<li>前面我们已经学习了对象相互赋值的一些关系，分别包括：<ul>
<li>引入的赋值：指向同一个对象，相互之间会影响；</li>
<li>对象的浅拷贝：只是浅层的拷贝，内部引入对象时，依然会相互影响；</li>
<li>对象的深拷贝：两个对象不再有任何关系，不会相互影响；</li>
</ul>
</li>
<li>前面我们已经可以通过一种方法来实现深拷贝了：JSON.parse<ul>
<li>这种深拷贝的方式其实对于函数、Symbol等是无法处理的；</li>
<li>并且如果存在对象的循环引用，也会报错的；</li>
</ul>
</li>
<li>自定义深拷贝函数：<ul>
<li>1.自定义深拷贝的基本功能；</li>
<li>2.对Symbol的key进行处理；</li>
<li>3.其他数据类型的值进程处理：数组、函数、Symbol、Set、Map；</li>
<li>4.对循环引用的处理；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义事件总线"><a href="#自定义事件总线" class="headerlink" title="自定义事件总线"></a>自定义事件总线</h3><ul>
<li>自定义事件总线属于一种观察者模式，其中包括三个角色：<ul>
<li>发布者（Publisher）：发出事件（Event）；</li>
<li>订阅者（Subscriber）：订阅事件（Event），并且会进行响应（Handler）；</li>
<li>事件总线（EventBus）：无论是发布者还是订阅者都是通过事件总线作为中台的；</li>
</ul>
</li>
<li>当然我们可以选择一些第三方的库：<ul>
<li>Vue2默认是带有事件总线的功能；</li>
<li>Vue3中推荐一些第三方库，比如mitt；</li>
</ul>
</li>
<li>当然我们也可以实现自己的事件总线：<ul>
<li>事件的监听方法on；</li>
<li>事件的发射方法emit；</li>
<li>事件的取消监听off；</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg"></a><div class="post-copyright__author_name">蜗牛浪迹天涯</div><div class="post-copyright__author_desc">宁静致远，热爱生活。</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div><div class="post-reward" onclick="AddRewardMask()"><div class="reward-button" title="赞赏作者"><i class="scoicon sco-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><ul class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a target="_blank" rel="noopener" href="https://bu.dusays.com/2023/11/07/6549e79364fa3.png"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/07/6549e79364fa3.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://bu.dusays.com/2023/11/07/6549e79d02bd6.png" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/07/6549e79d02bd6.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></ul></div></div><script>function RemoveRewardMask() {
    let rewardMainElements = document.querySelectorAll(".reward-main");
    let quitBoxElement = document.querySelector("#quit-box");

    console.log("RemoveRewardMask")

    rewardMainElements.forEach(element => {
        element.style.display = "none";
    });

    if (quitBoxElement) {
        quitBoxElement.style.display = "none";
    }
}

function AddRewardMask() {
    let rewardMainElements = document.querySelectorAll(".reward-main");
    let quitBoxElement = document.querySelector("#quit-box");

    console.log("AddRewardMask")

    rewardMainElements.forEach(element => {
        element.style.display = "flex";
    });

    if (quitBoxElement) {
        quitBoxElement.style.display = "flex";
    }
}</script></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">蜗牛浪迹天涯</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/18/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/201_Ajax/20101_Ajax/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Ajax</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/16/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/105_JavaScript/10506_JS_BOM/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript_BOM</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">一日之计在于晨</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg"><div class="avatar-sticker"><img class="avatar-sticker-img" src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/12/30/659011053e246.png" alt="心情贴纸"></div></div><div class="author-info__description_group"><div class="author-info__description">分享自己对编程的<b>热爱</b>，对美好生活的<b>向往</b>，对知识海洋<b>探索历程</b>。</div><div class="author-info__description2">相信你可以在这里找到对你有用的知识和教程。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><div class="author-info__name">snail289</div><div class="author-info__desc">宁静致远，热爱生活。</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://github.com/DuoSco/Hexo-Theme-slitude" title="Github"><i class="scoicon sco-github-line"></i></a><a class="social-icon" target="_blank" rel="noopener" href="https://space.bilibili.com/1329819902" title="Bilibili"><i class="scoicon sco-bilibili-line"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="scoicon sco-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ECMA%E6%96%B0%E6%8F%8F%E8%BF%B0%E6%A6%82%E5%BF%B5"><span class="toc-text">ECMA新描述概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ECMA%E6%96%B0%E6%8F%8F%E8%BF%B0%E6%A6%82%E5%BF%B5-1"><span class="toc-text">ECMA新描述概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83"><span class="toc-text">词法环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95"><span class="toc-text">环境记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-const%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">let&#x2F;const的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#let-const%E7%9A%84%E4%BD%BF%E7%94%A8-1"><span class="toc-text">let&#x2F;const的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let-const%E6%97%A0%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%90%E5%8D%87"><span class="toc-text">let&#x2F;const无作用域提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-text">暂时性死区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7"><span class="toc-text">window对象添加属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#var-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">var 的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let-const%E7%9A%84%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">let&#x2F;const的块级作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">块级作用域的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#var-let-const%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">var&#x2F;let&#x2F;const的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%94%A8"><span class="toc-text">标签模板字符串使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="toc-text">箭头函数简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">箭头函数的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E7%AE%80%E5%86%99"><span class="toc-text">箭头函数的简写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84-this-%E6%8C%87%E5%90%91"><span class="toc-text">箭头函数的 this 指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD-this-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">箭头函数中 this 的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81-this-%E6%8C%87%E5%90%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">常见 this 指向的面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80"><span class="toc-text">面试题一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C"><span class="toc-text">面试题二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%89"><span class="toc-text">面试题三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9B"><span class="toc-text">面试题四</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">函数的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-text">剩余参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95"><span class="toc-text">展开语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95-1"><span class="toc-text">展开语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%B1%95%E5%BC%80"><span class="toc-text">数组展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80"><span class="toc-text">对象展开</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝与浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">进制与数值的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">进制的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">数值的表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Symbol的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">Symbol的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D"><span class="toc-text">Symbol作为属性名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E5%80%BC%E7%9A%84Symbol"><span class="toc-text">相同值的Symbol</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Set的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">Set的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">Set的常见方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakSet%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">WeakSet的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakSet%E7%9A%84%E4%BD%BF%E7%94%A8-1"><span class="toc-text">WeakSet的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakSet%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">WeakSet的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Map的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">Map的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Map的常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakMap%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">WeakMap的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakMap%E7%9A%84%E4%BD%BF%E7%94%A8-1"><span class="toc-text">WeakMap的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakMap%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">WeakMap的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-%E7%9A%84%E5%85%B6%E4%BB%96%E8%AF%B4%E6%98%8E"><span class="toc-text">ES6 的其他说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES7-ES13"><span class="toc-text">ES7-ES13</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES7"><span class="toc-text">ES7</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-Includes"><span class="toc-text">Array Includes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">指数运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES8"><span class="toc-text">ES8</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-values"><span class="toc-text">Object values</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-entries"><span class="toc-text">Object entries</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-Padding"><span class="toc-text">String Padding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Trailing-Commas"><span class="toc-text">Trailing Commas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-Descriptors"><span class="toc-text">Object Descriptors</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES9"><span class="toc-text">ES9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES10"><span class="toc-text">ES10</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flat-flatMap"><span class="toc-text">flat flatMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-fromEntries"><span class="toc-text">Object fromEntries</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rimStart-trimEnd"><span class="toc-text">rimStart trimEnd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9"><span class="toc-text">其他内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES11"><span class="toc-text">ES11</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BigInt"><span class="toc-text">BigInt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">空值合并操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE"><span class="toc-text">可选链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Global-This"><span class="toc-text">Global This</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-in%E6%A0%87%E5%87%86%E5%8C%96"><span class="toc-text">for..in标准化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9-1"><span class="toc-text">其他内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES12"><span class="toc-text">ES12</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FinalizationRegistry"><span class="toc-text">FinalizationRegistry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WeakRefs"><span class="toc-text">WeakRefs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9-2"><span class="toc-text">其他内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES13"><span class="toc-text">ES13</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#method-at"><span class="toc-text">method.at()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-hasOwn"><span class="toc-text">Object.hasOwn()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class%E7%B1%BB%E6%88%90%E5%91%98%E5%AD%97%E6%AE%B5"><span class="toc-text">class类成员字段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="toc-text">Proxy使用详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">监听对象的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">Proxy基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy%E7%9A%84set%E5%92%8Cget%E6%8D%95%E8%8E%B7%E5%99%A8"><span class="toc-text">Proxy的set和get捕获器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy%E7%9A%84%E6%89%80%E6%9C%89%E6%8D%95%E8%8E%B7%E5%99%A8"><span class="toc-text">Proxy的所有捕获器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#construct%E5%92%8Capply"><span class="toc-text">construct和apply</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflect%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="toc-text">Reflect使用详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflect%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">Reflect的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflect%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">Reflect的常见方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflect%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Reflect的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Receiver%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">Receiver的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflect%E7%9A%84construct"><span class="toc-text">Reflect的construct</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E8%AF%A6%E8%A7%A3"><span class="toc-text">迭代器与生成器详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">什么是迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">可迭代对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">原生迭代器对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">可迭代对象的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E8%BF%AD%E4%BB%A3"><span class="toc-text">自定义类的迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD"><span class="toc-text">迭代器的中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">什么是生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="toc-text">生成器函数执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next%E5%87%BD%E6%95%B0"><span class="toc-text">next函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#return%E5%87%BD%E6%95%B0"><span class="toc-text">return函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw%E5%87%BD%E6%95%B0"><span class="toc-text">throw函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%9B%BF%E4%BB%A3%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">生成器替代迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">生成器实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88"><span class="toc-text">异步处理方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generator%E6%96%B9%E6%A1%88"><span class="toc-text">Generator方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await"><span class="toc-text">async&#x2F;await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0-async-function"><span class="toc-text">异步函数 async function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">异步函数的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">await关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B-1"><span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">操作系统的工作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JS%E7%BA%BF%E7%A8%8B"><span class="toc-text">浏览器中的JS线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">浏览器的事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-1"><span class="toc-text">浏览器的事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-text">宏任务和微任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">常见面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">Node的事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-1"><span class="toc-text">Node的事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="toc-text">Node事件循环的阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1-1"><span class="toc-text">宏任务和微任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E9%A1%BA%E5%BA%8F"><span class="toc-text">Node事件循环顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="toc-text">常见面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88"><span class="toc-text">错误处理方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88-1"><span class="toc-text">错误处理方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">throw关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error%E7%B1%BB%E5%9E%8B"><span class="toc-text">Error类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">异常的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7"><span class="toc-text">异常的捕获</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8Storage"><span class="toc-text">本地存储Storage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Storage"><span class="toc-text">认识Storage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Storage%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-text">Storage常见方法和属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%A9%BA"><span class="toc-text">正则表达式(空)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81"><span class="toc-text">防抖与节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0"><span class="toc-text">认识防抖和节流函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E9%98%B2%E6%8A%96debounce%E5%87%BD%E6%95%B0"><span class="toc-text">认识防抖debounce函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-text">防抖函数的案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%87%86%E5%A4%87"><span class="toc-text">案例准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Underscore%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">Underscore库的介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E8%8A%82%E6%B5%81throttle%E5%87%BD%E6%95%B0"><span class="toc-text">认识节流throttle函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">节流函数的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0"><span class="toc-text">自定义防抖节流函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0"><span class="toc-text">自定义深拷贝函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="toc-text">自定义事件总线</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="scoicon sco-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/004_MySQL_%E8%BF%90%E7%BB%B4%E7%AF%87/" title="MySQL运维篇"><img alt="MySQL运维篇" src= "/img/loading.gif" data-lazy-src="https://tse3-mm.cn.bing.net/th/id/OIP-C.LVnC_YS6D56g7magE9AD_gHaEK?w=189&amp;h=106&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/004_MySQL_%E8%BF%90%E7%BB%B4%E7%AF%87/" title="MySQL运维篇">MySQL运维篇</a><a class="article-recent_post_categories" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/004_MySQL_%E8%BF%90%E7%BB%B4%E7%AF%87/">软件测试</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/003_MySQL_%E8%BF%9B%E9%98%B6%E7%AF%87-02/" title="MySQL进阶篇"><img alt="MySQL进阶篇" src= "/img/loading.gif" data-lazy-src="https://tse2-mm.cn.bing.net/th/id/OIP-C.NHdSfyHemLa4eaycz7QR2AHaEK?w=333&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/003_MySQL_%E8%BF%9B%E9%98%B6%E7%AF%87-02/" title="MySQL进阶篇">MySQL进阶篇</a><a class="article-recent_post_categories" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/003_MySQL_%E8%BF%9B%E9%98%B6%E7%AF%87-02/">软件测试</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/002_MySQL_%E8%BF%9B%E9%98%B6%E7%AF%87-01/" title="MySQL进阶篇"><img alt="MySQL进阶篇" src= "/img/loading.gif" data-lazy-src="https://tse2-mm.cn.bing.net/th/id/OIP-C.XiTVekPE9y_42SZHAbxTZAHaEK?w=318&amp;h=184&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/002_MySQL_%E8%BF%9B%E9%98%B6%E7%AF%87-01/" title="MySQL进阶篇">MySQL进阶篇</a><a class="article-recent_post_categories" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/002_MySQL_%E8%BF%9B%E9%98%B6%E7%AF%87-01/">软件测试</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/001_MySQL_%E5%9F%BA%E7%A1%80%E7%AF%87/" title="MySQL基础篇"><img alt="MySQL基础篇" src= "/img/loading.gif" data-lazy-src="https://tse3-mm.cn.bing.net/th/id/OIP-C.3km1icpIVZB3d4flVs-JRgHaEK?w=318&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/001_MySQL_%E5%9F%BA%E7%A1%80%E7%AF%87/" title="MySQL基础篇">MySQL基础篇</a><a class="article-recent_post_categories" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/003_MySQL/001_MySQL_%E5%9F%BA%E7%A1%80%E7%AF%87/">软件测试</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/002_Linux/001_Linux/" title="Linux"><img alt="Linux" src= "/img/loading.gif" data-lazy-src="https://tse1-mm.cn.bing.net/th/id/OIP-C.XXu034JxuR9rZCV5_40S-wAAAA?w=267&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;pid=1.7"></a><div class="content"><a class="title" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/002_Linux/001_Linux/" title="Linux">Linux</a><a class="article-recent_post_categories" href="/2024/01/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/002_Linux/001_Linux/">软件测试</a></div></div></div></div></div></div></main><footer id="footer"><div id="sco-footer-bar"><div class="footer-logo"><span class="scoicon">首页</span></div><div class="footer-bar-description">来自蜗牛浪迹天涯 - 宁静致远，热爱生活。的文章</div><a class="footer-bar-link" href="/">了解更多</a></div><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com" title="Github"><i class="scoicon sco-bilibili-line"></i></a><a class="deal_link" href="mailto:1448623289@qq.com" title="Mail"><i class="scoicon sco-mail-line"></i></a><div class="footer_mini_logo" id="footer_mini_logo" title="返回顶部" onclick="sco.toTop()"><img src= "/img/loading.gif" data-lazy-src="https://bu.dusays.com/2023/11/08/654af68b25bb8.jpg" alt="返回顶部"></div><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com" title="Bilibili"><i class="scoicon sco-bilibili-line"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://v.douyin.com" title="抖音"><i class="scoicon sco-douyin-fill"></i></a></div><div id="sco-footer"><div class="footer-group"><h3 class="footer-title">导航</h3><div class="footer-links"><a class="footer-item" href="/archives/" title="归档">归档</a><a class="footer-item" href="/categories/" title="分类">分类</a><a class="footer-item" href="/tags/" title="标签">标签</a></div></div><div class="footer-group"><h3 class="footer-title">服务</h3><div class="footer-links"><a class="footer-item" target="_blank" rel="noopener" href="https://aliyun.com/" title="阿里云">阿里云</a><a class="footer-item" target="_blank" rel="noopener" href="https://v6.51.la/" title="51la统计">51la统计</a><a class="footer-item" target="_blank" rel="noopener" href="https://tongji.baidu.com/" title="百度统计">百度统计</a></div></div><div class="footer-group"><h3 class="footer-title">支持</h3><div class="footer-links"><a class="footer-item" href="/about/" title="打赏记录">打赏记录</a><a class="footer-item" target="_blank" rel="noopener" href="https://docs.wzsco.top/" title="文档">文档</a><a class="footer-item" target="_blank" rel="noopener" href="https://blog.wzsco.top/" title="案例">案例</a></div></div><div class="footer-group"><h3 class="footer-title">协议</h3><div class="footer-links"><a class="footer-item" href="/cookies/" title="Cookies">Cookies</a><a class="footer-item" href="/privacy/" title="用户协议">用户协议</a><a class="footer-item" href="/copyright/" title="版权协议">版权协议</a></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 By&nbsp;<a class="footer-bar-link" href="/">snail289</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/DuoSco/hexo-theme-solitude">主题</a><a class="footer-bar-link cc" href="/copyright/"><i class="scoicon sco-copyright-line"></i><i class="scoicon sco-creative-commons-by-line"></i><i class="scoicon sco-creative-commons-nc-line"></i><i class="scoicon sco-creative-commons-nd-line"></i></a></div></div></div><div class="needEndHide" id="cookies-window"><div class="cookies-window-title">协议提醒助手</div><div class="cookies-window-content"><span class="cookies-tip">查看本站为你的个人隐私做出的努力</span><a class="cookies-link" href="/privacy/" title="本站如何保护你的隐私"><i class="scoicon sco-right-btn-fill"></i></a></div></div></footer></div><!-- inject body--><script src="https://cdn.bootcdn.net/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/lib/lazyload.min.js"></script><script src="/lib/snackbar.min.js"></script><script src="/lib/view-image.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/Swiper/9.2.4/swiper-bundle.min.js"></script><div id="js-pjax"><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: 'post',
    toc: true,
    comment: false,
}
</script></div><!-- post-ai)--><script src="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/meting/2.0.1/Meting.min.js"></script><script>const meting_api = 'https://api.injahow.cn/meting/?server=:server&type=:type&id=:id&auth=:auth&r=:r';
</script><script>const coverColorConfig = {
    mode: 'local',
    api: 'https://img2color.meuicat.com/api?img=',
    time: 43200000,
}</script><script src="/lib/cover-color.min.js"></script><!-- waterfall--><script src="/lib/waterfall.min.js"></script><!-- pjax--><script>let pjaxSelectors = [
    'title',
    '#body-wrap',
    '#site-config',
    'meta[name="description"]',
    '#js-pjax',
    'meta[property^="og:"]',
]

const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()
})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- music--><script src="/js/music.js"></script><!-- inject custom body--><script>console.log("body")</script><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="scoicon sco-close-fill"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/extend/search/local-search.js"></script><!-- music--><div class="needEndHide" id="nav-music" onclick="sco.musicToggle()"><div id="nav-music-hoverTips">音乐已暂停</div><meting-js id="8927329843" server="netease" type="playlist" mutex="true" preload="none" data-lrctype="0" order="random" theme="var(--sco-main)"></meting-js></div></body></html><script>const posts=["2024/01/25/软件测试/003_MySQL/004_MySQL_运维篇/","2024/01/25/软件测试/003_MySQL/003_MySQL_进阶篇-02/","2024/01/25/软件测试/003_MySQL/002_MySQL_进阶篇-01/","2024/01/25/软件测试/003_MySQL/001_MySQL_基础篇/","2024/01/25/软件测试/002_Linux/001_Linux/","2024/01/25/软件测试/001_软件测试基础/01_软件测试基础_分类_模型_流程_用例_bug管理/","2024/01/24/Web前端开发/402_Webpack/40201_Webpack/","2024/01/24/Web前端开发/401_TypeScript/40101_TypeScript/","2024/01/23/Web前端开发/303_React/30305_React_Hooks解析/","2024/01/23/Web前端开发/303_React/30304_React_Router/","2024/01/23/Web前端开发/303_React/30303_Redux/","2024/01/23/Web前端开发/303_React/30302_React_过渡动画与CSS样式/","2024/01/23/Web前端开发/303_React/30301_React核心基础/","2024/01/23/Web前端开发/302_Vue3/30207_Vue3_Vue3原理/","2024/01/23/Web前端开发/302_Vue3/30206_Vue3_过渡与动画/","2024/01/23/Web前端开发/302_Vue3/30205_Vue3_自定义指令与插件/","2024/01/23/Web前端开发/302_Vue3/30204_Vue3_Pinia/","2024/01/23/Web前端开发/302_Vue3/30203_Vue3_VueX/","2024/01/23/Web前端开发/302_Vue3/30202_Vue3_Router/","2024/01/23/Web前端开发/302_Vue3/30201_Vue3_基础核心/","2024/01/23/Web前端开发/301_Vue2/30103_Vue2_VueX/","2024/01/23/Web前端开发/301_Vue2/30102_Vue2_VueRouter/","2024/01/23/Web前端开发/301_Vue2/30101_Vue2_Vue2Base/","2024/01/23/Web前端开发/206_模块化/20601_ModuleJS/","2024/01/22/Web前端开发/205_Git/20501_Git/","2024/01/21/Web前端开发/204_Fetch/20401_Fetch/","2024/01/20/Web前端开发/203_Axios/20301_Axios/","2024/01/19/Web前端开发/106_JavaScript高级/10509_JS代码的执行原理/","2024/01/19/Web前端开发/202_Promise/20201_Promise/","2024/01/18/Web前端开发/106_JavaScript高级/10508_浏览器执行过程原理/","2024/01/18/Web前端开发/201_Ajax/20101_Ajax/","2024/01/17/Web前端开发/106_JavaScript高级/10507_JS_ES6-ES13/","2024/01/16/Web前端开发/105_JavaScript/10506_JS_BOM/","2024/01/15/Web前端开发/105_JavaScript/10505_JS_DOM/","2024/01/14/Web前端开发/105_JavaScript/10504_JS_Function/","2024/01/13/Web前端开发/105_JavaScript/10503_JS_Object/","2024/01/12/Web前端开发/105_JavaScript/10502_JS_Array/","2024/01/11/Web前端开发/105_JavaScript/10501_JavaScript_Base/","2024/01/10/Web前端开发/104_Less/10401_Less/","2024/01/09/Web前端开发/103_移动端开发/10304_Flex/","2024/01/08/Web前端开发/103_移动端开发/10303_Rem/","2024/01/07/Web前端开发/103_移动端开发/10302_Percent/","2024/01/06/Web前端开发/103_移动端开发/10301_WebMobileBase/","2024/01/05/Web前端开发/102_HTML5_CSS3/10202_CSS3/","2024/01/04/Web前端开发/102_HTML5_CSS3/10201_HTML5/","2024/01/03/Web前端开发/101_HTML_CSS/10103_CSS/","2024/01/02/Web前端开发/101_HTML_CSS/10102_HTML/","2024/01/01/Web前端开发/101_HTML_CSS/10101_WebBase/"];function toRandomPost(){ pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]); };</script>